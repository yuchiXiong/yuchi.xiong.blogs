---
title: 瞎话 JavaScript 函数式：add(3)(4)一点都不酷
date: 2023-06-15 20:20:00
tags:
  - JavaScript
  - 函数式编程
  - 编程与思考
categories:
  - 好饿，早知道不学编程了
---

> 这可能是一篇很无聊的文章，它无聊就无聊在居然有人觉得这个世界需要这样的文章。

## 国际惯例，写在前面

作为一名野鸡大学毕业的野路子程序员，第一次听说函数式编程这个概念的时候我大概已经工作一年了。~~彼时的我正在做 Ruby&JavaScript 全栈工程师的美梦。~~

一名（暂时）有抱负的工程师通常不会放过任何一个知识盲点，于是我立刻打开某书某乎某SDN找了几篇文章学习。

当柯里化、纯函数、高阶函数等一个个概念出现在我的眼前时，我看的~~如痴如醉~~云里雾里，而在不久之后我就把这些概念完全抛在了脑后。

某天下午当我在看一篇讲 JavaScript Hosting 的文章里我看到如下这样一段代码的时候，我意识到我不能这样继续糊弄自己了。

```JavaScript
function isEven(n) {
  if (n === 0) {
    return true;
  }
  return isOdd(n - 1);
}
 
function isOdd(n) {
  if (n === 0) {
    return false;
  }
  return isEven(n - 1);
}
```

毫无疑问，这段代码让我在短短不到一分钟的时间里经历了困惑、惊奇、恐慌、困惑四种情绪的轮回，那一瞬我忽然觉得**要么我疯了，要么这个世界疯了**。

光阴任然，我在龟速学习的道路上一转眼又混过去两年，当有一天我又看到一篇文章里看到了如下代码块的时候（请注意，下面的代码块是我从原文抄过来的，包括注释），我知道这件事情不能再拖了。

```JavaScript
// 初级程序员
let arr = [1, 2, 3, 4]
let newArr = []
for (var i = 0; i < arr.length; i++) {
  newArr.push(arr[i] + 1)
}
console.log(newArr) //[2, 3, 4, 5]

// 函数式编程
let arr = [1, 2, 3, 4]
let newArr = (arr, fn) => {
  let res = []
  for (var i = 0; i < arr.length; i++) {
    res.push(fn(arr[i]))
  }
  return res
}
let add = item => item + 1 //每项加1
let multi = item => item * 5 //每项乘5
let sum = newArr(arr, add)
let product = newArr(arr, multi)
console.log(sum, product) // [2, 3, 4, 5] [5, 10, 15, 20]
```

## 函数式编程从哪儿来？
提到函数式编程，不得不提的是函数式编程的鼻祖——**Lambda 演算**。

JavaScript 程序员基数众多，Lambda 演算法可能并不是一个人尽皆知的概念，但如果提到同一时期的另一个概念——**图灵机**，相信有部分人会稍微明白些了。

简单来说，图灵机是一种理论上的计算模型，用大白话说就是它抽象了一台机器，而这台机器最大的特点是任何**可以用科学计算解决的问题**都可以用它来解决（也就是说显然也存在不可以用科学计算解决的问题，图灵机亦无能为力）。

图灵机是存在于假象之中的机器，因为世界上并不存在无限长的纸带。但与之同时，图灵机又明确了这样一台机器应该具备的最基本的特性，上世纪的计算机科学家们就是基于这些特性才发明了计算机。

本质上，Lambda 演算法与图灵机有着同样的目的，我们的祖师爷艾伦·图灵（Alan Turing）已经证明了 Lambda 演算法与图灵机的等价性（在 Lambda 演算法中模拟了图灵机的行为），而这一结论有一个更为人尽皆知的名字——**图灵等价**。

正是因为等价性的存在，即便当今的计算机大多都是基于图灵机的，我们依然可以实现大量的基于 Lambda 演算法的编程语言，这些语言正是我们今天所说的**函数式编程语言**。

## Lambda 演算法定义了什么？

不同于图灵机，Lambda 演算法并不是一台机器，而是一种数学模型，是一堆数学公式。

一个**通用的**计算模型要通过有限的手段来抽象无限的问题，Lambda 演算法通过**函数**实现了这种抽象能力。事实上 Lambda 演算法里除了函数就没有别的东西了。

把 Lambda 演算法推一遍不是本文的目的（真要那样放一个 Wiki 的链接就完事了，~~再说我也推不出来。~~）

阿隆佐·丘奇（Alonzo Church）通过一系列的参数传递与消除，实现了对数字、运算以及程序语言三种基本结构（顺序、分支、循环）的抽象，其中关于数字的抽象如今被称为**丘奇数**，这些内容看起来并不容易理解，下面是从 Google 上抄过来的一部分，感兴趣的同学可以自行搜索关键字并深入了解。

```JavaScript
// 数字的抽象
const zero = s => z => z;
const one = s => z => s(z);
const two = s => z => s(s(z));
const three = s => z => s(s(s(z)));
const four = s => z => s(s(s(s(z))));

// 加法的抽象
const add = x => y => s => z => x(s)(y(s)(z));

// 加法的应用
const five = add(two)(three);
```

很容易发现上述代码具备如下几个特点：
1. 所有函数都只有一个参数
2. 参数可以是函数，返回值也可以是函数
3. 纯粹的**数学推演**，每一步结束的时候**量**都是不变的

如果你已经看过一些函数式编程的文章了，那么你应该已经发现了，上述分别对应了**柯里化**、**函数一等公民**以及**不可变性**这些概念，更进一步的讲，**如今谈论函数式编程提到的这些概念均是来源于此。**

当然，要实现完整的运算与三种结构并不是那么简单，这里特地把**循环**拿出来过一下。

Lambda 演算法里是没有 for 循环的，但通过函数模拟循环并不难，通过**递归**来实现循环如今已经不算什么特别的技巧了，面试的时候也经常会遇到诸如「不使用递归实现 deepClone」这样的问题，考察的就是这个。

一个常见的的递归模板如下：

```JavaScript 
function loop(n) {
  if (n === 0) {
    return;
  }
  // do something
  loop(n - 1);
}
```

然鹅，在数学推演的世界里，在一个函数定义完成前调用自身的行为并不严谨（当然，我并不确定这是不是主因，欢迎补充），因而 Lambda 演算法使用了一种特别的技巧来实现递归，这种技巧有一个很酷~~一听就让人想融资~~的名字——**Y Combinator（Y 组合子）**。

关于 Y 组合子这里不过多展开了，感兴趣可以看文末附加的参考文章。

很多人会困惑上述是一坨什么东西，然而如果是细心的同学应该已经发现了，仅通过寥寥无几几个有限的特征（单参数，函数一等公民等），Lambda 演算法实现了一个通用计算模型所必备的所有特性，这也就意味着，Lambda 演算法是完全符合我们对通用计算模型的预期的，而更进一步的描述则是，Lambda 演算法是**图灵完备**的。

## 函数式 !== 函数式
事情并没有就此结束，Lambda 演算法复杂的数学推演让人望而却步，实际上在使用一门基于 Lambda 演算法设计的编程语言开发程序时并不一定要从定义数字/运算/结构开始，正如我们在图灵机上实现的编程语言亦不是从纸带打孔开始定义程序一样。

于是在 Lambda 演算法的基础上，出现了一系列的编程语言，其中最为著名的就是 Lisp 语言家族了，这些语言的共同特点继承自 Lambda 演算法，即通过函数抽象来实现对问题的抽象，由此形成了一种特有的编程范式。

提到编程范式，这里还是要多啰嗦几句的，编程范式是编程语言用于抽象和解决现实问题的**通用**方法，以面向对象编程为例，在面向对象编程中，我们通常把现实世界中的事物抽象成类与对象来对现实问题建模，在这个过程中我们需要考虑类，对象，属性甚至方法之间的组合与复用逻辑，因此又诞生了如继承、多态、封装，接口，抽象类等一系列的概念，这些概念均是编程范式的一部分。同理我们就可以很容易的理解函数式编程的概念了，函数式通过函数的方式来抽象现实问题，而高阶函数，compose 等正是函数式编程中用于组合与复用函数的概念。

时至今日，函数式编程语言百花齐放，各种各样的特性被加入到了函数式编程语言中，这些特性有的是为了更好的性能，有的则为了更好的开发体验，还有的是为了更好的可读性，更有一些是为了提升开发效率。这些特性并不是 Lambda 演算法所必须的，甚至有些特性是从其它编程范式借鉴过来的，一方面这使得广义上的函数式编程与狭义上的函数式编程有了区别，另一方面也使得函数式编程语言的特性更加丰富，更加适合实际开发，事实上当前有很多流行编程语言都结合了多种编程范式，JavaScript 便是其中之一。

## 多范式的 JavaScript
让我们把目光再次回到 JavaScript 上来，JavaScript 是一门多范式的编程语言，它既可以面向对象，也可以面向过程，同时也可以函数式编程。

大家所熟知的工具库如 Lodash 在使用方法上有着相当的函数式的影子：

```JavaScript
const arr = _.map([1, 2, 3], item => item + 1);
const fib = _.memoize(n => n < 2 ? n : fib(n - 1) + fib(n - 2));
```

从语言的抽象能力上来说这无疑是一件好事，它使得 JavaScript 拥有了更加丰富的表现能力。但如果要考虑到 JavaScript 和 Java 在国内的用户基数与入门门槛，那么有些事情就开始变得微妙了。

百度一下「JavaScript 函数式编程」，你会发现大量的文章与其说在讲如何使用 JavaScript 进行函数式编程，不如说是在讲如何使用 JavaScript 实现 Lambda 演算法。

当搜索柯里化的应用时，你会发现大量的文章在讲如何使用柯里化实现一个 add(3)(4) 的函数，却少有人提及最初的 Lambda 演算法本身就只支持一个参数。更进一步的讲，如果使用一个参数就实现对问题抽象，那么 Lambda 演算法就完全不需要支持多个参数，在编程语言为了表达能力而支持多个参数的情况下反向柯里化回去的意义何在？

如果只是这样的误解，或许不至于让人那么难以接受，相比之下有些文章堪称扭曲事实，以纯函数的线程安全完爆面向对象等角度出发最终得到了一个函数式编程比面向对象编程更高级的结论。另一侧还有人完全忽视函数式编程的抽象程度，将其描述为一种“有水平的程序员都在业务开发里大量用到”的范式，如果 Bilibili 的搜索排名还没有变化，那么我很推荐大家去试试搜索「函数式编程」，看看第一个视频的标题，好在我点开视频看了大概10秒以后终于完全理解了这种现状诞生的原因，**流量密码都让你们懂完了，当个人吧**。

## 碎碎念和叠 Buff 环节
本文不针对任何人，也不针对任何文章，只是想说说我自己的看法。

想写这篇文章很久了，考虑到自己对函数式的理解可能并不全面甚至正确，但转念一想人家 add(3)(4) 都有人点赞我有啥不敢写的，笑死。

借这个版块还想大概说一下自己在了解函数式编程的过程中的一些感受，也算是对自己的一个总结吧。

其实接连尝试读了《计算机程序的构造和解释》和《计算的本质》两本书都没读下去，之后大致翻阅了《程序设计方法》一书，这是一本使用 Racket 语言的书，这本书大概从头到尾都没有提到函数式编程这个词，后续又看了 UCB CS61A 关于函数抽象的部分，这两部教材的共同点在并不会反复唠叨什么柯里化、纯函数等乱七八糟的概念，如今回头看来这些才是真正能够教会你函数式编程的东西，函数式编程并不是复杂概念的集合，它只是一种协助你编写代码的方式罢了。印象里好像《Ruby 元编程》中有一句非常经典的话：**根本没有什么元编程，只有编程**，函数式编程大概亦是如此。

最后的最后，感谢能看到这里的你，如果文中有什么错误或者不妥的地方，欢迎指正。

## 参考
- [Lambda 演算科普系列](https://www.bilibili.com/video/BV1pU4y1v7Hj/?spm_id_from=333.337.search-card.all.click)：winter 在 Bilibili 关于 Lambda 演算法的系列科普视频
- [程序设计方法（中文版）](https://book.douban.com/subject/1140942/)：我看的第一版，第二版已经出版了，但是我没看过
- [UCB CS61A](https://inst.eecs.berkeley.edu/~cs61a/fa22/)：链接是 2022 年秋季的课程，这门课程是免费的，每年会同步更新，想看最新的直接搜索 CS61A 即可
- [JavaScript 设计模式与开发实践](https://book.douban.com/subject/26382780/)：多范式的 JavaScript 在实现常用设计模式时并不一定要照抄 Java 的实现，这本书的常见设计模式中很多地方都是使用函数式的方式实现的，值得一读
- [十分钟速通 Y Combinator](https://coderemixer.com/2018/12/07/y-combinator-in-ten-minutes/)：使用 JavaScript 实现 Y 组合子的过程