{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"source/images/ba-shi-pin-ruby-pa-chong-chu-tan/csr.png","path":"images/ba-shi-pin-ruby-pa-chong-chu-tan/csr.png","modified":1,"renderable":0},{"_id":"source/images/ba-shi-pin-ruby-pa-chong-chu-tan/download_video_result.png","path":"images/ba-shi-pin-ruby-pa-chong-chu-tan/download_video_result.png","modified":1,"renderable":0},{"_id":"source/images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list.png","path":"images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list.png","modified":1,"renderable":0},{"_id":"source/images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list_javascript.png","path":"images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list_javascript.png","modified":1,"renderable":0},{"_id":"source/images/ba-shi-pin-ruby-pa-chong-chu-tan/ssr.png","path":"images/ba-shi-pin-ruby-pa-chong-chu-tan/ssr.png","modified":1,"renderable":0},{"_id":"source/images/ba-shi-pin-ruby-pa-chong-chu-tan/video_href.png","path":"images/ba-shi-pin-ruby-pa-chong-chu-tan/video_href.png","modified":1,"renderable":0},{"_id":"source/images/bie-cai-bai-kuai-er-html-ban-de-di-er-tian/2.webp","path":"images/bie-cai-bai-kuai-er-html-ban-de-di-er-tian/2.webp","modified":1,"renderable":0},{"_id":"source/images/bie-cai-bai-kuai-er-html-ban-de-di-yi-tian/1.webp","path":"images/bie-cai-bai-kuai-er-html-ban-de-di-yi-tian/1.webp","modified":1,"renderable":0},{"_id":"source/images/bie-cai-bai-kuai-er-zong-jie/1.png","path":"images/bie-cai-bai-kuai-er-zong-jie/1.png","modified":1,"renderable":0},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/1.webp","path":"images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/1.webp","modified":1,"renderable":0},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/2.webp","path":"images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/2.webp","modified":1,"renderable":0},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/3.webp","path":"images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/3.webp","modified":1,"renderable":0},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/4.webp","path":"images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/4.webp","modified":1,"renderable":0},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/5.webp","path":"images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/5.webp","modified":1,"renderable":0},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/6.webp","path":"images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/6.webp","modified":1,"renderable":0},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/7.webp","path":"images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/7.webp","modified":1,"renderable":0},{"_id":"source/images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/1.webp","path":"images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/1.webp","modified":1,"renderable":0},{"_id":"source/images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/2.webp","path":"images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/2.webp","modified":1,"renderable":0},{"_id":"source/images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/3.webp","path":"images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/3.webp","modified":1,"renderable":0},{"_id":"source/images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/4.webp","path":"images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/4.webp","modified":1,"renderable":0},{"_id":"source/images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/5.webp","path":"images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/5.webp","modified":1,"renderable":0},{"_id":"source/images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/1.webp","path":"images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/1.webp","modified":1,"renderable":0},{"_id":"source/images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/2.webp","path":"images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/2.webp","modified":1,"renderable":0},{"_id":"source/images/jian-dan-de-bian-li-wen-jian-lu-jing/1.webp","path":"images/jian-dan-de-bian-li-wen-jian-lu-jing/1.webp","modified":1,"renderable":0},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-er-tian/1.webp","path":"images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-er-tian/1.webp","modified":1,"renderable":0},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/1.webp","path":"images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/1.webp","modified":1,"renderable":0},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/2.webp","path":"images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/2.webp","modified":1,"renderable":0},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/3.webp","path":"images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/3.webp","modified":1,"renderable":0},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/4.webp","path":"images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/4.webp","modified":1,"renderable":0},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/5.webp","path":"images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/5.webp","modified":1,"renderable":0},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/6.webp","path":"images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/6.webp","modified":1,"renderable":0},{"_id":"themes/cactus-white/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/images/favicon_cactus.ico","path":"images/favicon_cactus.ico","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/images/logo.png","path":"images/logo.png","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/images/theme overview.psd","path":"images/theme overview.psd","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/justified-gallery/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/justified-gallery/justifiedGallery.min.css","path":"lib/justified-gallery/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/styles.css","path":"lib/meslo-LG/styles.css","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Regular.ttf","modified":1,"renderable":1}],"Cache":[{"_id":"themes/cactus-white/LICENSE","hash":"6c2233da6ccbf42c2d2fdd8a137c8a050cb97e21","modified":1651563491092},{"_id":"themes/cactus-white/README.md","hash":"10723cf57ac18800f9693cfdf6e34a94d012c599","modified":1651563491092},{"_id":"themes/cactus-white/_config.yml","hash":"1bea4a02538be152eab82726ac3786b1b46dd754","modified":1651568809012},{"_id":"themes/cactus-white/layout/archive.ejs","hash":"ab9798bf534485a4fed4d3089011421858afdd26","modified":1651563491092},{"_id":"themes/cactus-white/layout/layout.ejs","hash":"8484532ad7c4da22f46fc1394bb2fd9ded34be1f","modified":1651563491092},{"_id":"themes/cactus-white/layout/page.ejs","hash":"d14964cac07f5db45d83af682a7924413f7dd3b6","modified":1651563491092},{"_id":"themes/cactus-white/layout/index.ejs","hash":"0e9f3c57c5219837d5b2f73481992d47e623cea1","modified":1651568733482},{"_id":"themes/cactus-white/layout/post.ejs","hash":"2731e597b5d1714a6f5a775c432e99785f02a3e3","modified":1651563491092},{"_id":"themes/cactus-white/scripts/meta.js","hash":"fa6055a39851c9953d033e70c1614547b94dce60","modified":1651563491092},{"_id":"themes/cactus-white/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/comments.ejs","hash":"853a4500da515ef3facc51a055886eaf8efd080d","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/footer.ejs","hash":"7f6b3f126a58e6734b658ab57bc6b41822bc9342","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/head.ejs","hash":"7782e6b1ce72fcf121f0017d383e2fb87e72c539","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/header.ejs","hash":"889fe54bbfd1fb3357e8c0614d57a437a72f782a","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/pagination.ejs","hash":"ca660c59aec56daa4a7b41715b97434d4a24c37e","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/scripts.ejs","hash":"61b9d9517d07c18360da6177e40436260224eccc","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/search.ejs","hash":"1812a10645f635fa8467bf71eed57e704fa3b7cd","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/styles.ejs","hash":"6eb7189f05783e7044c7dab16e671176329e7cd3","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_mixins.styl","hash":"c921ceb620deedddd38c9cec28190995e8764bab","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_extend.styl","hash":"13e3792845e219246ce9e8b92da26f6c65f4c5c1","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_util.styl","hash":"f8e286a21c7ec3e771d5ddeb2909ac92390af9bd","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_variables.styl","hash":"66cdadb8c13eb08a33dac135be9486d28eec6e79","modified":1651563491092},{"_id":"themes/cactus-white/source/css/style.styl","hash":"4dc2093b87c76fcc1225103145549fe35d22b80a","modified":1651563491092},{"_id":"themes/cactus-white/source/images/favicon_cactus.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1651563491092},{"_id":"themes/cactus-white/source/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1651563491092},{"_id":"themes/cactus-white/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1651563491092},{"_id":"themes/cactus-white/source/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1651563491112},{"_id":"themes/cactus-white/source/js/search.js","hash":"62493e5477618f259eec9b9d626f5bfd000589df","modified":1651563491112},{"_id":"themes/cactus-white/layout/_partial/post/actions_desktop.ejs","hash":"063ae931a6902f192e086fe5cceae587d27ed196","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/post/actions_mobile.ejs","hash":"64d0f85480997a4fa53c99954e9454c189595e9c","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/post/date.ejs","hash":"12a4a7ba6334e3e5c03d9a9601d7779a27c2e082","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/post/share.ejs","hash":"25a3406f97e976ec13239f0d3f32f9e512511f50","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/post/tag.ejs","hash":"bfab03ef986d35ccad583f2d2b575db4a8d2789e","modified":1651563491092},{"_id":"themes/cactus-white/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1651563491092},{"_id":"themes/cactus-white/source/images/logo.png","hash":"199750f3a39251ca97d36ed8317d88dfdc2dfe66","modified":1651563491102},{"_id":"themes/cactus-white/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/arta.styl","hash":"25f4d37cbb65409b2245c7c1bd830f18f5cb4227","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/kimbie.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/paraiso.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_partial/archive.styl","hash":"18fa7f84a9783c5fb56c9f450ea93bd88408e682","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_partial/comments.styl","hash":"11fb41241a13971d23fc3f7e6d60315c7f248396","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_partial/footer.styl","hash":"9828b9c71781768f2ec74d0535d17966ef020b36","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_partial/header.styl","hash":"ba27c6e702e60c3eecb998714ab61284efa4a09b","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_partial/index.styl","hash":"e78a3d6254ea6acb339c177692f4d3df7fab87bd","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_partial/pagination.styl","hash":"03a1b81d60dae3dd55963b7e74a6fee83470e6bb","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_partial/search.styl","hash":"4bf70f1ecc5f2c41003ca51a8b0255e32c8c6eba","modified":1651563491092},{"_id":"themes/cactus-white/source/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1651563491112},{"_id":"themes/cactus-white/source/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1651563491112},{"_id":"themes/cactus-white/source/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1651563491132},{"_id":"themes/cactus-white/source/css/_partial/post/actions_desktop.styl","hash":"fb5106e42ab607181145e5f4fb78b8ae717ac263","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_partial/post/actions_mobile.styl","hash":"e6a802d7ee1023c5fc5fac18bb0ba3dc03ef2ac8","modified":1651563491092},{"_id":"themes/cactus-white/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1651563491092},{"_id":"themes/cactus-white/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1651563491112},{"_id":"themes/cactus-white/source/css/_partial/article.styl","hash":"26a44b26c34285297003e100ddf90e26d3cc88ac","modified":1651569773422},{"_id":"themes/cactus-white/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1651563491112},{"_id":"source/404/index.md","hash":"8d493f624fdd29c8d0266767e56f343d549e16d8","modified":1651560490162},{"_id":"source/_data/projects.json","hash":"868cf928eacf8dd9fb55d2d034c429e41fc59b2a","modified":1651565973242},{"_id":"source/_posts/JavaScript-4-引用类型.md","hash":"c52ec331174b023335615c5079b4d31faf25215b","modified":1651565343582},{"_id":"source/_posts/JavaScript-6-函数表达式.md","hash":"310e606bbeab60b26e46a0e30a0d423db6501fbb","modified":1651565343582},{"_id":"source/_posts/JavaScript-2-基本语法概念.md","hash":"cc8963eacb4c8b39023783934d5f04b0f3e74dc8","modified":1651565343582},{"_id":"source/_posts/Linux下安装nodeJs.md","hash":"5a2e478562341085070fe4766c9425ee92257e0a","modified":1651567585182},{"_id":"source/_posts/Linux下如何安装Ruby.md","hash":"f9d06376f018ff83d2a3ef1105c9f08277ed163c","modified":1651567585172},{"_id":"source/_posts/Linux安装android-studio.md","hash":"f86ddf28df493b93cefde12f077710cca62d929b","modified":1651567585182},{"_id":"source/_posts/Linux实例服务器无法使用mstsc连接.md","hash":"d70022bf087c4611ac6ddd6ac28c0c37a482a9aa","modified":1651567585182},{"_id":"source/_posts/JavaScript-5-面向对象的程序设计.md","hash":"fbaf2ae114d6b41a35726a3d6c180fba03d73248","modified":1651565343582},{"_id":"source/_posts/MongoDB配置.md","hash":"83034afc829524f4ac11ffed2a4514789d40a16d","modified":1651567585142},{"_id":"source/_posts/PringStackTrace方法的一点碎碎念.md","hash":"336b19a10ef0f134bd40b1921d0444704902a628","modified":1651567585182},{"_id":"source/_posts/Nginx配置简单的反向代理.md","hash":"1425d856f587c3c16ee886aee9e76940a40d9f69","modified":1651567585142},{"_id":"source/_posts/Rails-Migrate关于MySQL-lock的一点问题.md","hash":"ee1a8abbdb66e72b04a10d5efaa60f9b76309fd3","modified":1651567585152},{"_id":"source/_posts/Rails使用puma带证书启动.md","hash":"0ed3a33181a018a21cce51c1ae9b41163f1d519d","modified":1651567585152},{"_id":"source/_posts/Rails-test等命令卡死常用的解决方案.md","hash":"7c239659d3deafafe20127ca1ad5eb25173b1e06","modified":1651567585152},{"_id":"source/_posts/RubyMine执行bin目录下指令无权限的解决方案.md","hash":"1c30df47e75ba59eb4cbbbb38bef449d4211de9b","modified":1651567585182},{"_id":"source/_posts/Rails和HTTP422那点事儿.md","hash":"641c75ecb1844391f937a9c2ceb482643de3747c","modified":1651567585152},{"_id":"source/_posts/git-clone速度太慢.md","hash":"75cf2426eeeaa262b03db9fefa9d6e31355e85f4","modified":1651567585182},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1651563091302},{"_id":"source/_posts/Ruby中的数据类型.md","hash":"49eb163852bbafc81af8347344197c1388d889f6","modified":1651567585172},{"_id":"source/_posts/node-sass提示找不到python的解决方案.md","hash":"3649e7829c22f05569925abb203f5bd696fe8381","modified":1651567585182},{"_id":"source/_posts/node-rsa与ruby-openSSL的一点问题.md","hash":"f4520241c0abcd92039508ab8f38b7b8b7886ad8","modified":1651567585172},{"_id":"source/_posts/tortoiseGit-SSH公钥的配置.md","hash":"57f1f7094617cabfbd3a51aa0fa36b7331cc2c43","modified":1651567585142},{"_id":"source/_posts/一次马虎导致的Tomcat闪退…….md","hash":"bfbe3e4cdc479f9ef399367b7d64b37b1db308ba","modified":1651577508412},{"_id":"source/_posts/javascript元编程——基于Proxy实现active_record动态查找.md","hash":"2b4b8cc652a12b897af281736ffdd63d238f528f","modified":1651567585172},{"_id":"source/_posts/云服务器：个人网站初体验.md","hash":"7339603926844554ff27a26f5b28cc2d4183e8a1","modified":1651567585142},{"_id":"source/_posts/关于Url传参的一点问题.md","hash":"98276fde315bab7135064724da8b3d9f2439b7b9","modified":1651571078552},{"_id":"source/_posts/关于浏览器那些蛋疼的东西.md","hash":"71fb41764e0e4f160a640ea03648d8ad69098855","modified":1651570906902},{"_id":"source/_posts/servlet+jsp实现验证码.md","hash":"57a799a518f09984ce2e98885861f950ee4f2900","modified":1651567585182},{"_id":"source/_posts/从Rails视角看现代前端——换一种方式实现SPA.md","hash":"0949019003ca3121a911170bb15d4f81b327ebba","modified":1651570690322},{"_id":"source/_posts/别踩白块儿HTML版的第一天.md","hash":"89422e28050e4a1062be1ac6abb3767aed30cc7c","modified":1651570406562},{"_id":"source/_posts/别踩白块儿总结.md","hash":"d9e6e8c9322bd2f9698a54dd6d31e5d974032312","modified":1651570166892},{"_id":"source/_posts/别踩白块儿HTML版的第二天.md","hash":"b649d79bfb27e75513fe225dba834f210966a567","modified":1651570294972},{"_id":"source/_posts/在Rails里使用MongoDB.md","hash":"040ca5f3334201fc7a42a2f0dba7e6f3640e4158","modified":1651567585152},{"_id":"source/_posts/在Rails中接入微信支付指北.md","hash":"1d6aecc6940c8e7ddf756957163bf3a3d33b74af","modified":1651567585152},{"_id":"source/_posts/在Rails上搭建React服务端渲染瞎谈.md","hash":"a744c911c902a8cfc04027786d5c34a8dc09de19","modified":1651567585152},{"_id":"source/_posts/简单的遍历文件路径.md","hash":"547d8008de4ed508d966d22365ed1197b97d9a09","modified":1651571275002},{"_id":"source/_posts/扒视频！Ruby爬虫初探.md","hash":"b7ba8cf164ed2f227bebad8e7b4d75677c9e8226","modified":1651569926772},{"_id":"source/_posts/小强升职记-一本被名字耽搁的时间管理宝典.md","hash":"f78f304e0c6d3702243dfc4978b1417c5696b4a7","modified":1651567516182},{"_id":"source/_posts/记一次百度云BOS踩坑.md","hash":"7a76c689ceedd28a00fddeaeca83ddc2d97755f7","modified":1651571160282},{"_id":"source/_posts/练手项目：BullShit聊天室（第一天）.md","hash":"3f15e04957857aac2dcf45bef1ed15bc64b1def9","modified":1651571694442},{"_id":"source/_posts/线性表.md","hash":"911bbacf71e399d61b28be97f9c00ce7adfa4fa5","modified":1651571825682},{"_id":"source/_posts/练手项目：BullShit聊天室（第二天）.md","hash":"a7d9a63436282039b95358343e2f155b7b0cdc08","modified":1651571376322},{"_id":"source/_posts/项目从Linux迁移到Windows后找不到Python的问题.md","hash":"ba6fc46349b073acd876797140203f6212e5adad","modified":1651572028192},{"_id":"source/_posts/随机获取到的高质量图片.md","hash":"105c36a244dda34f769792b16626a6dc0c6e019e","modified":1651571761172},{"_id":"source/books/index.md","hash":"cf4163959c23244059cbbbc1c0fe379cc3b2cb73","modified":1651560490162},{"_id":"source/_posts/这可能是最全最细节的rails环境搭建向导了(基于rvm).md","hash":"595ebfe89ea844f8c5ec4ed348ec48a8fc1e3247","modified":1651567585152},{"_id":"source/categories/index.md","hash":"5d2a4f103d27bebbe3eef1604649d0f5c6d86ac6","modified":1651560490162},{"_id":"source/links/index.md","hash":"febcf87eb0ab3c5080578275d25f3970bba39625","modified":1651560490162},{"_id":"source/about/index.md","hash":"bf32fd3b15421f7e2376a9739c8245230a110407","modified":1651565343582},{"_id":"source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1651563545832},{"_id":"source/repository/index.md","hash":"ed0e082c30f233dd5c140d188f1e4bce44bdbf79","modified":1651560490162},{"_id":"source/tags/index.md","hash":"42e9c904ea63b0a7dd4033e2e8f153225bc5cda5","modified":1651565343582},{"_id":"source/series/index.md","hash":"364b07ea1e0b28e792fc7bbddac0069c771dbefa","modified":1651563545832},{"_id":"source/_posts/一些旧的博文归档和待整理文档/小团队无运维，网站宕机人不在？.md","hash":"82acb50c569e4f5d74f706817f5ac9e1fffd9ec8","modified":1651567585142},{"_id":"source/images/ba-shi-pin-ruby-pa-chong-chu-tan/csr.png","hash":"c7e5c0e81bf01bd2386fbd00fbc573843691f4df","modified":1651567585172},{"_id":"source/images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list_javascript.png","hash":"085dc4e866030871a3f609ef8618afe45822557f","modified":1651567585172},{"_id":"source/images/ba-shi-pin-ruby-pa-chong-chu-tan/ssr.png","hash":"12fa00e594c52acde27f7057c7801167234c1b2f","modified":1651567585172},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/1.webp","hash":"23ccd35f09e7517de9a387892885a0ee500936a1","modified":1651570547282},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/4.webp","hash":"1c7b26f312d4a11f7b95f25e225f40d3dc5022dd","modified":1651570540292},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/2.webp","hash":"6488f763a763acd0a3bb435f1b698dfc57d3fa05","modified":1651570547322},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/5.webp","hash":"f6f5bf5d5440deff403e11c2fba5887a75bf3d9a","modified":1651570540382},{"_id":"source/images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/1.webp","hash":"b0a18543f1490899d7d837b12c60daee50cb72dd","modified":1651570860792},{"_id":"source/images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/2.webp","hash":"3e82a807dc11590b9998339a1f750006f1d15c0e","modified":1651570860832},{"_id":"source/images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/5.webp","hash":"3fce7c5f403b73fb5e5186ffb23f7f9ef150ae88","modified":1651570864052},{"_id":"source/images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/1.webp","hash":"e50e3d83f32f198c27e06c7ff3e2deabdbfba151","modified":1651571009732},{"_id":"source/images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/4.webp","hash":"a03cfd4696091e0e8fadbfee72b64ee7861ad2a4","modified":1651570864002},{"_id":"source/images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/2.webp","hash":"1493cd9ff5b8768b4a9bff329a2697995c44c1aa","modified":1651571009832},{"_id":"source/images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/3.webp","hash":"9357a0f82e18479881e15a2541d776a7897289e2","modified":1651570860882},{"_id":"source/_posts/JavaScript-3-变量、作用域和内存问题.md","hash":"7336a56e5bfb0d0838b0addc90ceb9a6da5c2467","modified":1651565343582},{"_id":"source/_posts/JavaScript-1-在HTML中使用JavaScript.md","hash":"de5c6dc57e43ed774dbe14e91e864e64ca25f0f4","modified":1651565343582},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/2.webp","hash":"3b3039032963a883884f52f757f8c2b6f6a53493","modified":1651571541732},{"_id":"source/images/jian-dan-de-bian-li-wen-jian-lu-jing/1.webp","hash":"1c75365db76005380892ad95cc9e70bcafe7fd5b","modified":1651571263222},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/1.webp","hash":"513fd89172fd244a1ff2e8f217b3c474b031850f","modified":1651571541672},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/6.webp","hash":"c7e43eed72383e362ea34e82cb9d458813b1d0f3","modified":1651571541572},{"_id":"source/_posts/一些旧的博文归档和待整理文档/React/redux-react.md","hash":"514fb602965888b8f4bd314716b27d9cffbff91e","modified":1651567585152},{"_id":"source/_posts/一些旧的博文归档和待整理文档/React/redux相关概念.md","hash":"9d2a4f0d43c7b4d14fc6c61d4d8bd8b95f44b862","modified":1651567585152},{"_id":"source/_posts/一些旧的博文归档和待整理文档/设计/ant-design设计原则.md","hash":"e412c48a30cac69e5c095ce6db9bba6ed110d30f","modified":1651495122335},{"_id":"source/_posts/一些旧的博文归档和待整理文档/设计/ant-motion动效设计.md","hash":"03f8cb0da35332e83acb861058bab2f72edb492d","modified":1651495122335},{"_id":"source/_posts/一些旧的博文归档和待整理文档/设计/动效原则.md","hash":"e739a4a245ecefbd74ff1ea1638c9a122422f622","modified":1651495122335},{"_id":"source/_posts/一些旧的博文归档和待整理文档/设计/动效空间.md","hash":"89293c23b4c1894609b9223b4bebe3778d7d8d6f","modified":1651495122335},{"_id":"source/_posts/一些旧的博文归档和待整理文档/设计/全局规则.md","hash":"8c053f5a827c5271f9e9be19244e2a1e8ffdaf0c","modified":1651495122335},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/4.webp","hash":"9bcacc2634b796d57432d5986e89f3413c62fde3","modified":1651571541832},{"_id":"source/_posts/一些旧的博文归档和待整理文档/设计/动效组合.md","hash":"e722201cc1759acb846915e25e3593e7080e06ff","modified":1651495122335},{"_id":"source/_posts/一些旧的博文归档和待整理文档/设计/动效过渡.md","hash":"ade2e684428d2c19bf34b57abd33492852afbde7","modified":1651495122335},{"_id":"source/_posts/一些旧的博文归档和待整理文档/设计/动效速度.md","hash":"58a4631f33ca85b8916cc8ce0f2ab108a45ed2b7","modified":1651495122335},{"_id":"source/_posts/一些旧的博文归档和待整理文档/设计/字体.md","hash":"fb534224d9d27b9410092dd123203e1af038e416","modified":1651495122335},{"_id":"source/_posts/一些旧的博文归档和待整理文档/设计/模板文档.md","hash":"75e636a3e0227dda74887b97ebeeb151dbaa50ee","modified":1651495122335},{"_id":"source/_posts/一些旧的博文归档和待整理文档/设计/自然价值观.md","hash":"efd12aecfce73f75bb9e0ad4d071463bde854367","modified":1651495122335},{"_id":"source/_posts/一些旧的博文归档和待整理文档/设计/设计模式.md","hash":"3fc12144b2ad84a9beb1d2757e1a3ff096073d4e","modified":1651495122335},{"_id":"source/_posts/一些旧的博文归档和待整理文档/设计/原则.md","hash":"7595cd0ac0b18c7c6e0a978dd0c765b244c62ffc","modified":1651495122335},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Html-CSS01（Git，VSCode）.md","hash":"1b4b34a30d248f0eb4b3e8ca554a12f322cadc33","modified":1651567585142},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/5.webp","hash":"24ecb25626c6e959206cabfbac0a402e27cf3fce","modified":1651571541892},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Html-CSS04（基本结构）.md","hash":"539bff226236e2234e97f9aa3ba937ac64f5fd40","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Html-CSS03（盒子模型传参）.md","hash":"5b19ac5e24051d01be45f7e728e32dc91abbdb80","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Html-CSS06（定位，居中）.md","hash":"0ed680535eae24b95abfe9a0561cb056559b174c","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Html-CSS05（盒子模型，浮动）.md","hash":"b4ad7c6469086122a6b6f4b616ced1fb61472d53","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Html-CSS02（基本标签，Css选择器，盒子模型）.md","hash":"a50ee2f2d5b1ad05e6e511e348719a47dae57527","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Html-CSS07（布局，引入，表单元素）.md","hash":"551f4bd949b0cac3850cf91d50cc9e976fca9d7c","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/JavaScript02（沙箱，闭包）.md","hash":"d257ab99c8b6707070e6399835827c2ae83dd392","modified":1651567585142},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/3.webp","hash":"61a39bcf42932436383cbfb0de2aab2523f7c037","modified":1651571541782},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/JavaScript01（原型链，继承）.md","hash":"2b2c34e0dc42e7360709b1a4dc8f9a1fb0e37d9a","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Node-Js（一）.md","hash":"6ad6483d2fc3b2e711b257797141f956940d3721","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Node-Js（三）.md","hash":"a73e31fb23a02dea0176487a1ed2ad889c8239f1","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Node-Js（二）.md","hash":"dc453533692f6bb782c917fb69b8313c03e5d193","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Node-js（四）.md","hash":"c30efce0b15066af3f653e961e3cc4e59aa9fc48","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Php01（基本语法与常用函数）.md","hash":"72ff7a7f225750d95c4ea63c891302f474a95f41","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Php02（连接MySql数据库）.md","hash":"0c79cf5dba7e8db36f57d374ca7db38d8f5c5a1f","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Php03（数据库操作）.md","hash":"ee5b53542448ee76e56f80853e34e8083fdf88cf","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Vue-Router.md","hash":"33f8ccb4fb6b00871429c9763daceba741b4fbf6","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Vue基础（二）.md","hash":"2adc2eed67a6a342a8036c66d383bf134f7634ac","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Vue基础（零）.md","hash":"7ae1a24c1cd764901d84a4beb77db0d1049abe75","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/Vue基础（一）.md","hash":"eeaad3939532537fbb5dde61aa0c1e40b01531cd","modified":1651568110922},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/nodemailer.md","hash":"4eb5856591c857c144211d9acec71fc544312b42","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/webpack（二）.md","hash":"af3f042c3828043b40201f94fd5640714e997be1","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/1.1.汉化.md","hash":"e96cb36cc8c79d0d27ab13862eeb04739305585a","modified":1651567585152},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/1.2.1.配置tomcat找不到sever选项的解决方案.md","hash":"f4f7ef651c853a88ffe02328cae688572653e552","modified":1651567585152},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/1.2.配置tomcat.md","hash":"1de96fc151bb6b7d7d45be0db31a647907e9f87b","modified":1651567585152},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/自学笔记/webpack（一）.md","hash":"f356ea3fa41ece12e47cbc0a49b4fd1ff65d6643","modified":1651567585142},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/3.2.异常处理.md","hash":"caae1d598ab157d7e25fa01fbdd2857982594d30","modified":1651567585152},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/3.4.常用的工具类.md","hash":"1605fd50345b396764d08bbb7c5201dd0421d885","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/3.3.字符串的一点内容.md","hash":"1e9f5f14f22200861bda93cdeaa661e5a3d8fad3","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/3.语法篇.md","hash":"72e2a4d601fed85eb49e8c011651fc2a9ee24180","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/2.环境变量篇.md","hash":"599534dff09b117eb11fc779926c021f76d30171","modified":1651567585152},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/4.1.EL与JSTL.md","hash":"ef9533ecd079215e2c39f275af85d69c14864077","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/4.2.自定义JSP标签.md","hash":"76f52a062114d3b05b1967cae7f50f9288b88866","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/Hibernate第二天.md","hash":"ece29ecf8fa65069910e97a5a2dfe96847063257","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/README.md","hash":"c8765621be641f598fa0e9c66c63643db5efcd58","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/敲！撸一个自定义jsp标签！.md","hash":"ab681451503b8538d84c50b9aca3991698d9f3e0","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/Hibernate初体验.md","hash":"ec67533a9588e298cdb6eb0c635d2422fc978244","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/设计模式（一）：单例模式.md","hash":"858cba60528f2214788e782365cbcf4658b0c074","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/设计模式（二）：工厂模式.md","hash":"369f543f8a4d26cb23a6c0909aca1e25e58a193e","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/javascript/JavaScript-1-在HTML中使用JavaScript.md","hash":"ebb8ac4a54698f0ec37cb624fd62306439e07e3f","modified":1651567585172},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/javascript/JavaScript-3-变量、作用域和内存问题.md","hash":"36a01fc0aa0063996b1d163ba4375f59f039ee71","modified":1651567585172},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/javascript/JavaScript-2-基本语法概念.md","hash":"feace2f10fba625089221000811d61eb9f3c8558","modified":1651567585172},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/javascript/JavaScript-4-引用类型.md","hash":"d75d2edc0af250171560e9b86a9fd489d262b3e6","modified":1651567585172},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/javascript/JavaScript-5-面向对象的程序设计.md","hash":"6a8ad451eac59f6df86576bda5a6d3d48dc2723d","modified":1651567585172},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/images/screenshot_1587863891577.png","hash":"1f05cbb3945a2bfc4652488bdb1a3e42379820b4","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/images/screenshot_1587863861061.png","hash":"8712721f034784a0be59b6c3916ac5195ba94d7f","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/images/screenshot_1587863872701.png","hash":"8712721f034784a0be59b6c3916ac5195ba94d7f","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/1.3.编码配置.md","hash":"c09e635c8044bf5eebc871044cb45620d4b934bf","modified":1651567585152},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/images/screenshot_1587863971323.png","hash":"f0a902f28b61a495c34109fab9cc132f8edd5543","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/images/screenshot_1587873786441.png","hash":"be31eb564de8bb056af1c58d30b4e652887e0354","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/3.1.面向对象.md","hash":"e196f1acc862022fd35d0ec36272e310ed7530cc","modified":1651567585152},{"_id":"themes/cactus-white/source/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1651563491112},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1651563491112},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1651563491112},{"_id":"source/images/ba-shi-pin-ruby-pa-chong-chu-tan/download_video_result.png","hash":"756017e67dd6d77d22937c553755916bb2ea6aa7","modified":1651567585172},{"_id":"source/images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-er-tian/1.webp","hash":"973551fc89ac66b8ac82d3975428e126d9b2d900","modified":1651571359992},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/images/screenshot_1587863582240.png","hash":"96e1098f3a4045ce950653686c176d3eaa12ac7d","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/images/screenshot_1587863766026.png","hash":"bdefdc572fd5f3a249f2695c7a52f34341241909","modified":1651567585162},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1651563491112},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1651563491112},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1651563491112},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/images/screenshot_1587863630769.png","hash":"1c37c2e2910d28fd8ceedacf91c06e607475bbb8","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/images/screenshot_1587864040949.png","hash":"31868813b779e2e4eefa9386e5ea30e5ad9a78b2","modified":1651567585162},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/images/screenshot_1587863826470.png","hash":"b6e17653d7ff32a4658a96b154de40155f1dfa4c","modified":1651567585162},{"_id":"source/images/ba-shi-pin-ruby-pa-chong-chu-tan/video_href.png","hash":"f50779aecebce298645a3f2b5585b2826cf7f4b5","modified":1651567585172},{"_id":"source/images/bie-cai-bai-kuai-er-zong-jie/1.png","hash":"ba25c70a245901d88c02e850fce7bf04517039a1","modified":1651570150472},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/images/screenshot_1587863668067.png","hash":"894bf8c1b7e485438da95141ba6017e6d6b68019","modified":1651567585162},{"_id":"themes/cactus-white/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1651563491112},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/3.webp","hash":"4604d9eed47b6ae109a51d8cb9f09520d9bfd4a2","modified":1651570547432},{"_id":"source/_posts/一些旧的博文归档和待整理文档/技术/编程语言/java/images/screenshot_1587864011277.png","hash":"460f7c1fdb991b66e293c46feb219aa540752f6b","modified":1651567585162},{"_id":"source/images/bie-cai-bai-kuai-er-html-ban-de-di-er-tian/2.webp","hash":"b0b181714af82b5ddae4dfd107331430d89ba202","modified":1651570250832},{"_id":"source/images/bie-cai-bai-kuai-er-html-ban-de-di-yi-tian/1.webp","hash":"ae1d757c76e9164678a9656bba8a6a589d434a40","modified":1651570383122},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/6.webp","hash":"1e8723ecb63cb6b060a956491af73e7be91ddf54","modified":1651570540482},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1651563491122},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1651563491132},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1651563491132},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1651563491112},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1651563491122},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1651563491122},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1651563491122},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1651563491132},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1651563491132},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1651563491132},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1651563491132},{"_id":"themes/cactus-white/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1651563491122},{"_id":"source/images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/7.webp","hash":"9d937c2710b566c0b7dbc857a3f65b34a647681d","modified":1651570540552},{"_id":"source/images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list.png","hash":"553ec31729bc92da36a4de338aba9e8ccc7661d0","modified":1651567585172},{"_id":"themes/cactus-white/source/images/theme overview.psd","hash":"8dc11d9d289c247423911e962c4eb3a556dc67d1","modified":1651563491112}],"Category":[{"name":"JavaScript高级程序设计","_id":"cl2q2mdtp0004r2veba4s5che"},{"name":"好书分享","_id":"cl2q2mduh001tr2vehjon0cx8"},{"name":"程序员的幸福：让代码变成强有力的工具","_id":"cl2q2mduj001zr2vec1zbd7t4"},{"name":"好饿，早知道不学编程了","_id":"cl2q2mduq002wr2ve6rrn3vco"}],"Data":[{"_id":"projects","data":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}],"Page":[{"title":"404 Not Found：该页无法显示","toc":false,"comments":0,"_content":"<script type=\"text/javascript\" src=\"//www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"<%- config.url %>\" homePageName=\"回到我的主页\"></script>\n","source":"404/index.md","raw":"---\ntitle: 404 Not Found：该页无法显示\ntoc: false\ncomments: false\npermalink: /404\n---\n<script type=\"text/javascript\" src=\"//www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"<%- config.url %>\" homePageName=\"回到我的主页\"></script>\n","date":"2022-05-03T06:48:10.162Z","updated":"2022-05-03T06:48:10.162Z","path":"/404.html","layout":"page","_id":"cl2q2mdtg0000r2veafgdfgdn","content":"<script type=\"text/javascript\" src=\"//www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"<%- config.url %>\" homePageName=\"回到我的主页\"></script>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<script type=\"text/javascript\" src=\"//www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"<%- config.url %>\" homePageName=\"回到我的主页\"></script>\n"},{"title":"书单","layout":"books","comments":0,"sidebar":"none","_content":"","source":"books/index.md","raw":"---\ntitle: 书单\nlayout: books\ncomments: false\nsidebar: none\n---","date":"2022-05-03T06:48:10.162Z","updated":"2022-05-03T06:48:10.162Z","path":"books/index.html","_id":"cl2q2mdtn0002r2ve68gj0z73","content":"","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":""},{"title":"关于","description":"个人简介","layout":"about","comments":0,"sidebar":"custom","_content":"菜鸡前端，Rubyer（非Rubyist），特摄厨。\n我的看云：http://docs.xiongyuchi.top/","source":"about/index.md","raw":"---\ntitle: 关于\ndescription: 个人简介\nlayout: about\ncomments: false\nsidebar: custom\n---\n菜鸡前端，Rubyer（非Rubyist），特摄厨。\n我的看云：http://docs.xiongyuchi.top/","date":"2022-05-03T08:09:03.582Z","updated":"2022-05-03T08:09:03.582Z","path":"about/index.html","_id":"cl2q2mdtr0006r2ve39r8f0rg","content":"<p>菜鸡前端，Rubyer（非Rubyist），特摄厨。<br>我的看云：<a href=\"http://docs.xiongyuchi.top/\">http://docs.xiongyuchi.top/</a></p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<p>菜鸡前端，Rubyer（非Rubyist），特摄厨。<br>我的看云：<a href=\"http://docs.xiongyuchi.top/\">http://docs.xiongyuchi.top/</a></p>\n"},{"title":"分类","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\nlayout: categories\ncomments: false\n---\n","date":"2022-05-03T06:48:10.162Z","updated":"2022-05-03T06:48:10.162Z","path":"categories/index.html","_id":"cl2q2mdtt0008r2ve4fiugrfl","content":"","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":""},{"title":"友情链接","layout":"links","comments":1,"sidebar":"none","_content":"","source":"links/index.md","raw":"---\ntitle: 友情链接\nlayout: links\ncomments: true\nsidebar: none\n---","date":"2022-05-03T06:48:10.162Z","updated":"2022-05-03T06:48:10.162Z","path":"links/index.html","_id":"cl2q2mdtu000ar2ve9ye60h6f","content":"","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":""},{"title":"Project","layout":"project","_content":"","source":"project/index.md","raw":"---\ntitle: Project\nlayout: project\n---\n","date":"2022-05-03T07:39:05.832Z","updated":"2022-05-03T07:39:05.832Z","path":"project/index.html","comments":1,"_id":"cl2q2mdtx000er2ve0vn597ki","content":"","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":""},{"title":"Series","layout":"series","_content":"","source":"series/index.md","raw":"---\ntitle: Series\nlayout: series\n---\n","date":"2022-05-03T07:39:05.832Z","updated":"2022-05-03T07:39:05.832Z","path":"series/index.html","comments":1,"_id":"cl2q2mdty000gr2ve03iegbxe","content":"","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":""},{"title":"Repositories","layout":"repository","comments":0,"sidebar":"none","_content":"","source":"repository/index.md","raw":"---\ntitle: Repositories\nlayout: repository\ncomments: false\nsidebar: none\n---\n","date":"2022-05-03T06:48:10.162Z","updated":"2022-05-03T06:48:10.162Z","path":"repository/index.html","_id":"cl2q2mdu0000mr2ve2vaifp9j","content":"","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":""},{"title":"标签","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\nlayout: tags\ncomments: false\n---\n","date":"2022-05-03T08:09:03.582Z","updated":"2022-05-03T08:09:03.582Z","path":"tags/index.html","_id":"cl2q2mdu1000qr2ve9ffp2y7y","content":"","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":""}],"Post":[{"title":"JavaScript(1)在HTML中使用JavaScript","date":"2020-05-23T06:13:11.000Z","_content":"# 1. script标签\n在 `HTML` 中使用 `JavaScript` 很简单，只需要使用 `<script></script>` 标签即可，就像这样：\n~~~ HTML\n<html>\n    <head></head>\n    <body>\n        <script>\n            console.log('hello,javascript');\n        </script>\n    </body>\n</html>\n~~~\n另外我们也可以引入外部脚本就像下面这样：\n~~~ HTML\n<html>\n    <head></head>\n    <body>\n        <script src=\"demo.js\"></script>\n    </body>\n</html>\n~~~\n当我们引入外部脚本后，不应再在同一个 `<script></script>` 标签中嵌入内容，嵌入的内容会被忽略。\n\n## 1.1. async属性\n`async` 属性定义了脚本是否应该立即下载且异步执行，注意：**该属性仅对外部脚本有效**。\n当脚本被标记为 `async` 后，浏览器会立即下载对应脚本，但并不一定会按照其顺序执行，因而**不要使两个异步加载的脚本存在相互依赖的关系**很重要。\n另外，将脚本标记为异步的目的是为了让页面不需要等待该脚本的下载和执行，因此不应该在异步脚本中执行 `dom` 操作。\n~~~ HTML\n<html>\n    <head></head>\n    <body>\n        <script async>\n            console.log('hello,javascript');\n        </script>\n    </body>\n</html>\n~~~\n\n## 1.2. defer属性\n`defer` 属性使脚本在文档被解析完成后执行，同样**该属性仅对外部脚本有效**。\n被标记为 `defer` 的脚本会在浏览器遇到 `</html>` 时才执行。\n~~~ HTML\n<html>\n    <head></head>\n    <body>\n        <script defer=\"defer\">\n            console.log('hello,javascript');\n        </script>\n    </body>\n</html>\n~~~\n\n## 1.3. script标签的实践\n考虑到 `aysnc/defer` 两个属性的兼容问题，我们依然建议将脚本置于 `<body></body>` 的底部。\n~~~ HTML\n<html>\n    <head></head>\n    <body>\n        <script defer=\"defer\">\n            console.log('hello,javascript');\n        </script>\n    </body>\n</html>\n~~~\n\n## 1.3. 其它属性\n`<script></script>` 元素除了上述几个较为常用的属性外，还包含如下属性：\n- charset: 用于指定脚本的字符集，由于大部分浏览器会忽略该值，因此使用的很少。\n- type: 因兼容问题，目前最常用的是 `text/javascript` ，如果没有指定该值，其默认值也会设置为 `text/javascript` 。\n- language: 已废弃。\n\n# 2. noscript标签\n`<noscript></noscript>` 元素中的内容只有在下列情况下才会显示出来：\n- 浏览器不支持脚本\n- 浏览器支持脚本，但脚本被禁用","source":"_posts/JavaScript-1-在HTML中使用JavaScript.md","raw":"---\ntitle: JavaScript(1)在HTML中使用JavaScript\ndate: 2020-05-23 14:13:11\ntags:\n  - JavaScript\n  - 前端\ncategories:\n  - JavaScript高级程序设计\n---\n# 1. script标签\n在 `HTML` 中使用 `JavaScript` 很简单，只需要使用 `<script></script>` 标签即可，就像这样：\n~~~ HTML\n<html>\n    <head></head>\n    <body>\n        <script>\n            console.log('hello,javascript');\n        </script>\n    </body>\n</html>\n~~~\n另外我们也可以引入外部脚本就像下面这样：\n~~~ HTML\n<html>\n    <head></head>\n    <body>\n        <script src=\"demo.js\"></script>\n    </body>\n</html>\n~~~\n当我们引入外部脚本后，不应再在同一个 `<script></script>` 标签中嵌入内容，嵌入的内容会被忽略。\n\n## 1.1. async属性\n`async` 属性定义了脚本是否应该立即下载且异步执行，注意：**该属性仅对外部脚本有效**。\n当脚本被标记为 `async` 后，浏览器会立即下载对应脚本，但并不一定会按照其顺序执行，因而**不要使两个异步加载的脚本存在相互依赖的关系**很重要。\n另外，将脚本标记为异步的目的是为了让页面不需要等待该脚本的下载和执行，因此不应该在异步脚本中执行 `dom` 操作。\n~~~ HTML\n<html>\n    <head></head>\n    <body>\n        <script async>\n            console.log('hello,javascript');\n        </script>\n    </body>\n</html>\n~~~\n\n## 1.2. defer属性\n`defer` 属性使脚本在文档被解析完成后执行，同样**该属性仅对外部脚本有效**。\n被标记为 `defer` 的脚本会在浏览器遇到 `</html>` 时才执行。\n~~~ HTML\n<html>\n    <head></head>\n    <body>\n        <script defer=\"defer\">\n            console.log('hello,javascript');\n        </script>\n    </body>\n</html>\n~~~\n\n## 1.3. script标签的实践\n考虑到 `aysnc/defer` 两个属性的兼容问题，我们依然建议将脚本置于 `<body></body>` 的底部。\n~~~ HTML\n<html>\n    <head></head>\n    <body>\n        <script defer=\"defer\">\n            console.log('hello,javascript');\n        </script>\n    </body>\n</html>\n~~~\n\n## 1.3. 其它属性\n`<script></script>` 元素除了上述几个较为常用的属性外，还包含如下属性：\n- charset: 用于指定脚本的字符集，由于大部分浏览器会忽略该值，因此使用的很少。\n- type: 因兼容问题，目前最常用的是 `text/javascript` ，如果没有指定该值，其默认值也会设置为 `text/javascript` 。\n- language: 已废弃。\n\n# 2. noscript标签\n`<noscript></noscript>` 元素中的内容只有在下列情况下才会显示出来：\n- 浏览器不支持脚本\n- 浏览器支持脚本，但脚本被禁用","slug":"JavaScript-1-在HTML中使用JavaScript","published":1,"updated":"2022-05-03T08:09:03.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdti0001r2vee3bf0etz","content":"<h1 id=\"1-script标签\"><a href=\"#1-script标签\" class=\"headerlink\" title=\"1. script标签\"></a>1. script标签</h1><p>在 <code>HTML</code> 中使用 <code>JavaScript</code> 很简单，只需要使用 <code>&lt;script&gt;&lt;/script&gt;</code> 标签即可，就像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello,javascript&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>另外我们也可以引入外部脚本就像下面这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;demo.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当我们引入外部脚本后，不应再在同一个 <code>&lt;script&gt;&lt;/script&gt;</code> 标签中嵌入内容，嵌入的内容会被忽略。</p>\n<h2 id=\"1-1-async属性\"><a href=\"#1-1-async属性\" class=\"headerlink\" title=\"1.1. async属性\"></a>1.1. async属性</h2><p><code>async</code> 属性定义了脚本是否应该立即下载且异步执行，注意：<strong>该属性仅对外部脚本有效</strong>。<br>当脚本被标记为 <code>async</code> 后，浏览器会立即下载对应脚本，但并不一定会按照其顺序执行，因而<strong>不要使两个异步加载的脚本存在相互依赖的关系</strong>很重要。<br>另外，将脚本标记为异步的目的是为了让页面不需要等待该脚本的下载和执行，因此不应该在异步脚本中执行 <code>dom</code> 操作。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello,javascript&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-defer属性\"><a href=\"#1-2-defer属性\" class=\"headerlink\" title=\"1.2. defer属性\"></a>1.2. defer属性</h2><p><code>defer</code> 属性使脚本在文档被解析完成后执行，同样<strong>该属性仅对外部脚本有效</strong>。<br>被标记为 <code>defer</code> 的脚本会在浏览器遇到 <code>&lt;/html&gt;</code> 时才执行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span>=<span class=\"string\">&quot;defer&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello,javascript&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-script标签的实践\"><a href=\"#1-3-script标签的实践\" class=\"headerlink\" title=\"1.3. script标签的实践\"></a>1.3. script标签的实践</h2><p>考虑到 <code>aysnc/defer</code> 两个属性的兼容问题，我们依然建议将脚本置于 <code>&lt;body&gt;&lt;/body&gt;</code> 的底部。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span>=<span class=\"string\">&quot;defer&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello,javascript&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-其它属性\"><a href=\"#1-3-其它属性\" class=\"headerlink\" title=\"1.3. 其它属性\"></a>1.3. 其它属性</h2><p><code>&lt;script&gt;&lt;/script&gt;</code> 元素除了上述几个较为常用的属性外，还包含如下属性：</p>\n<ul>\n<li>charset: 用于指定脚本的字符集，由于大部分浏览器会忽略该值，因此使用的很少。</li>\n<li>type: 因兼容问题，目前最常用的是 <code>text/javascript</code> ，如果没有指定该值，其默认值也会设置为 <code>text/javascript</code> 。</li>\n<li>language: 已废弃。</li>\n</ul>\n<h1 id=\"2-noscript标签\"><a href=\"#2-noscript标签\" class=\"headerlink\" title=\"2. noscript标签\"></a>2. noscript标签</h1><p><code>&lt;noscript&gt;&lt;/noscript&gt;</code> 元素中的内容只有在下列情况下才会显示出来：</p>\n<ul>\n<li>浏览器不支持脚本</li>\n<li>浏览器支持脚本，但脚本被禁用</li>\n</ul>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"1-script标签\"><a href=\"#1-script标签\" class=\"headerlink\" title=\"1. script标签\"></a>1. script标签</h1><p>在 <code>HTML</code> 中使用 <code>JavaScript</code> 很简单，只需要使用 <code>&lt;script&gt;&lt;/script&gt;</code> 标签即可，就像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello,javascript&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>另外我们也可以引入外部脚本就像下面这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;demo.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当我们引入外部脚本后，不应再在同一个 <code>&lt;script&gt;&lt;/script&gt;</code> 标签中嵌入内容，嵌入的内容会被忽略。</p>\n<h2 id=\"1-1-async属性\"><a href=\"#1-1-async属性\" class=\"headerlink\" title=\"1.1. async属性\"></a>1.1. async属性</h2><p><code>async</code> 属性定义了脚本是否应该立即下载且异步执行，注意：<strong>该属性仅对外部脚本有效</strong>。<br>当脚本被标记为 <code>async</code> 后，浏览器会立即下载对应脚本，但并不一定会按照其顺序执行，因而<strong>不要使两个异步加载的脚本存在相互依赖的关系</strong>很重要。<br>另外，将脚本标记为异步的目的是为了让页面不需要等待该脚本的下载和执行，因此不应该在异步脚本中执行 <code>dom</code> 操作。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello,javascript&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-defer属性\"><a href=\"#1-2-defer属性\" class=\"headerlink\" title=\"1.2. defer属性\"></a>1.2. defer属性</h2><p><code>defer</code> 属性使脚本在文档被解析完成后执行，同样<strong>该属性仅对外部脚本有效</strong>。<br>被标记为 <code>defer</code> 的脚本会在浏览器遇到 <code>&lt;/html&gt;</code> 时才执行。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span>=<span class=\"string\">&quot;defer&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello,javascript&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-script标签的实践\"><a href=\"#1-3-script标签的实践\" class=\"headerlink\" title=\"1.3. script标签的实践\"></a>1.3. script标签的实践</h2><p>考虑到 <code>aysnc/defer</code> 两个属性的兼容问题，我们依然建议将脚本置于 <code>&lt;body&gt;&lt;/body&gt;</code> 的底部。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span>=<span class=\"string\">&quot;defer&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello,javascript&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-其它属性\"><a href=\"#1-3-其它属性\" class=\"headerlink\" title=\"1.3. 其它属性\"></a>1.3. 其它属性</h2><p><code>&lt;script&gt;&lt;/script&gt;</code> 元素除了上述几个较为常用的属性外，还包含如下属性：</p>\n<ul>\n<li>charset: 用于指定脚本的字符集，由于大部分浏览器会忽略该值，因此使用的很少。</li>\n<li>type: 因兼容问题，目前最常用的是 <code>text/javascript</code> ，如果没有指定该值，其默认值也会设置为 <code>text/javascript</code> 。</li>\n<li>language: 已废弃。</li>\n</ul>\n<h1 id=\"2-noscript标签\"><a href=\"#2-noscript标签\" class=\"headerlink\" title=\"2. noscript标签\"></a>2. noscript标签</h1><p><code>&lt;noscript&gt;&lt;/noscript&gt;</code> 元素中的内容只有在下列情况下才会显示出来：</p>\n<ul>\n<li>浏览器不支持脚本</li>\n<li>浏览器支持脚本，但脚本被禁用</li>\n</ul>\n"},{"title":"JavaScript(2)基本语法概念","date":"2020-05-23T06:58:15.000Z","_content":"# 1. 语法要点\n`JavaScript` 语法借鉴了 `C/Java` ，其语法主要有如下特征\n- 严格区分大小写。\n- 标识符（变量/函数名/属性/参数）命名允许使用数字/字母/下划线/美元符号，其中数字不能用作命名开头。\n- 语句结尾的分号不是必要的，但是**建议在语句结尾使用分号**。\n\n# 2. 变量 \n与其它语言相比，`JavaScript` 的变量更加灵活，但并不是所有的特性都应该被使用。\n`JavaScript` 的变量是松散类型的，即它可以保存任何类型的数据，因此如下代码是合法的：\n~~~ JavaScript\nvar message = '666';\nmessage = 666;\n~~~\n`JavaScript` 允许我们修改一个变量的数据类型，但请注意，我们**不提倡这种做法**。\n另外一个特性是，当使用 `var` 关键字定义变量时，实则是在当前作用域里定义了一个局部变量。`JavaScript` 允许定义变量时去掉 `var` 关键字，这样的做法会直接定义一个全局变量，同样，我们也**不提倡这种做法**。\n~~~ JavaScript\nfunction test() {\n    message = 'hi'\n}\nalert(test());\n~~~\n\n# 3. 数据类型\n`JavaScript` 中一共定义了5种基本数据类型，它们分别是：`Number`，`String`，`Boolean`，`Null`，`Undefined`。以及一种复杂数据类型 `Object` 。\n\n## 3.1. 如何判断一个变量的数据类型\n`JavaScript` 提供了 `typeof` 关键字来检测变量的数据类型。\n对于部分值我们很容易得到其对应的结果，就像下面的代码：\n~~~ JavaScript\nconsole.log(typeof 666);\nconsole.log(typeof '666');\nconsole.log(typeof true);\nconsole.log(typeof {});\nconsole.log(typeof function(){});\n~~~\n几乎没有疑问的可以得到输出结果是 `number string boolean object function`。\n但对于如下的代码：\n~~~ JavaScript\nonsole.log(typeof []);\nconsole.log(typeof null);\n~~~\n其输出结果却是 `object object`。\n\n> 有些时候，typeof 操作符会返回一些令人疑惑但技术上却正确的值。比如，调用 typeof null 会返回 \"object\"，因为特殊值 null 被认为是一个空的对象引用。\n> 《JavaScript高级程序设计》\n\n## 3.2. Undefined\n`Undefined` 类型的变量只有 `undefined` 一个值，当一个变量仅声明未赋初值时，它的值就是 `undefined`。\n~~~ JavaScript\nvar msg;\nconsole.log(msg);\n~~~\n如上代码输出 `undefined`。\n> 即便未初始化的变量会自动被赋予undefined值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当typeof操作符返回 \"undefined\" 值时，我们就知道被检测的变量还没有申明，而不是尚未初始化。\n> 《JavaScript高级程序设计》\n\n## 3.3. Null\n`Null` 类型的变量和 `Undefined` 一样只有一个值那就是 `null` , `null` 变量存储的实际是一个空指针对象，也正是因为如此， `typeof null` 返回了 `\"objcet\"`。\n当使用 `==` 运算符在判断 `null` 和 `undefined` 时会返回 `true`，因为该操作符会发生隐式转换。\n> 只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象的惯例，而且也有助于进一步区分null和undefined。\n> 《JavaScript高级程序设计》\n\n## 3.4. Boolean\n`Boolean` 有两个值 `true` 和 `false` ，在 `JavaScript` 中，所有的类型都可以转化为 `Boolean` 值。\n~~~ JavaScript\nvar message = 'hello, world!';\nvar messageBoolean = Boolean(message);\n~~~\n\n## 3.5. Number\n`JavaScript` 中的 `Number` 类型与其它语言并没有太大的差异。它的数字返回存储在 `Number.MAX_VALUE` 和 `Number.MIN_VALUE` 中，如果超出这个范围，则会被转化为 `Infinity/-Infinity`。有一点需要注意：`Infinity/-Infinity` 是无法参与计算的。另外，可以使用 `isFinite()` 来判断一个值是否为 `Infinity/-Infinity`。\n另一个比较特殊的 `Number` 类型值是 `NaN`，即 `Not a Number`。任何涉及 `NaN` 的操作最后都会返回 `NaN`，其次 `NaN` 与任何值都不相等，包括他自身，因而当需要判断时，可以使用 `isNaN()` 函数。\n\n## 3.6. String\n### 3.6.1 字符字面量\n字符字面量又叫转义序列，如果你接触过 `C/Java` 系列的格式化输出，就很容易理解，我们可以使用 `\\n` 等字符来表示换行等特殊字符。但需要注意的一点是，一个字符字面量通常被解析为一个字符串，因此它的长度是1。\n~~~ JavaScript\nconsole.log('\\n'.length);\n~~~\n如上代码输出为1。\n\n### 3.6.2 字符串的特性\n**字符串一旦被创建，将不可被更改**，如果要修改某个字符串变量的值，实际在后台是先创建了一个新的字符串，然后销毁旧的字符串。\n\n### 3.6.3 将任意类型转换至字符串\n- toString()方法\n- String()构造方法\n- 在该值后面追加空字符\n\n\n## 3.7 Object\n如下代码都是合法的变量定义，但后者并不是推荐的语法。\n~~~ JavaScript\nvar obj_1 = new Object();\nvar obj_2 = new Object;\n~~~\n\n# 4. 操作符\n几乎所有语言中的操作符都遵循数学逻辑，因而此处重点描述 `JavaScript` 中那些较为特殊的特性。\n## 4.1 自增/自减运算符\n自增/自减运算符通常用于对 `Number` 类型的操作，然而 `JavaScript` 中你却可以对任何类型的数据使用该运算符。\n背后实际先尝试对该变量进行转化，而后进行自增/自减运算。\n\n# 5. 语句\n`JavaScript` 中那些语句也基本与 `C/Java` 保持一致，此处略过。\n\n# 6. 函数\n## 6.1 arguments\n函数体内可以使用 `arguments` 来获取参数数组，不过需要注意的是，它虽然可以使用下标的方式获取到元素，但其实并不是数组。\n~~~ JavaScript\nfunction print_args (a,b,c,e) {\n  console.log(arguments[0], arguments[1], arguments[2]);\n}\n\nprint_args(1,2,3,4);\n~~~ \n以上代码输出结果为 `1 2 3`。\n另外 `arguments` 中的值始终与入参保持一致，因而当函数内部修改了入参或修改了 `arguments` 元素的值，则对应的 `arguments` 元素值/入参的值都会发生变化。当然，它们的内存空间依然是独立的，但值是同步的。\n最后，在严格模式下是无法修改 `arguments` 对象的值的。\n\n## 6.2 没有重载\n就像标题所说的，`JavaScript` 函数是没有重载的，任何同名函数的定义都会覆盖原有的函数定义。","source":"_posts/JavaScript-2-基本语法概念.md","raw":"---\ntitle: JavaScript(2)基本语法概念\ndate: 2020-05-23 14:58:15\ntags:\n  - JavaScript\n  - 前端\ncategories:\n  - JavaScript高级程序设计\n---\n# 1. 语法要点\n`JavaScript` 语法借鉴了 `C/Java` ，其语法主要有如下特征\n- 严格区分大小写。\n- 标识符（变量/函数名/属性/参数）命名允许使用数字/字母/下划线/美元符号，其中数字不能用作命名开头。\n- 语句结尾的分号不是必要的，但是**建议在语句结尾使用分号**。\n\n# 2. 变量 \n与其它语言相比，`JavaScript` 的变量更加灵活，但并不是所有的特性都应该被使用。\n`JavaScript` 的变量是松散类型的，即它可以保存任何类型的数据，因此如下代码是合法的：\n~~~ JavaScript\nvar message = '666';\nmessage = 666;\n~~~\n`JavaScript` 允许我们修改一个变量的数据类型，但请注意，我们**不提倡这种做法**。\n另外一个特性是，当使用 `var` 关键字定义变量时，实则是在当前作用域里定义了一个局部变量。`JavaScript` 允许定义变量时去掉 `var` 关键字，这样的做法会直接定义一个全局变量，同样，我们也**不提倡这种做法**。\n~~~ JavaScript\nfunction test() {\n    message = 'hi'\n}\nalert(test());\n~~~\n\n# 3. 数据类型\n`JavaScript` 中一共定义了5种基本数据类型，它们分别是：`Number`，`String`，`Boolean`，`Null`，`Undefined`。以及一种复杂数据类型 `Object` 。\n\n## 3.1. 如何判断一个变量的数据类型\n`JavaScript` 提供了 `typeof` 关键字来检测变量的数据类型。\n对于部分值我们很容易得到其对应的结果，就像下面的代码：\n~~~ JavaScript\nconsole.log(typeof 666);\nconsole.log(typeof '666');\nconsole.log(typeof true);\nconsole.log(typeof {});\nconsole.log(typeof function(){});\n~~~\n几乎没有疑问的可以得到输出结果是 `number string boolean object function`。\n但对于如下的代码：\n~~~ JavaScript\nonsole.log(typeof []);\nconsole.log(typeof null);\n~~~\n其输出结果却是 `object object`。\n\n> 有些时候，typeof 操作符会返回一些令人疑惑但技术上却正确的值。比如，调用 typeof null 会返回 \"object\"，因为特殊值 null 被认为是一个空的对象引用。\n> 《JavaScript高级程序设计》\n\n## 3.2. Undefined\n`Undefined` 类型的变量只有 `undefined` 一个值，当一个变量仅声明未赋初值时，它的值就是 `undefined`。\n~~~ JavaScript\nvar msg;\nconsole.log(msg);\n~~~\n如上代码输出 `undefined`。\n> 即便未初始化的变量会自动被赋予undefined值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当typeof操作符返回 \"undefined\" 值时，我们就知道被检测的变量还没有申明，而不是尚未初始化。\n> 《JavaScript高级程序设计》\n\n## 3.3. Null\n`Null` 类型的变量和 `Undefined` 一样只有一个值那就是 `null` , `null` 变量存储的实际是一个空指针对象，也正是因为如此， `typeof null` 返回了 `\"objcet\"`。\n当使用 `==` 运算符在判断 `null` 和 `undefined` 时会返回 `true`，因为该操作符会发生隐式转换。\n> 只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象的惯例，而且也有助于进一步区分null和undefined。\n> 《JavaScript高级程序设计》\n\n## 3.4. Boolean\n`Boolean` 有两个值 `true` 和 `false` ，在 `JavaScript` 中，所有的类型都可以转化为 `Boolean` 值。\n~~~ JavaScript\nvar message = 'hello, world!';\nvar messageBoolean = Boolean(message);\n~~~\n\n## 3.5. Number\n`JavaScript` 中的 `Number` 类型与其它语言并没有太大的差异。它的数字返回存储在 `Number.MAX_VALUE` 和 `Number.MIN_VALUE` 中，如果超出这个范围，则会被转化为 `Infinity/-Infinity`。有一点需要注意：`Infinity/-Infinity` 是无法参与计算的。另外，可以使用 `isFinite()` 来判断一个值是否为 `Infinity/-Infinity`。\n另一个比较特殊的 `Number` 类型值是 `NaN`，即 `Not a Number`。任何涉及 `NaN` 的操作最后都会返回 `NaN`，其次 `NaN` 与任何值都不相等，包括他自身，因而当需要判断时，可以使用 `isNaN()` 函数。\n\n## 3.6. String\n### 3.6.1 字符字面量\n字符字面量又叫转义序列，如果你接触过 `C/Java` 系列的格式化输出，就很容易理解，我们可以使用 `\\n` 等字符来表示换行等特殊字符。但需要注意的一点是，一个字符字面量通常被解析为一个字符串，因此它的长度是1。\n~~~ JavaScript\nconsole.log('\\n'.length);\n~~~\n如上代码输出为1。\n\n### 3.6.2 字符串的特性\n**字符串一旦被创建，将不可被更改**，如果要修改某个字符串变量的值，实际在后台是先创建了一个新的字符串，然后销毁旧的字符串。\n\n### 3.6.3 将任意类型转换至字符串\n- toString()方法\n- String()构造方法\n- 在该值后面追加空字符\n\n\n## 3.7 Object\n如下代码都是合法的变量定义，但后者并不是推荐的语法。\n~~~ JavaScript\nvar obj_1 = new Object();\nvar obj_2 = new Object;\n~~~\n\n# 4. 操作符\n几乎所有语言中的操作符都遵循数学逻辑，因而此处重点描述 `JavaScript` 中那些较为特殊的特性。\n## 4.1 自增/自减运算符\n自增/自减运算符通常用于对 `Number` 类型的操作，然而 `JavaScript` 中你却可以对任何类型的数据使用该运算符。\n背后实际先尝试对该变量进行转化，而后进行自增/自减运算。\n\n# 5. 语句\n`JavaScript` 中那些语句也基本与 `C/Java` 保持一致，此处略过。\n\n# 6. 函数\n## 6.1 arguments\n函数体内可以使用 `arguments` 来获取参数数组，不过需要注意的是，它虽然可以使用下标的方式获取到元素，但其实并不是数组。\n~~~ JavaScript\nfunction print_args (a,b,c,e) {\n  console.log(arguments[0], arguments[1], arguments[2]);\n}\n\nprint_args(1,2,3,4);\n~~~ \n以上代码输出结果为 `1 2 3`。\n另外 `arguments` 中的值始终与入参保持一致，因而当函数内部修改了入参或修改了 `arguments` 元素的值，则对应的 `arguments` 元素值/入参的值都会发生变化。当然，它们的内存空间依然是独立的，但值是同步的。\n最后，在严格模式下是无法修改 `arguments` 对象的值的。\n\n## 6.2 没有重载\n就像标题所说的，`JavaScript` 函数是没有重载的，任何同名函数的定义都会覆盖原有的函数定义。","slug":"JavaScript-2-基本语法概念","published":1,"updated":"2022-05-03T08:09:03.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdto0003r2vefglfbyqq","content":"<h1 id=\"1-语法要点\"><a href=\"#1-语法要点\" class=\"headerlink\" title=\"1. 语法要点\"></a>1. 语法要点</h1><p><code>JavaScript</code> 语法借鉴了 <code>C/Java</code> ，其语法主要有如下特征</p>\n<ul>\n<li>严格区分大小写。</li>\n<li>标识符（变量&#x2F;函数名&#x2F;属性&#x2F;参数）命名允许使用数字&#x2F;字母&#x2F;下划线&#x2F;美元符号，其中数字不能用作命名开头。</li>\n<li>语句结尾的分号不是必要的，但是<strong>建议在语句结尾使用分号</strong>。</li>\n</ul>\n<h1 id=\"2-变量\"><a href=\"#2-变量\" class=\"headerlink\" title=\"2. 变量\"></a>2. 变量</h1><p>与其它语言相比，<code>JavaScript</code> 的变量更加灵活，但并不是所有的特性都应该被使用。<br><code>JavaScript</code> 的变量是松散类型的，即它可以保存任何类型的数据，因此如下代码是合法的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">&#x27;666&#x27;</span>;</span><br><span class=\"line\">message = <span class=\"number\">666</span>;</span><br></pre></td></tr></table></figure>\n<p><code>JavaScript</code> 允许我们修改一个变量的数据类型，但请注意，我们<strong>不提倡这种做法</strong>。<br>另外一个特性是，当使用 <code>var</code> 关键字定义变量时，实则是在当前作用域里定义了一个局部变量。<code>JavaScript</code> 允许定义变量时去掉 <code>var</code> 关键字，这样的做法会直接定义一个全局变量，同样，我们也<strong>不提倡这种做法</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    message = <span class=\"string\">&#x27;hi&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(<span class=\"title function_\">test</span>());</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-数据类型\"><a href=\"#3-数据类型\" class=\"headerlink\" title=\"3. 数据类型\"></a>3. 数据类型</h1><p><code>JavaScript</code> 中一共定义了5种基本数据类型，它们分别是：<code>Number</code>，<code>String</code>，<code>Boolean</code>，<code>Null</code>，<code>Undefined</code>。以及一种复杂数据类型 <code>Object</code> 。</p>\n<h2 id=\"3-1-如何判断一个变量的数据类型\"><a href=\"#3-1-如何判断一个变量的数据类型\" class=\"headerlink\" title=\"3.1. 如何判断一个变量的数据类型\"></a>3.1. 如何判断一个变量的数据类型</h2><p><code>JavaScript</code> 提供了 <code>typeof</code> 关键字来检测变量的数据类型。<br>对于部分值我们很容易得到其对应的结果，就像下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"number\">666</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;666&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> &#123;&#125;);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;);</span><br></pre></td></tr></table></figure>\n<p>几乎没有疑问的可以得到输出结果是 <code>number string boolean object function</code>。<br>但对于如下的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onsole.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> []);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>其输出结果却是 <code>object object</code>。</p>\n<blockquote>\n<p>有些时候，typeof 操作符会返回一些令人疑惑但技术上却正确的值。比如，调用 typeof null 会返回 “object”，因为特殊值 null 被认为是一个空的对象引用。<br>《JavaScript高级程序设计》</p>\n</blockquote>\n<h2 id=\"3-2-Undefined\"><a href=\"#3-2-Undefined\" class=\"headerlink\" title=\"3.2. Undefined\"></a>3.2. Undefined</h2><p><code>Undefined</code> 类型的变量只有 <code>undefined</code> 一个值，当一个变量仅声明未赋初值时，它的值就是 <code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(msg);</span><br></pre></td></tr></table></figure>\n<p>如上代码输出 <code>undefined</code>。</p>\n<blockquote>\n<p>即便未初始化的变量会自动被赋予undefined值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当typeof操作符返回 “undefined” 值时，我们就知道被检测的变量还没有申明，而不是尚未初始化。<br>《JavaScript高级程序设计》</p>\n</blockquote>\n<h2 id=\"3-3-Null\"><a href=\"#3-3-Null\" class=\"headerlink\" title=\"3.3. Null\"></a>3.3. Null</h2><p><code>Null</code> 类型的变量和 <code>Undefined</code> 一样只有一个值那就是 <code>null</code> , <code>null</code> 变量存储的实际是一个空指针对象，也正是因为如此， <code>typeof null</code> 返回了 <code>&quot;objcet&quot;</code>。<br>当使用 <code>==</code> 运算符在判断 <code>null</code> 和 <code>undefined</code> 时会返回 <code>true</code>，因为该操作符会发生隐式转换。</p>\n<blockquote>\n<p>只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象的惯例，而且也有助于进一步区分null和undefined。<br>《JavaScript高级程序设计》</p>\n</blockquote>\n<h2 id=\"3-4-Boolean\"><a href=\"#3-4-Boolean\" class=\"headerlink\" title=\"3.4. Boolean\"></a>3.4. Boolean</h2><p><code>Boolean</code> 有两个值 <code>true</code> 和 <code>false</code> ，在 <code>JavaScript</code> 中，所有的类型都可以转化为 <code>Boolean</code> 值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">&#x27;hello, world!&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> messageBoolean = <span class=\"title class_\">Boolean</span>(message);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-Number\"><a href=\"#3-5-Number\" class=\"headerlink\" title=\"3.5. Number\"></a>3.5. Number</h2><p><code>JavaScript</code> 中的 <code>Number</code> 类型与其它语言并没有太大的差异。它的数字返回存储在 <code>Number.MAX_VALUE</code> 和 <code>Number.MIN_VALUE</code> 中，如果超出这个范围，则会被转化为 <code>Infinity/-Infinity</code>。有一点需要注意：<code>Infinity/-Infinity</code> 是无法参与计算的。另外，可以使用 <code>isFinite()</code> 来判断一个值是否为 <code>Infinity/-Infinity</code>。<br>另一个比较特殊的 <code>Number</code> 类型值是 <code>NaN</code>，即 <code>Not a Number</code>。任何涉及 <code>NaN</code> 的操作最后都会返回 <code>NaN</code>，其次 <code>NaN</code> 与任何值都不相等，包括他自身，因而当需要判断时，可以使用 <code>isNaN()</code> 函数。</p>\n<h2 id=\"3-6-String\"><a href=\"#3-6-String\" class=\"headerlink\" title=\"3.6. String\"></a>3.6. String</h2><h3 id=\"3-6-1-字符字面量\"><a href=\"#3-6-1-字符字面量\" class=\"headerlink\" title=\"3.6.1 字符字面量\"></a>3.6.1 字符字面量</h3><p>字符字面量又叫转义序列，如果你接触过 <code>C/Java</code> 系列的格式化输出，就很容易理解，我们可以使用 <code>\\n</code> 等字符来表示换行等特殊字符。但需要注意的一点是，一个字符字面量通常被解析为一个字符串，因此它的长度是1。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;\\n&#x27;</span>.<span class=\"property\">length</span>);</span><br></pre></td></tr></table></figure>\n<p>如上代码输出为1。</p>\n<h3 id=\"3-6-2-字符串的特性\"><a href=\"#3-6-2-字符串的特性\" class=\"headerlink\" title=\"3.6.2 字符串的特性\"></a>3.6.2 字符串的特性</h3><p><strong>字符串一旦被创建，将不可被更改</strong>，如果要修改某个字符串变量的值，实际在后台是先创建了一个新的字符串，然后销毁旧的字符串。</p>\n<h3 id=\"3-6-3-将任意类型转换至字符串\"><a href=\"#3-6-3-将任意类型转换至字符串\" class=\"headerlink\" title=\"3.6.3 将任意类型转换至字符串\"></a>3.6.3 将任意类型转换至字符串</h3><ul>\n<li>toString()方法</li>\n<li>String()构造方法</li>\n<li>在该值后面追加空字符</li>\n</ul>\n<h2 id=\"3-7-Object\"><a href=\"#3-7-Object\" class=\"headerlink\" title=\"3.7 Object\"></a>3.7 Object</h2><p>如下代码都是合法的变量定义，但后者并不是推荐的语法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj_1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj_2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-操作符\"><a href=\"#4-操作符\" class=\"headerlink\" title=\"4. 操作符\"></a>4. 操作符</h1><p>几乎所有语言中的操作符都遵循数学逻辑，因而此处重点描述 <code>JavaScript</code> 中那些较为特殊的特性。</p>\n<h2 id=\"4-1-自增-x2F-自减运算符\"><a href=\"#4-1-自增-x2F-自减运算符\" class=\"headerlink\" title=\"4.1 自增&#x2F;自减运算符\"></a>4.1 自增&#x2F;自减运算符</h2><p>自增&#x2F;自减运算符通常用于对 <code>Number</code> 类型的操作，然而 <code>JavaScript</code> 中你却可以对任何类型的数据使用该运算符。<br>背后实际先尝试对该变量进行转化，而后进行自增&#x2F;自减运算。</p>\n<h1 id=\"5-语句\"><a href=\"#5-语句\" class=\"headerlink\" title=\"5. 语句\"></a>5. 语句</h1><p><code>JavaScript</code> 中那些语句也基本与 <code>C/Java</code> 保持一致，此处略过。</p>\n<h1 id=\"6-函数\"><a href=\"#6-函数\" class=\"headerlink\" title=\"6. 函数\"></a>6. 函数</h1><h2 id=\"6-1-arguments\"><a href=\"#6-1-arguments\" class=\"headerlink\" title=\"6.1 arguments\"></a>6.1 arguments</h2><p>函数体内可以使用 <code>arguments</code> 来获取参数数组，不过需要注意的是，它虽然可以使用下标的方式获取到元素，但其实并不是数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">print_args</span> (a,b,c,e) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>], <span class=\"variable language_\">arguments</span>[<span class=\"number\">1</span>], <span class=\"variable language_\">arguments</span>[<span class=\"number\">2</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">print_args</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<p>以上代码输出结果为 <code>1 2 3</code>。<br>另外 <code>arguments</code> 中的值始终与入参保持一致，因而当函数内部修改了入参或修改了 <code>arguments</code> 元素的值，则对应的 <code>arguments</code> 元素值&#x2F;入参的值都会发生变化。当然，它们的内存空间依然是独立的，但值是同步的。<br>最后，在严格模式下是无法修改 <code>arguments</code> 对象的值的。</p>\n<h2 id=\"6-2-没有重载\"><a href=\"#6-2-没有重载\" class=\"headerlink\" title=\"6.2 没有重载\"></a>6.2 没有重载</h2><p>就像标题所说的，<code>JavaScript</code> 函数是没有重载的，任何同名函数的定义都会覆盖原有的函数定义。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"1-语法要点\"><a href=\"#1-语法要点\" class=\"headerlink\" title=\"1. 语法要点\"></a>1. 语法要点</h1><p><code>JavaScript</code> 语法借鉴了 <code>C/Java</code> ，其语法主要有如下特征</p>\n<ul>\n<li>严格区分大小写。</li>\n<li>标识符（变量&#x2F;函数名&#x2F;属性&#x2F;参数）命名允许使用数字&#x2F;字母&#x2F;下划线&#x2F;美元符号，其中数字不能用作命名开头。</li>\n<li>语句结尾的分号不是必要的，但是<strong>建议在语句结尾使用分号</strong>。</li>\n</ul>\n<h1 id=\"2-变量\"><a href=\"#2-变量\" class=\"headerlink\" title=\"2. 变量\"></a>2. 变量</h1><p>与其它语言相比，<code>JavaScript</code> 的变量更加灵活，但并不是所有的特性都应该被使用。<br><code>JavaScript</code> 的变量是松散类型的，即它可以保存任何类型的数据，因此如下代码是合法的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">&#x27;666&#x27;</span>;</span><br><span class=\"line\">message = <span class=\"number\">666</span>;</span><br></pre></td></tr></table></figure>\n<p><code>JavaScript</code> 允许我们修改一个变量的数据类型，但请注意，我们<strong>不提倡这种做法</strong>。<br>另外一个特性是，当使用 <code>var</code> 关键字定义变量时，实则是在当前作用域里定义了一个局部变量。<code>JavaScript</code> 允许定义变量时去掉 <code>var</code> 关键字，这样的做法会直接定义一个全局变量，同样，我们也<strong>不提倡这种做法</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    message = <span class=\"string\">&#x27;hi&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">alert</span>(<span class=\"title function_\">test</span>());</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-数据类型\"><a href=\"#3-数据类型\" class=\"headerlink\" title=\"3. 数据类型\"></a>3. 数据类型</h1><p><code>JavaScript</code> 中一共定义了5种基本数据类型，它们分别是：<code>Number</code>，<code>String</code>，<code>Boolean</code>，<code>Null</code>，<code>Undefined</code>。以及一种复杂数据类型 <code>Object</code> 。</p>\n<h2 id=\"3-1-如何判断一个变量的数据类型\"><a href=\"#3-1-如何判断一个变量的数据类型\" class=\"headerlink\" title=\"3.1. 如何判断一个变量的数据类型\"></a>3.1. 如何判断一个变量的数据类型</h2><p><code>JavaScript</code> 提供了 <code>typeof</code> 关键字来检测变量的数据类型。<br>对于部分值我们很容易得到其对应的结果，就像下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"number\">666</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;666&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">true</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> &#123;&#125;);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;&#125;);</span><br></pre></td></tr></table></figure>\n<p>几乎没有疑问的可以得到输出结果是 <code>number string boolean object function</code>。<br>但对于如下的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onsole.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> []);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>其输出结果却是 <code>object object</code>。</p>\n<blockquote>\n<p>有些时候，typeof 操作符会返回一些令人疑惑但技术上却正确的值。比如，调用 typeof null 会返回 “object”，因为特殊值 null 被认为是一个空的对象引用。<br>《JavaScript高级程序设计》</p>\n</blockquote>\n<h2 id=\"3-2-Undefined\"><a href=\"#3-2-Undefined\" class=\"headerlink\" title=\"3.2. Undefined\"></a>3.2. Undefined</h2><p><code>Undefined</code> 类型的变量只有 <code>undefined</code> 一个值，当一个变量仅声明未赋初值时，它的值就是 <code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> msg;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(msg);</span><br></pre></td></tr></table></figure>\n<p>如上代码输出 <code>undefined</code>。</p>\n<blockquote>\n<p>即便未初始化的变量会自动被赋予undefined值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当typeof操作符返回 “undefined” 值时，我们就知道被检测的变量还没有申明，而不是尚未初始化。<br>《JavaScript高级程序设计》</p>\n</blockquote>\n<h2 id=\"3-3-Null\"><a href=\"#3-3-Null\" class=\"headerlink\" title=\"3.3. Null\"></a>3.3. Null</h2><p><code>Null</code> 类型的变量和 <code>Undefined</code> 一样只有一个值那就是 <code>null</code> , <code>null</code> 变量存储的实际是一个空指针对象，也正是因为如此， <code>typeof null</code> 返回了 <code>&quot;objcet&quot;</code>。<br>当使用 <code>==</code> 运算符在判断 <code>null</code> 和 <code>undefined</code> 时会返回 <code>true</code>，因为该操作符会发生隐式转换。</p>\n<blockquote>\n<p>只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象的惯例，而且也有助于进一步区分null和undefined。<br>《JavaScript高级程序设计》</p>\n</blockquote>\n<h2 id=\"3-4-Boolean\"><a href=\"#3-4-Boolean\" class=\"headerlink\" title=\"3.4. Boolean\"></a>3.4. Boolean</h2><p><code>Boolean</code> 有两个值 <code>true</code> 和 <code>false</code> ，在 <code>JavaScript</code> 中，所有的类型都可以转化为 <code>Boolean</code> 值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">&#x27;hello, world!&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> messageBoolean = <span class=\"title class_\">Boolean</span>(message);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-Number\"><a href=\"#3-5-Number\" class=\"headerlink\" title=\"3.5. Number\"></a>3.5. Number</h2><p><code>JavaScript</code> 中的 <code>Number</code> 类型与其它语言并没有太大的差异。它的数字返回存储在 <code>Number.MAX_VALUE</code> 和 <code>Number.MIN_VALUE</code> 中，如果超出这个范围，则会被转化为 <code>Infinity/-Infinity</code>。有一点需要注意：<code>Infinity/-Infinity</code> 是无法参与计算的。另外，可以使用 <code>isFinite()</code> 来判断一个值是否为 <code>Infinity/-Infinity</code>。<br>另一个比较特殊的 <code>Number</code> 类型值是 <code>NaN</code>，即 <code>Not a Number</code>。任何涉及 <code>NaN</code> 的操作最后都会返回 <code>NaN</code>，其次 <code>NaN</code> 与任何值都不相等，包括他自身，因而当需要判断时，可以使用 <code>isNaN()</code> 函数。</p>\n<h2 id=\"3-6-String\"><a href=\"#3-6-String\" class=\"headerlink\" title=\"3.6. String\"></a>3.6. String</h2><h3 id=\"3-6-1-字符字面量\"><a href=\"#3-6-1-字符字面量\" class=\"headerlink\" title=\"3.6.1 字符字面量\"></a>3.6.1 字符字面量</h3><p>字符字面量又叫转义序列，如果你接触过 <code>C/Java</code> 系列的格式化输出，就很容易理解，我们可以使用 <code>\\n</code> 等字符来表示换行等特殊字符。但需要注意的一点是，一个字符字面量通常被解析为一个字符串，因此它的长度是1。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;\\n&#x27;</span>.<span class=\"property\">length</span>);</span><br></pre></td></tr></table></figure>\n<p>如上代码输出为1。</p>\n<h3 id=\"3-6-2-字符串的特性\"><a href=\"#3-6-2-字符串的特性\" class=\"headerlink\" title=\"3.6.2 字符串的特性\"></a>3.6.2 字符串的特性</h3><p><strong>字符串一旦被创建，将不可被更改</strong>，如果要修改某个字符串变量的值，实际在后台是先创建了一个新的字符串，然后销毁旧的字符串。</p>\n<h3 id=\"3-6-3-将任意类型转换至字符串\"><a href=\"#3-6-3-将任意类型转换至字符串\" class=\"headerlink\" title=\"3.6.3 将任意类型转换至字符串\"></a>3.6.3 将任意类型转换至字符串</h3><ul>\n<li>toString()方法</li>\n<li>String()构造方法</li>\n<li>在该值后面追加空字符</li>\n</ul>\n<h2 id=\"3-7-Object\"><a href=\"#3-7-Object\" class=\"headerlink\" title=\"3.7 Object\"></a>3.7 Object</h2><p>如下代码都是合法的变量定义，但后者并不是推荐的语法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj_1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj_2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-操作符\"><a href=\"#4-操作符\" class=\"headerlink\" title=\"4. 操作符\"></a>4. 操作符</h1><p>几乎所有语言中的操作符都遵循数学逻辑，因而此处重点描述 <code>JavaScript</code> 中那些较为特殊的特性。</p>\n<h2 id=\"4-1-自增-x2F-自减运算符\"><a href=\"#4-1-自增-x2F-自减运算符\" class=\"headerlink\" title=\"4.1 自增&#x2F;自减运算符\"></a>4.1 自增&#x2F;自减运算符</h2><p>自增&#x2F;自减运算符通常用于对 <code>Number</code> 类型的操作，然而 <code>JavaScript</code> 中你却可以对任何类型的数据使用该运算符。<br>背后实际先尝试对该变量进行转化，而后进行自增&#x2F;自减运算。</p>\n<h1 id=\"5-语句\"><a href=\"#5-语句\" class=\"headerlink\" title=\"5. 语句\"></a>5. 语句</h1><p><code>JavaScript</code> 中那些语句也基本与 <code>C/Java</code> 保持一致，此处略过。</p>\n<h1 id=\"6-函数\"><a href=\"#6-函数\" class=\"headerlink\" title=\"6. 函数\"></a>6. 函数</h1><h2 id=\"6-1-arguments\"><a href=\"#6-1-arguments\" class=\"headerlink\" title=\"6.1 arguments\"></a>6.1 arguments</h2><p>函数体内可以使用 <code>arguments</code> 来获取参数数组，不过需要注意的是，它虽然可以使用下标的方式获取到元素，但其实并不是数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">print_args</span> (a,b,c,e) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>], <span class=\"variable language_\">arguments</span>[<span class=\"number\">1</span>], <span class=\"variable language_\">arguments</span>[<span class=\"number\">2</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">print_args</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<p>以上代码输出结果为 <code>1 2 3</code>。<br>另外 <code>arguments</code> 中的值始终与入参保持一致，因而当函数内部修改了入参或修改了 <code>arguments</code> 元素的值，则对应的 <code>arguments</code> 元素值&#x2F;入参的值都会发生变化。当然，它们的内存空间依然是独立的，但值是同步的。<br>最后，在严格模式下是无法修改 <code>arguments</code> 对象的值的。</p>\n<h2 id=\"6-2-没有重载\"><a href=\"#6-2-没有重载\" class=\"headerlink\" title=\"6.2 没有重载\"></a>6.2 没有重载</h2><p>就像标题所说的，<code>JavaScript</code> 函数是没有重载的，任何同名函数的定义都会覆盖原有的函数定义。</p>\n"},{"title":"JavaScript(3)变量、作用域和内存问题","date":"2020-05-30T04:13:55.000Z","_content":"# 1. 基本类型和引用类型\n和其他语言不太相同，`JavaScript` 在定义变量时必须确定这个值是基本类型还是引用类型，其中 `Number`，`String`，`Boolean`，`Null`，`Undefined` 都是基本类型。而 `Object` 则是引用类型。它们之间最大的区别在于基本类型是存储在内存中的值，而引用类型是存储在内存中的对象。\n\n## 1.1 动态属性\n无论是引用类型还是基本类型，其定义方法都是相同的，先创建一个变量然后为其赋值。不同的是，我们可以为引用类型的变量添加属性和方法，也可以修改它的属性和方法，就像下面这样\n~~~ JavaScript\nvar person = new Object();\nperson.name = 'yuchi';\nconsole.log(person.name);\n~~~\n这段代码打印输出字符串 `yuchi` 。我们一样可以为基本类型添加/修改属性与方法，这样不会导致任何错误，但事实上也没有任何意义。\n~~~ JavaScript\nvar person = 'yuchi';\nperson.name = 'yuchi';\nconsole.log(person.name);\n~~~\n上面的代码在控制台输出了 `undefined` 。\n\n## 1.2 复制\n当将一个基本类型的变量赋值给另一个变量时，实际开辟了新的内存空间来存储被复制的值，因而两个变量是独立的。\n但当我们将一个引用类型的变量复制给另一个变量时，则两者指向了同一块内存空间，那么对应的，修改了其中一个的值，另一个也会发生变化。\n~~~ JavaScript\nvar a = 1;\nvar b = a;\n\na ++;\nconsole.log(a, b);\n\nvar obj_a = { name: 'xiaohong', age: 30 }\nvar obj_b = obj_a;\n\nobj_a.age = 24;\nconsole.log(obj_a, obj_b);\n~~~\n如上代码分别输出了 `2 1` 和 `{ name: 'xiaohong', age: 24 } { name: 'xiaohong', age: 24 }`\n\n## 1.3 传递参数\n当向函数传递参数的时候，不管是引用类型还是基本类型，都会使用按值传递的方式，所谓按值传递，即把变量的值复制到一块新的内存空间然后赋值给新的变量（基本类型的赋值正是这个流程）。\n当入参是基本类型时，则如同赋值一样，基本类型的变量被复制了一份传递给入参，两者相互独立，且入参被定义在了函数级作用域里，因而离开了函数作用域，入参将会被销毁。这些非常容易理解。\n但是当参数是引用类型时，这些就会变的略微有些难以理解了，由于引用类型变量存储的是对象在内存中的地址，因而即便按值传递，入参与被传递的参数对象也会指向同一块内存。\n~~~ JavaScript\nvar obj = { name: 'xiaoming', age: 18 };\n\nfunction setName (o) { o.name = 'yuchi' }\n\nsetName(obj);\n\nconsole.log(obj);\n~~~\n上述代码打印输出 `{ name: 'yuchi', age: 18 }` 。当我们把代码进行一些修改后，上述的过程会更清晰一些：\n~~~ JavaScript\nvar obj = { name: 'xiaoming', age: 18 };\n\nfunction setName (o) {\n  o = new Object();\n  o.name = 'yuchi';\n}\n\nconsole.log(obj.name);\n~~~\n我们假设函数传参时，引用类型变量按引用传递，则在函数内部变量 `o` 与外部的 `obj` 指向同一块内存，那么当 `o` 被赋值为 `new Object()` 时，`obj` 也应该被修改为 `new Objcet` 。然而我们发现输出的结果是 `xiaoming` ，这恰巧说明了传递参数时，`o` 接收到的是变量的引用而非指向对象的内存。\n\n# 2. 执行环境与作用域\n执行环境中定义了变量或函数有权访问的数据，决定了各自的行为。每个执行环境都有一个与之关联的变量对象。\n每个函数都有自己的执行环境，每当执行流进入一个函数，函数的执行环境会被推入环境栈中，而函数执行之后栈再将环境弹出。\n代码在一个执行环境里执行时，会创建变量对象的作用域链，作用域链保证了执行环境有权访问的所有变量与函数的**有序访问**。\n当代码开始解析标识符（即变量/函数等）时，会沿着作用域链一层一层的搜索直到找到该标识符（如果找不到，则会抛出异常）。\n其实说了这么多总结就一句话，使用一个变量时会沿着作用域一层一层的向外查找。\n\n# 3. 垃圾回收\n任何语言都需要合理的垃圾回收机制以维护程序的正常开销。下面介绍几种常用的垃圾回收机制。\n\n## 3.1 标记清除\n标记清除就像它的名字一样，当变量进入环境时，将其标记为进入环境，反之当变量离开环境时，将其标记为离开环境。垃圾收集器会为环境里所有的变量进行标记，然后它会去除掉当前环境中的变量以及它们所依赖的变量的标记，并将剩下的变量标记为准备删除的变量。最后完成内存清除的工作。\n\n## 3.2 引用计数\n引用计数会跟踪每个值被引用的次数，当声明了一个变量并将一个引用类型值赋给该变量时，这个值的引用次数增加1，反之如果包含这个值引用的变量又取得了另一个值，则这个值的引用次数减少1.当这个值减少至0时，则说明有办法再访问到这个值了，此时可以将它占用的空间回收。\n引用计数存在的问题是，如果有两个引用类型的变量互相引用，如下：\n~~~ JavaScript\nvar obj1 = new Object();\nvar obj2 = new Object();\n\nobj1.one = obj2;\nobj2.two = obj1;\n~~~\n则这两个变量的引用次数永远不会是0，这种现象叫做**循环引用**。\n\n## 3.3 内存管理\n为了更高效的管理应用的内存，我们应该手动释放不再使用的对象引用：\n~~~ JavaScript\nvar Person = new Object();\n...\nPerson = null;\n~~~","source":"_posts/JavaScript-3-变量、作用域和内存问题.md","raw":"---\ntitle: JavaScript(3)变量、作用域和内存问题\ndate: 2020-05-30 12:13:55\ntags:\n  - JavaScript\n  - 前端\ncategories:\n  - JavaScript高级程序设计\n---\n# 1. 基本类型和引用类型\n和其他语言不太相同，`JavaScript` 在定义变量时必须确定这个值是基本类型还是引用类型，其中 `Number`，`String`，`Boolean`，`Null`，`Undefined` 都是基本类型。而 `Object` 则是引用类型。它们之间最大的区别在于基本类型是存储在内存中的值，而引用类型是存储在内存中的对象。\n\n## 1.1 动态属性\n无论是引用类型还是基本类型，其定义方法都是相同的，先创建一个变量然后为其赋值。不同的是，我们可以为引用类型的变量添加属性和方法，也可以修改它的属性和方法，就像下面这样\n~~~ JavaScript\nvar person = new Object();\nperson.name = 'yuchi';\nconsole.log(person.name);\n~~~\n这段代码打印输出字符串 `yuchi` 。我们一样可以为基本类型添加/修改属性与方法，这样不会导致任何错误，但事实上也没有任何意义。\n~~~ JavaScript\nvar person = 'yuchi';\nperson.name = 'yuchi';\nconsole.log(person.name);\n~~~\n上面的代码在控制台输出了 `undefined` 。\n\n## 1.2 复制\n当将一个基本类型的变量赋值给另一个变量时，实际开辟了新的内存空间来存储被复制的值，因而两个变量是独立的。\n但当我们将一个引用类型的变量复制给另一个变量时，则两者指向了同一块内存空间，那么对应的，修改了其中一个的值，另一个也会发生变化。\n~~~ JavaScript\nvar a = 1;\nvar b = a;\n\na ++;\nconsole.log(a, b);\n\nvar obj_a = { name: 'xiaohong', age: 30 }\nvar obj_b = obj_a;\n\nobj_a.age = 24;\nconsole.log(obj_a, obj_b);\n~~~\n如上代码分别输出了 `2 1` 和 `{ name: 'xiaohong', age: 24 } { name: 'xiaohong', age: 24 }`\n\n## 1.3 传递参数\n当向函数传递参数的时候，不管是引用类型还是基本类型，都会使用按值传递的方式，所谓按值传递，即把变量的值复制到一块新的内存空间然后赋值给新的变量（基本类型的赋值正是这个流程）。\n当入参是基本类型时，则如同赋值一样，基本类型的变量被复制了一份传递给入参，两者相互独立，且入参被定义在了函数级作用域里，因而离开了函数作用域，入参将会被销毁。这些非常容易理解。\n但是当参数是引用类型时，这些就会变的略微有些难以理解了，由于引用类型变量存储的是对象在内存中的地址，因而即便按值传递，入参与被传递的参数对象也会指向同一块内存。\n~~~ JavaScript\nvar obj = { name: 'xiaoming', age: 18 };\n\nfunction setName (o) { o.name = 'yuchi' }\n\nsetName(obj);\n\nconsole.log(obj);\n~~~\n上述代码打印输出 `{ name: 'yuchi', age: 18 }` 。当我们把代码进行一些修改后，上述的过程会更清晰一些：\n~~~ JavaScript\nvar obj = { name: 'xiaoming', age: 18 };\n\nfunction setName (o) {\n  o = new Object();\n  o.name = 'yuchi';\n}\n\nconsole.log(obj.name);\n~~~\n我们假设函数传参时，引用类型变量按引用传递，则在函数内部变量 `o` 与外部的 `obj` 指向同一块内存，那么当 `o` 被赋值为 `new Object()` 时，`obj` 也应该被修改为 `new Objcet` 。然而我们发现输出的结果是 `xiaoming` ，这恰巧说明了传递参数时，`o` 接收到的是变量的引用而非指向对象的内存。\n\n# 2. 执行环境与作用域\n执行环境中定义了变量或函数有权访问的数据，决定了各自的行为。每个执行环境都有一个与之关联的变量对象。\n每个函数都有自己的执行环境，每当执行流进入一个函数，函数的执行环境会被推入环境栈中，而函数执行之后栈再将环境弹出。\n代码在一个执行环境里执行时，会创建变量对象的作用域链，作用域链保证了执行环境有权访问的所有变量与函数的**有序访问**。\n当代码开始解析标识符（即变量/函数等）时，会沿着作用域链一层一层的搜索直到找到该标识符（如果找不到，则会抛出异常）。\n其实说了这么多总结就一句话，使用一个变量时会沿着作用域一层一层的向外查找。\n\n# 3. 垃圾回收\n任何语言都需要合理的垃圾回收机制以维护程序的正常开销。下面介绍几种常用的垃圾回收机制。\n\n## 3.1 标记清除\n标记清除就像它的名字一样，当变量进入环境时，将其标记为进入环境，反之当变量离开环境时，将其标记为离开环境。垃圾收集器会为环境里所有的变量进行标记，然后它会去除掉当前环境中的变量以及它们所依赖的变量的标记，并将剩下的变量标记为准备删除的变量。最后完成内存清除的工作。\n\n## 3.2 引用计数\n引用计数会跟踪每个值被引用的次数，当声明了一个变量并将一个引用类型值赋给该变量时，这个值的引用次数增加1，反之如果包含这个值引用的变量又取得了另一个值，则这个值的引用次数减少1.当这个值减少至0时，则说明有办法再访问到这个值了，此时可以将它占用的空间回收。\n引用计数存在的问题是，如果有两个引用类型的变量互相引用，如下：\n~~~ JavaScript\nvar obj1 = new Object();\nvar obj2 = new Object();\n\nobj1.one = obj2;\nobj2.two = obj1;\n~~~\n则这两个变量的引用次数永远不会是0，这种现象叫做**循环引用**。\n\n## 3.3 内存管理\n为了更高效的管理应用的内存，我们应该手动释放不再使用的对象引用：\n~~~ JavaScript\nvar Person = new Object();\n...\nPerson = null;\n~~~","slug":"JavaScript-3-变量、作用域和内存问题","published":1,"updated":"2022-05-03T08:09:03.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdtr0007r2ve5vbhfun8","content":"<h1 id=\"1-基本类型和引用类型\"><a href=\"#1-基本类型和引用类型\" class=\"headerlink\" title=\"1. 基本类型和引用类型\"></a>1. 基本类型和引用类型</h1><p>和其他语言不太相同，<code>JavaScript</code> 在定义变量时必须确定这个值是基本类型还是引用类型，其中 <code>Number</code>，<code>String</code>，<code>Boolean</code>，<code>Null</code>，<code>Undefined</code> 都是基本类型。而 <code>Object</code> 则是引用类型。它们之间最大的区别在于基本类型是存储在内存中的值，而引用类型是存储在内存中的对象。</p>\n<h2 id=\"1-1-动态属性\"><a href=\"#1-1-动态属性\" class=\"headerlink\" title=\"1.1 动态属性\"></a>1.1 动态属性</h2><p>无论是引用类型还是基本类型，其定义方法都是相同的，先创建一个变量然后为其赋值。不同的是，我们可以为引用类型的变量添加属性和方法，也可以修改它的属性和方法，就像下面这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">&#x27;yuchi&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person.<span class=\"property\">name</span>);</span><br></pre></td></tr></table></figure>\n<p>这段代码打印输出字符串 <code>yuchi</code> 。我们一样可以为基本类型添加&#x2F;修改属性与方法，这样不会导致任何错误，但事实上也没有任何意义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"string\">&#x27;yuchi&#x27;</span>;</span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">&#x27;yuchi&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person.<span class=\"property\">name</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的代码在控制台输出了 <code>undefined</code> 。</p>\n<h2 id=\"1-2-复制\"><a href=\"#1-2-复制\" class=\"headerlink\" title=\"1.2 复制\"></a>1.2 复制</h2><p>当将一个基本类型的变量赋值给另一个变量时，实际开辟了新的内存空间来存储被复制的值，因而两个变量是独立的。<br>但当我们将一个引用类型的变量复制给另一个变量时，则两者指向了同一块内存空间，那么对应的，修改了其中一个的值，另一个也会发生变化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;</span><br><span class=\"line\"></span><br><span class=\"line\">a ++;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj_a = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaohong&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj_b = obj_a;</span><br><span class=\"line\"></span><br><span class=\"line\">obj_a.<span class=\"property\">age</span> = <span class=\"number\">24</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj_a, obj_b);</span><br></pre></td></tr></table></figure>\n<p>如上代码分别输出了 <code>2 1</code> 和 <code>&#123; name: &#39;xiaohong&#39;, age: 24 &#125; &#123; name: &#39;xiaohong&#39;, age: 24 &#125;</code></p>\n<h2 id=\"1-3-传递参数\"><a href=\"#1-3-传递参数\" class=\"headerlink\" title=\"1.3 传递参数\"></a>1.3 传递参数</h2><p>当向函数传递参数的时候，不管是引用类型还是基本类型，都会使用按值传递的方式，所谓按值传递，即把变量的值复制到一块新的内存空间然后赋值给新的变量（基本类型的赋值正是这个流程）。<br>当入参是基本类型时，则如同赋值一样，基本类型的变量被复制了一份传递给入参，两者相互独立，且入参被定义在了函数级作用域里，因而离开了函数作用域，入参将会被销毁。这些非常容易理解。<br>但是当参数是引用类型时，这些就会变的略微有些难以理解了，由于引用类型变量存储的是对象在内存中的地址，因而即便按值传递，入参与被传递的参数对象也会指向同一块内存。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoming&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setName</span> (o) &#123; o.<span class=\"property\">name</span> = <span class=\"string\">&#x27;yuchi&#x27;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">setName</span>(obj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj);</span><br></pre></td></tr></table></figure>\n<p>上述代码打印输出 <code>&#123; name: &#39;yuchi&#39;, age: 18 &#125;</code> 。当我们把代码进行一些修改后，上述的过程会更清晰一些：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoming&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setName</span> (o) &#123;</span><br><span class=\"line\">  o = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">  o.<span class=\"property\">name</span> = <span class=\"string\">&#x27;yuchi&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>);</span><br></pre></td></tr></table></figure>\n<p>我们假设函数传参时，引用类型变量按引用传递，则在函数内部变量 <code>o</code> 与外部的 <code>obj</code> 指向同一块内存，那么当 <code>o</code> 被赋值为 <code>new Object()</code> 时，<code>obj</code> 也应该被修改为 <code>new Objcet</code> 。然而我们发现输出的结果是 <code>xiaoming</code> ，这恰巧说明了传递参数时，<code>o</code> 接收到的是变量的引用而非指向对象的内存。</p>\n<h1 id=\"2-执行环境与作用域\"><a href=\"#2-执行环境与作用域\" class=\"headerlink\" title=\"2. 执行环境与作用域\"></a>2. 执行环境与作用域</h1><p>执行环境中定义了变量或函数有权访问的数据，决定了各自的行为。每个执行环境都有一个与之关联的变量对象。<br>每个函数都有自己的执行环境，每当执行流进入一个函数，函数的执行环境会被推入环境栈中，而函数执行之后栈再将环境弹出。<br>代码在一个执行环境里执行时，会创建变量对象的作用域链，作用域链保证了执行环境有权访问的所有变量与函数的<strong>有序访问</strong>。<br>当代码开始解析标识符（即变量&#x2F;函数等）时，会沿着作用域链一层一层的搜索直到找到该标识符（如果找不到，则会抛出异常）。<br>其实说了这么多总结就一句话，使用一个变量时会沿着作用域一层一层的向外查找。</p>\n<h1 id=\"3-垃圾回收\"><a href=\"#3-垃圾回收\" class=\"headerlink\" title=\"3. 垃圾回收\"></a>3. 垃圾回收</h1><p>任何语言都需要合理的垃圾回收机制以维护程序的正常开销。下面介绍几种常用的垃圾回收机制。</p>\n<h2 id=\"3-1-标记清除\"><a href=\"#3-1-标记清除\" class=\"headerlink\" title=\"3.1 标记清除\"></a>3.1 标记清除</h2><p>标记清除就像它的名字一样，当变量进入环境时，将其标记为进入环境，反之当变量离开环境时，将其标记为离开环境。垃圾收集器会为环境里所有的变量进行标记，然后它会去除掉当前环境中的变量以及它们所依赖的变量的标记，并将剩下的变量标记为准备删除的变量。最后完成内存清除的工作。</p>\n<h2 id=\"3-2-引用计数\"><a href=\"#3-2-引用计数\" class=\"headerlink\" title=\"3.2 引用计数\"></a>3.2 引用计数</h2><p>引用计数会跟踪每个值被引用的次数，当声明了一个变量并将一个引用类型值赋给该变量时，这个值的引用次数增加1，反之如果包含这个值引用的变量又取得了另一个值，则这个值的引用次数减少1.当这个值减少至0时，则说明有办法再访问到这个值了，此时可以将它占用的空间回收。<br>引用计数存在的问题是，如果有两个引用类型的变量互相引用，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">obj1.<span class=\"property\">one</span> = obj2;</span><br><span class=\"line\">obj2.<span class=\"property\">two</span> = obj1;</span><br></pre></td></tr></table></figure>\n<p>则这两个变量的引用次数永远不会是0，这种现象叫做<strong>循环引用</strong>。</p>\n<h2 id=\"3-3-内存管理\"><a href=\"#3-3-内存管理\" class=\"headerlink\" title=\"3.3 内存管理\"></a>3.3 内存管理</h2><p>为了更高效的管理应用的内存，我们应该手动释放不再使用的对象引用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Person</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"title class_\">Person</span> = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"1-基本类型和引用类型\"><a href=\"#1-基本类型和引用类型\" class=\"headerlink\" title=\"1. 基本类型和引用类型\"></a>1. 基本类型和引用类型</h1><p>和其他语言不太相同，<code>JavaScript</code> 在定义变量时必须确定这个值是基本类型还是引用类型，其中 <code>Number</code>，<code>String</code>，<code>Boolean</code>，<code>Null</code>，<code>Undefined</code> 都是基本类型。而 <code>Object</code> 则是引用类型。它们之间最大的区别在于基本类型是存储在内存中的值，而引用类型是存储在内存中的对象。</p>\n<h2 id=\"1-1-动态属性\"><a href=\"#1-1-动态属性\" class=\"headerlink\" title=\"1.1 动态属性\"></a>1.1 动态属性</h2><p>无论是引用类型还是基本类型，其定义方法都是相同的，先创建一个变量然后为其赋值。不同的是，我们可以为引用类型的变量添加属性和方法，也可以修改它的属性和方法，就像下面这样</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">&#x27;yuchi&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person.<span class=\"property\">name</span>);</span><br></pre></td></tr></table></figure>\n<p>这段代码打印输出字符串 <code>yuchi</code> 。我们一样可以为基本类型添加&#x2F;修改属性与方法，这样不会导致任何错误，但事实上也没有任何意义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"string\">&#x27;yuchi&#x27;</span>;</span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">&#x27;yuchi&#x27;</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person.<span class=\"property\">name</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的代码在控制台输出了 <code>undefined</code> 。</p>\n<h2 id=\"1-2-复制\"><a href=\"#1-2-复制\" class=\"headerlink\" title=\"1.2 复制\"></a>1.2 复制</h2><p>当将一个基本类型的变量赋值给另一个变量时，实际开辟了新的内存空间来存储被复制的值，因而两个变量是独立的。<br>但当我们将一个引用类型的变量复制给另一个变量时，则两者指向了同一块内存空间，那么对应的，修改了其中一个的值，另一个也会发生变化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;</span><br><span class=\"line\"></span><br><span class=\"line\">a ++;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a, b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj_a = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaohong&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj_b = obj_a;</span><br><span class=\"line\"></span><br><span class=\"line\">obj_a.<span class=\"property\">age</span> = <span class=\"number\">24</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj_a, obj_b);</span><br></pre></td></tr></table></figure>\n<p>如上代码分别输出了 <code>2 1</code> 和 <code>&#123; name: &#39;xiaohong&#39;, age: 24 &#125; &#123; name: &#39;xiaohong&#39;, age: 24 &#125;</code></p>\n<h2 id=\"1-3-传递参数\"><a href=\"#1-3-传递参数\" class=\"headerlink\" title=\"1.3 传递参数\"></a>1.3 传递参数</h2><p>当向函数传递参数的时候，不管是引用类型还是基本类型，都会使用按值传递的方式，所谓按值传递，即把变量的值复制到一块新的内存空间然后赋值给新的变量（基本类型的赋值正是这个流程）。<br>当入参是基本类型时，则如同赋值一样，基本类型的变量被复制了一份传递给入参，两者相互独立，且入参被定义在了函数级作用域里，因而离开了函数作用域，入参将会被销毁。这些非常容易理解。<br>但是当参数是引用类型时，这些就会变的略微有些难以理解了，由于引用类型变量存储的是对象在内存中的地址，因而即便按值传递，入参与被传递的参数对象也会指向同一块内存。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoming&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setName</span> (o) &#123; o.<span class=\"property\">name</span> = <span class=\"string\">&#x27;yuchi&#x27;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">setName</span>(obj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj);</span><br></pre></td></tr></table></figure>\n<p>上述代码打印输出 <code>&#123; name: &#39;yuchi&#39;, age: 18 &#125;</code> 。当我们把代码进行一些修改后，上述的过程会更清晰一些：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoming&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setName</span> (o) &#123;</span><br><span class=\"line\">  o = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">  o.<span class=\"property\">name</span> = <span class=\"string\">&#x27;yuchi&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>);</span><br></pre></td></tr></table></figure>\n<p>我们假设函数传参时，引用类型变量按引用传递，则在函数内部变量 <code>o</code> 与外部的 <code>obj</code> 指向同一块内存，那么当 <code>o</code> 被赋值为 <code>new Object()</code> 时，<code>obj</code> 也应该被修改为 <code>new Objcet</code> 。然而我们发现输出的结果是 <code>xiaoming</code> ，这恰巧说明了传递参数时，<code>o</code> 接收到的是变量的引用而非指向对象的内存。</p>\n<h1 id=\"2-执行环境与作用域\"><a href=\"#2-执行环境与作用域\" class=\"headerlink\" title=\"2. 执行环境与作用域\"></a>2. 执行环境与作用域</h1><p>执行环境中定义了变量或函数有权访问的数据，决定了各自的行为。每个执行环境都有一个与之关联的变量对象。<br>每个函数都有自己的执行环境，每当执行流进入一个函数，函数的执行环境会被推入环境栈中，而函数执行之后栈再将环境弹出。<br>代码在一个执行环境里执行时，会创建变量对象的作用域链，作用域链保证了执行环境有权访问的所有变量与函数的<strong>有序访问</strong>。<br>当代码开始解析标识符（即变量&#x2F;函数等）时，会沿着作用域链一层一层的搜索直到找到该标识符（如果找不到，则会抛出异常）。<br>其实说了这么多总结就一句话，使用一个变量时会沿着作用域一层一层的向外查找。</p>\n<h1 id=\"3-垃圾回收\"><a href=\"#3-垃圾回收\" class=\"headerlink\" title=\"3. 垃圾回收\"></a>3. 垃圾回收</h1><p>任何语言都需要合理的垃圾回收机制以维护程序的正常开销。下面介绍几种常用的垃圾回收机制。</p>\n<h2 id=\"3-1-标记清除\"><a href=\"#3-1-标记清除\" class=\"headerlink\" title=\"3.1 标记清除\"></a>3.1 标记清除</h2><p>标记清除就像它的名字一样，当变量进入环境时，将其标记为进入环境，反之当变量离开环境时，将其标记为离开环境。垃圾收集器会为环境里所有的变量进行标记，然后它会去除掉当前环境中的变量以及它们所依赖的变量的标记，并将剩下的变量标记为准备删除的变量。最后完成内存清除的工作。</p>\n<h2 id=\"3-2-引用计数\"><a href=\"#3-2-引用计数\" class=\"headerlink\" title=\"3.2 引用计数\"></a>3.2 引用计数</h2><p>引用计数会跟踪每个值被引用的次数，当声明了一个变量并将一个引用类型值赋给该变量时，这个值的引用次数增加1，反之如果包含这个值引用的变量又取得了另一个值，则这个值的引用次数减少1.当这个值减少至0时，则说明有办法再访问到这个值了，此时可以将它占用的空间回收。<br>引用计数存在的问题是，如果有两个引用类型的变量互相引用，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">obj1.<span class=\"property\">one</span> = obj2;</span><br><span class=\"line\">obj2.<span class=\"property\">two</span> = obj1;</span><br></pre></td></tr></table></figure>\n<p>则这两个变量的引用次数永远不会是0，这种现象叫做<strong>循环引用</strong>。</p>\n<h2 id=\"3-3-内存管理\"><a href=\"#3-3-内存管理\" class=\"headerlink\" title=\"3.3 内存管理\"></a>3.3 内存管理</h2><p>为了更高效的管理应用的内存，我们应该手动释放不再使用的对象引用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">Person</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"title class_\">Person</span> = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>"},{"title":"JavaScript(4)引用类型","date":"2020-06-04T11:15:26.000Z","_content":"# 1. Object类型\n创建一个对象有两种方式：\n~~~ JavaScript\n# 构造函数\nconst student1 = new Object();\n\n# 字面量\nconst student2 = {\n    name: 'yuchi',\n    age: 18\n};\n~~~\n这两种方式创建对象区别不大，后者更常被使用在参数中，它能够更清晰的表达函数接收了什么，如：\n~~~ JavaScript\nnew Vue({\n    el: \"#app\",\n    data: {\n        msg: 'hello, world'\n    },\n    methods: [\n        fun1 () {\n\n        },\n        fun2 () {\n\n        }\n    ]\n});\n~~~\n获取对象的属性有两种方式：\n~~~ JavaScript\nconst obj = {\n    'name': 'yuchi',\n    'age': 18,\n    'test attr': 'hello!'\n};\n\nconsole.log(obj['name']);\nconsole.log(obj.name);\n~~~\n两种方式都可以获取到 `name` 属性，但对于 `test attr` 属性而言，打点的方式将不可用，只能使用 `[]` 获取。\n值得一提的是，`[]` 方式可以使用变量来动态获取属性，但**除非必须使用变量来访问属性，否则我们建议使用点表示法**。\n\n# 2. Array类型\n`Array` 用很多种创建方式：\n~~~ JavaScript\nconst colors = new Array();\nconst friends = new Array(20);\nconst riders = new Array('kuuga', 'ruyki', 'agito');\nconst name = new Array('tokiwa sougo');\n\nconst froms = ['muteki gamer', 'oma zio'];\n......\n~~~\n上述写法都是合理的，但需要注意如下写法可能会带来问题，在部分浏览器中，会因为最后一个逗号解析为具有４个元素的数组。\n~~~ JavaScript\nconst colors = [ 'あか', 'あお', 'しろ', ]\n~~~\n同样的，如下代码也可能带来问题，**强烈建议不要使用这种语法**。\n~~~ JavaScript\nconst colors = [ , , , ,];\n~~~\n## 2.1 Array的长度\n使用 `length` 可以获取数组的长度：\n~~~ JavaScript\nconst colors = [ 1, 2, 3, 4];\n\nconsole.log(colors.length);\n~~~\n如上代码会输出4。\n有一点很有趣，修改一个 `Array` 的长度是允许的：\n~~~ JavaScript\nconst colors = [ 1, 2, 3, 4];\n\ncolors.length = 10;\nconsole.log(colors);\n\ncolors.length = 3;\nconsole.log(colors);\n~~~\n如上代码首先将 `colors` 数组的长度修改为10，`colors` 数组的后面被填充了6个 `undefined` ，而后我们又修改其长度为3，则 `colors` 数组从第3位（下标为2）开始都被截掉了。\n\n## 2.2 类型检测\n前面我提到过，使用 `typeof` 关键字测试数组类型会返回 `object`。\n~~~ JavaScript\nconsole.log(typeof []);\n~~~\n我们也提到，对于这种情况我们可以使用 `instanceof` 操作符：\n~~~ JavaScript\nconsole.log([] instanceof Array);\n~~~\n这将返回 `true`。但这并不代表着问题解决了，事实上 `instanceof` 操作符在执行时会假设只有一个全局执行环境，如果页面中有两个以上的执行环境（如使用了 `iframe` 等场景），则会存在两个不同的 `Array` 构造函数，因而 `instanceof` 可能会返回一个错误的结论。为了解决这一问题，ES5新增的 `isArray()` 方法彻底解决了这个问题。\n~~~ JavaScript\nconsole.log(Array.isArray([]));\n~~~\n## 2.3 类型转换\n所有对象都具有 `toLocaleString()`，`toString()`，`valueOf()` 方法，当数组调用 `toString()` 方法的时候，会将所有元素组合在一起，并使用逗号分隔行成字符串。\n~~~ JavaScript\nconsole.log([ 1, 2, 3].toString());\n~~~\n上述语句输出 `'1,2,3'`。\n`toLocaleString()` 与 `toString()` 方法相同，两者在调用时都会使用数组的每个元素来分别调用 `toString()` 与 `toLocaleString()` 方法。\n另外我们也可以使用 `join()` 方法使用指定的分隔符将数组转换为字符串，如下代码输出 `'1|2|3|4'`。\n~~~ JavaScript\n[ 1, 2, 3, 4 ].join('|');\n~~~\n值得说明的是，如果某个元素是 `null` ，`undefined` ，那么该值在调用 `toLocaleString()`，`toString()`, `join` 时都会以空字符串表示。\n\n## 2.4 使数组具备栈的特性\n栈是一种先进后出的数据结构，虽然数组并不是栈，但我们依然可以使用指定的方法使数组具备栈的特性。使用 `push()` 方法可以向数组中添加一个元素，**该方法的返回值是数组的长度**，对应的，我们可以使用 `pop()` 方法从数组中取出最后一个元素。\n~~~ JavaScript\nconst arr = [ 1, 2, 3 ];\n\nconsole.log(arr.push(5));\nconsole.log(arr);\narr.pop();\nconsole.log(arr);\n~~~\n如上代码分别打印 `4 [ 1, 2, 3, 5 ] [ 1, 2, 3 ]` 。\n\n## 2.5 时数组具备队列的特性\n既然提到了栈，难免要提到队列，和栈不同，队列是一种先进先出的数据结构。当我们使用 `shift()` 方法时，可以去掉数组第一项元素，也就是先进先出的实现了。\n~~~ JavaScript\nconst arr = [ 1, 2, 3 ];\n\nconsole.log(arr.push(4));\nconsole.log(arr);\narr.shift();\nconsole.log(arr);\n~~~\n如上代码分别打印 `4 [ 1, 2, 3, 4 ] [ 2, 3, 4 ]` 。\n\n## 2.6 数组重排\n能够实现数组重排的方法有两个：`reverse()` 和 `sort()` ，但需要说明的是，这两个方法在比较元素大小的时候均使用 `ASCII` 码值，也就是说，元素10会小于元素2。\n~~~ JavaScript\nconst arr = [1, 2, 10, 4, 6]；\narr.sort();\n~~~\n该代码进行排序后会返回序列 `1, 10, 2, 4, 6` ，同样的，当使用 `reverse()` 时，会返回序列 `6, 4, 2, 10, 1` 。\n这样的序列是不符合我们对数字排序的要求的，因此我们可以为 `sort()` 方法传递一个方法协助它完成排序：\n~~~ JavaScript\nconst arr = [1, 2, 10, 4, 6];\narr.sort( (val1, val2) => val1 - val2 );\n~~~\n使用如上代码将得到序列 `1, 2, 4, 6, 10` 。\n\n## 2.7 操作方法\n\n### 2.7.1 concat\n当需要将两个数组连接在一起的时候，我们可以使用 `concat()` 方法，这对增量更新非常有用。\n~~~ JavaScript\nconsole.log([1,2,3].concat([5,6,7]));\n~~~\n上述代码输出 `1, 2, 3, 5, 6, 7` 。\n\n### 2.7.2 slice\n`slice` 方法用于截取数组中的指定片段，它接收两个参数，第一个参数为起始位置，当不传递第二个参数时，返回参数1至结尾的数组片段：\n~~~ JavaScript\n[1, 2, 3, 4, 5, 6].slice(2);\n~~~\n上述代码返回下标2开始到结尾的所有元素组成的新数组。\n当传递第二个参数时，则返回第一个参数到第二个参数范围内的元素组成的新数组：\n~~~ JavaScript\n[1, 2, 3, 4, 5, 6].slice(2, 5);\n~~~\n另外该方法的参数允许为负数，当参数为负数时，实际使用该负数于数组长度相加得到的结果作为下标使用。\n\n### 2.7.3 splice\n`splice()` 方法用来向数组插入项目，但根据其参数的传递方式，我们可以使用这个方法实现删除，插入，替换等操作：\n~~~ JavaScript\nlet arr = [1, 2, 3, 4, 5, 6];\n\n// 删除数组前两项\narr.splice(0, 2);\nconsole.log(arr);\n\n// 在第二项后增加一项\narr = [1, 2, 3, 4, 5, 6];\narr.splice(2, 0, 8);\n\n// 替换下标为2的项目\narr = [1, 2, 3, 4, 5, 6];\narr.splice(2, 1, 8);\n~~~\n\n### 2.7.4 位置方法\n查找数组中元素的位置可以使用 `indexOf()` 和 `lastIndexOf()` 方法，这个两个方法都接收两个参数，参数1是要查找的元素，参数二为开始查找的起始位置，区别在于 `indexOf()` 从前往后查找，而 `lastIndexOf()` 从后往前查找。当两个方法找到指定的元素时，它们会返回元素的下标，反之返回-1.\n~~~ JavaScript\nconst arr = [ 1, 2, 3, 4, 5];\n\n// 从前往后查找元素 1 的位置，返回 0\nconsole.log(arr.indexOf(1));\n\n// 从第二项开始查找元素 1 的位置，返回 -1\nconsole.log(arr.indexOf(1, 2));\n\n// 从后往前查找元素 1 的位置，返回0\nconsole.log(arr.lastIndexOf(1));\n\n// 从倒是第一项开始查找元素 1 的位置，返回0\nconsole.log(arr.lastIndexOf(1, 1));\n~~~\n\n## 2.8 迭代方法\n迭代数组可以使用如下五种方式：\n- `every()`：该函数接受回调函数并使用每一个元素执行，当所有元素的执行结果都是 `true` 时，则该函数返回 `true` 。\n- `fileter()`：该函数接受回调函数并使用每一个元素执行，返回所有能够返回 `true` 的项目组成的数组。\n- `forEach()`：使每一个元素执行回调函数，无返回值。\n- `map()`：使每一个元素执行回调函数，返回执行回调函数后的元素组成的数组。\n- `some()`：该函数接受回调函数并使用每一个元素执行，其中有一个元素执行结果为 `true` 时则该函数返回 `true` 。\n\n## 2.9 归并方法\n归并方法主要是将上一次执行的结果做为下一次执行函数的参数，可以使用 `reduce()` 方法和 `reduceRight()` 方法。其中 `reduce()` 方法从项目的第一项开始而 `reduceRight()` 从项目的最后一项开始。\n\n# 3. Date类型\n就像它的名字一样，`Date` 类型用于创建日期数据，`Date` 类型的 `valueOf()` 方法会返回该时间对应的毫秒数。\n\n# 4. Function类型\n声明一个函数可以使用如下方式：\n~~~ JavaScript\nfunction fun1 () {\n    return 'hello';\n}\n\nconst fun2 = function () {\n    return 'hello';\n}\n\nconst fun3 = new Function(\"return 'hello'\");\n~~~\n三种方式都是合法的，但第三种语法会导致代码别解析两次，第一次解析赋值表达式，第二次解析构造函数，同时这种语法也不便于理解，因此不推荐使用。\n\n## 4.1 无重载\n`JavaScript` 函数没有重载的特性，当重复定义函数时，函数会被覆盖。\n\n## 4.2 函数申明与函数表达式\n上面提到这两种方法都是合法的，但解析器会先读取函数申明，也就是说声明式函数存在变量提升，而函数表达式不会，因而声明式的函数可以先使用后申明，而函数表达式不可以。\n\n## 4.3 函数内部属性\n函数内部有两个特殊的对象它们分别是 `arguments` 和 `this` 。\n`arguments` 是一个类数组对象，它有一个 `callee` 属性保存着拥有这个 `arguments` 对象的函数指针。\n~~~ JavaScript\nfunction fun1 () {\n    console.log(fun1 === arguments.callee);\n}\nfun1();\n~~~\n上述函数返回 `true` 。\n函数还有另外一个属性 `caller` ，该属性返回调用当前函数的函数应用，如果在全局环境调用，则返回 `null` 。\n\n## 4.4 函数属性与方法\n函数的 `length` 属性返回参数的个数：\n~~~ JavaScript\nfunction fun1 (num1, num2, num3) {\n    console.log(arguments);\n}\n\n// 输出结果为3\nconsole.log(fun1.length);\n~~~\n每个函数都有两个方法 `apply` 和 `call` ，它们都可以为函数绑定 `this`，不过 `call` 的参数需要一一列举，而 `apply` 可以直接传递参数表。\n至于 `bind` ，它会创建一个函数实例，同时将 `this` 绑定到函数内部。\n\n# 5. 基本包装类型\n关于本章节，没有太多可以讲的内容，一些常见的方法此处不再赘述。\n\n## 5.1 Boolean\n没卵用系列，看如下代码：\n~~~ JavaScript\nconst booleanObj = new Boolean(false);\nconsole.log(booleanObj && true);\n~~~\n如上代码返回 `true`，因为 `new Boolean(false)` 实际返回了一个对象而非 `Boolean` 值，这会给人带来误解。\n~~~ JavaScript\nconsole.log(typeof (new Boolean(true)));\n~~~\n就像上面说的，此处返回 `object` 。\n\n## 5.2 Number\n`Number.toFixed()` 方法具有四舍五入的功能。\n\n## 5.3 String\n`str.charAt(1)` 基本等同于 `str[1]`。\n除此之外还可以使用 `str.charCodeAt()` 来获取指定字符的字符编码。\n\n# 6. 单体内置对象\n\n## 6.1 Global\n`Global` 对象提供了两个 `URI` 编码方法：`encodeURI()` 和 `encodeURIComponent()` ，前者可以编码整个 `URI` 中的空格，而后者会编码所有非字母数字字符。因而我们通常用 `encodeURIComponent()` 来编码 `URI` 中的参数部分。\n对应的，我们也可以使用 `decodeURI()` 和 `decodeURIComponent()` 方法进行 `URI` 解码。\n\n`eval()` 运行执行 `JavaScript` 代码，但该方法也会带来注入风险，在不了解的情况下不应该轻易使用。\n\n最后，`Global` 对象是无法直接访问的，但浏览器中的 `window` 对象包含了 `Global` 的一部分作为实现，也正因为如此，全局变量和函数最终都成了 `window` 对象的变量或函数。","source":"_posts/JavaScript-4-引用类型.md","raw":"---\ntitle: JavaScript(4)引用类型\ndate: 2020-06-04 19:15:26\ntags:\n  - JavaScript\n  - 前端\ncategories:\n  - JavaScript高级程序设计\n---\n# 1. Object类型\n创建一个对象有两种方式：\n~~~ JavaScript\n# 构造函数\nconst student1 = new Object();\n\n# 字面量\nconst student2 = {\n    name: 'yuchi',\n    age: 18\n};\n~~~\n这两种方式创建对象区别不大，后者更常被使用在参数中，它能够更清晰的表达函数接收了什么，如：\n~~~ JavaScript\nnew Vue({\n    el: \"#app\",\n    data: {\n        msg: 'hello, world'\n    },\n    methods: [\n        fun1 () {\n\n        },\n        fun2 () {\n\n        }\n    ]\n});\n~~~\n获取对象的属性有两种方式：\n~~~ JavaScript\nconst obj = {\n    'name': 'yuchi',\n    'age': 18,\n    'test attr': 'hello!'\n};\n\nconsole.log(obj['name']);\nconsole.log(obj.name);\n~~~\n两种方式都可以获取到 `name` 属性，但对于 `test attr` 属性而言，打点的方式将不可用，只能使用 `[]` 获取。\n值得一提的是，`[]` 方式可以使用变量来动态获取属性，但**除非必须使用变量来访问属性，否则我们建议使用点表示法**。\n\n# 2. Array类型\n`Array` 用很多种创建方式：\n~~~ JavaScript\nconst colors = new Array();\nconst friends = new Array(20);\nconst riders = new Array('kuuga', 'ruyki', 'agito');\nconst name = new Array('tokiwa sougo');\n\nconst froms = ['muteki gamer', 'oma zio'];\n......\n~~~\n上述写法都是合理的，但需要注意如下写法可能会带来问题，在部分浏览器中，会因为最后一个逗号解析为具有４个元素的数组。\n~~~ JavaScript\nconst colors = [ 'あか', 'あお', 'しろ', ]\n~~~\n同样的，如下代码也可能带来问题，**强烈建议不要使用这种语法**。\n~~~ JavaScript\nconst colors = [ , , , ,];\n~~~\n## 2.1 Array的长度\n使用 `length` 可以获取数组的长度：\n~~~ JavaScript\nconst colors = [ 1, 2, 3, 4];\n\nconsole.log(colors.length);\n~~~\n如上代码会输出4。\n有一点很有趣，修改一个 `Array` 的长度是允许的：\n~~~ JavaScript\nconst colors = [ 1, 2, 3, 4];\n\ncolors.length = 10;\nconsole.log(colors);\n\ncolors.length = 3;\nconsole.log(colors);\n~~~\n如上代码首先将 `colors` 数组的长度修改为10，`colors` 数组的后面被填充了6个 `undefined` ，而后我们又修改其长度为3，则 `colors` 数组从第3位（下标为2）开始都被截掉了。\n\n## 2.2 类型检测\n前面我提到过，使用 `typeof` 关键字测试数组类型会返回 `object`。\n~~~ JavaScript\nconsole.log(typeof []);\n~~~\n我们也提到，对于这种情况我们可以使用 `instanceof` 操作符：\n~~~ JavaScript\nconsole.log([] instanceof Array);\n~~~\n这将返回 `true`。但这并不代表着问题解决了，事实上 `instanceof` 操作符在执行时会假设只有一个全局执行环境，如果页面中有两个以上的执行环境（如使用了 `iframe` 等场景），则会存在两个不同的 `Array` 构造函数，因而 `instanceof` 可能会返回一个错误的结论。为了解决这一问题，ES5新增的 `isArray()` 方法彻底解决了这个问题。\n~~~ JavaScript\nconsole.log(Array.isArray([]));\n~~~\n## 2.3 类型转换\n所有对象都具有 `toLocaleString()`，`toString()`，`valueOf()` 方法，当数组调用 `toString()` 方法的时候，会将所有元素组合在一起，并使用逗号分隔行成字符串。\n~~~ JavaScript\nconsole.log([ 1, 2, 3].toString());\n~~~\n上述语句输出 `'1,2,3'`。\n`toLocaleString()` 与 `toString()` 方法相同，两者在调用时都会使用数组的每个元素来分别调用 `toString()` 与 `toLocaleString()` 方法。\n另外我们也可以使用 `join()` 方法使用指定的分隔符将数组转换为字符串，如下代码输出 `'1|2|3|4'`。\n~~~ JavaScript\n[ 1, 2, 3, 4 ].join('|');\n~~~\n值得说明的是，如果某个元素是 `null` ，`undefined` ，那么该值在调用 `toLocaleString()`，`toString()`, `join` 时都会以空字符串表示。\n\n## 2.4 使数组具备栈的特性\n栈是一种先进后出的数据结构，虽然数组并不是栈，但我们依然可以使用指定的方法使数组具备栈的特性。使用 `push()` 方法可以向数组中添加一个元素，**该方法的返回值是数组的长度**，对应的，我们可以使用 `pop()` 方法从数组中取出最后一个元素。\n~~~ JavaScript\nconst arr = [ 1, 2, 3 ];\n\nconsole.log(arr.push(5));\nconsole.log(arr);\narr.pop();\nconsole.log(arr);\n~~~\n如上代码分别打印 `4 [ 1, 2, 3, 5 ] [ 1, 2, 3 ]` 。\n\n## 2.5 时数组具备队列的特性\n既然提到了栈，难免要提到队列，和栈不同，队列是一种先进先出的数据结构。当我们使用 `shift()` 方法时，可以去掉数组第一项元素，也就是先进先出的实现了。\n~~~ JavaScript\nconst arr = [ 1, 2, 3 ];\n\nconsole.log(arr.push(4));\nconsole.log(arr);\narr.shift();\nconsole.log(arr);\n~~~\n如上代码分别打印 `4 [ 1, 2, 3, 4 ] [ 2, 3, 4 ]` 。\n\n## 2.6 数组重排\n能够实现数组重排的方法有两个：`reverse()` 和 `sort()` ，但需要说明的是，这两个方法在比较元素大小的时候均使用 `ASCII` 码值，也就是说，元素10会小于元素2。\n~~~ JavaScript\nconst arr = [1, 2, 10, 4, 6]；\narr.sort();\n~~~\n该代码进行排序后会返回序列 `1, 10, 2, 4, 6` ，同样的，当使用 `reverse()` 时，会返回序列 `6, 4, 2, 10, 1` 。\n这样的序列是不符合我们对数字排序的要求的，因此我们可以为 `sort()` 方法传递一个方法协助它完成排序：\n~~~ JavaScript\nconst arr = [1, 2, 10, 4, 6];\narr.sort( (val1, val2) => val1 - val2 );\n~~~\n使用如上代码将得到序列 `1, 2, 4, 6, 10` 。\n\n## 2.7 操作方法\n\n### 2.7.1 concat\n当需要将两个数组连接在一起的时候，我们可以使用 `concat()` 方法，这对增量更新非常有用。\n~~~ JavaScript\nconsole.log([1,2,3].concat([5,6,7]));\n~~~\n上述代码输出 `1, 2, 3, 5, 6, 7` 。\n\n### 2.7.2 slice\n`slice` 方法用于截取数组中的指定片段，它接收两个参数，第一个参数为起始位置，当不传递第二个参数时，返回参数1至结尾的数组片段：\n~~~ JavaScript\n[1, 2, 3, 4, 5, 6].slice(2);\n~~~\n上述代码返回下标2开始到结尾的所有元素组成的新数组。\n当传递第二个参数时，则返回第一个参数到第二个参数范围内的元素组成的新数组：\n~~~ JavaScript\n[1, 2, 3, 4, 5, 6].slice(2, 5);\n~~~\n另外该方法的参数允许为负数，当参数为负数时，实际使用该负数于数组长度相加得到的结果作为下标使用。\n\n### 2.7.3 splice\n`splice()` 方法用来向数组插入项目，但根据其参数的传递方式，我们可以使用这个方法实现删除，插入，替换等操作：\n~~~ JavaScript\nlet arr = [1, 2, 3, 4, 5, 6];\n\n// 删除数组前两项\narr.splice(0, 2);\nconsole.log(arr);\n\n// 在第二项后增加一项\narr = [1, 2, 3, 4, 5, 6];\narr.splice(2, 0, 8);\n\n// 替换下标为2的项目\narr = [1, 2, 3, 4, 5, 6];\narr.splice(2, 1, 8);\n~~~\n\n### 2.7.4 位置方法\n查找数组中元素的位置可以使用 `indexOf()` 和 `lastIndexOf()` 方法，这个两个方法都接收两个参数，参数1是要查找的元素，参数二为开始查找的起始位置，区别在于 `indexOf()` 从前往后查找，而 `lastIndexOf()` 从后往前查找。当两个方法找到指定的元素时，它们会返回元素的下标，反之返回-1.\n~~~ JavaScript\nconst arr = [ 1, 2, 3, 4, 5];\n\n// 从前往后查找元素 1 的位置，返回 0\nconsole.log(arr.indexOf(1));\n\n// 从第二项开始查找元素 1 的位置，返回 -1\nconsole.log(arr.indexOf(1, 2));\n\n// 从后往前查找元素 1 的位置，返回0\nconsole.log(arr.lastIndexOf(1));\n\n// 从倒是第一项开始查找元素 1 的位置，返回0\nconsole.log(arr.lastIndexOf(1, 1));\n~~~\n\n## 2.8 迭代方法\n迭代数组可以使用如下五种方式：\n- `every()`：该函数接受回调函数并使用每一个元素执行，当所有元素的执行结果都是 `true` 时，则该函数返回 `true` 。\n- `fileter()`：该函数接受回调函数并使用每一个元素执行，返回所有能够返回 `true` 的项目组成的数组。\n- `forEach()`：使每一个元素执行回调函数，无返回值。\n- `map()`：使每一个元素执行回调函数，返回执行回调函数后的元素组成的数组。\n- `some()`：该函数接受回调函数并使用每一个元素执行，其中有一个元素执行结果为 `true` 时则该函数返回 `true` 。\n\n## 2.9 归并方法\n归并方法主要是将上一次执行的结果做为下一次执行函数的参数，可以使用 `reduce()` 方法和 `reduceRight()` 方法。其中 `reduce()` 方法从项目的第一项开始而 `reduceRight()` 从项目的最后一项开始。\n\n# 3. Date类型\n就像它的名字一样，`Date` 类型用于创建日期数据，`Date` 类型的 `valueOf()` 方法会返回该时间对应的毫秒数。\n\n# 4. Function类型\n声明一个函数可以使用如下方式：\n~~~ JavaScript\nfunction fun1 () {\n    return 'hello';\n}\n\nconst fun2 = function () {\n    return 'hello';\n}\n\nconst fun3 = new Function(\"return 'hello'\");\n~~~\n三种方式都是合法的，但第三种语法会导致代码别解析两次，第一次解析赋值表达式，第二次解析构造函数，同时这种语法也不便于理解，因此不推荐使用。\n\n## 4.1 无重载\n`JavaScript` 函数没有重载的特性，当重复定义函数时，函数会被覆盖。\n\n## 4.2 函数申明与函数表达式\n上面提到这两种方法都是合法的，但解析器会先读取函数申明，也就是说声明式函数存在变量提升，而函数表达式不会，因而声明式的函数可以先使用后申明，而函数表达式不可以。\n\n## 4.3 函数内部属性\n函数内部有两个特殊的对象它们分别是 `arguments` 和 `this` 。\n`arguments` 是一个类数组对象，它有一个 `callee` 属性保存着拥有这个 `arguments` 对象的函数指针。\n~~~ JavaScript\nfunction fun1 () {\n    console.log(fun1 === arguments.callee);\n}\nfun1();\n~~~\n上述函数返回 `true` 。\n函数还有另外一个属性 `caller` ，该属性返回调用当前函数的函数应用，如果在全局环境调用，则返回 `null` 。\n\n## 4.4 函数属性与方法\n函数的 `length` 属性返回参数的个数：\n~~~ JavaScript\nfunction fun1 (num1, num2, num3) {\n    console.log(arguments);\n}\n\n// 输出结果为3\nconsole.log(fun1.length);\n~~~\n每个函数都有两个方法 `apply` 和 `call` ，它们都可以为函数绑定 `this`，不过 `call` 的参数需要一一列举，而 `apply` 可以直接传递参数表。\n至于 `bind` ，它会创建一个函数实例，同时将 `this` 绑定到函数内部。\n\n# 5. 基本包装类型\n关于本章节，没有太多可以讲的内容，一些常见的方法此处不再赘述。\n\n## 5.1 Boolean\n没卵用系列，看如下代码：\n~~~ JavaScript\nconst booleanObj = new Boolean(false);\nconsole.log(booleanObj && true);\n~~~\n如上代码返回 `true`，因为 `new Boolean(false)` 实际返回了一个对象而非 `Boolean` 值，这会给人带来误解。\n~~~ JavaScript\nconsole.log(typeof (new Boolean(true)));\n~~~\n就像上面说的，此处返回 `object` 。\n\n## 5.2 Number\n`Number.toFixed()` 方法具有四舍五入的功能。\n\n## 5.3 String\n`str.charAt(1)` 基本等同于 `str[1]`。\n除此之外还可以使用 `str.charCodeAt()` 来获取指定字符的字符编码。\n\n# 6. 单体内置对象\n\n## 6.1 Global\n`Global` 对象提供了两个 `URI` 编码方法：`encodeURI()` 和 `encodeURIComponent()` ，前者可以编码整个 `URI` 中的空格，而后者会编码所有非字母数字字符。因而我们通常用 `encodeURIComponent()` 来编码 `URI` 中的参数部分。\n对应的，我们也可以使用 `decodeURI()` 和 `decodeURIComponent()` 方法进行 `URI` 解码。\n\n`eval()` 运行执行 `JavaScript` 代码，但该方法也会带来注入风险，在不了解的情况下不应该轻易使用。\n\n最后，`Global` 对象是无法直接访问的，但浏览器中的 `window` 对象包含了 `Global` 的一部分作为实现，也正因为如此，全局变量和函数最终都成了 `window` 对象的变量或函数。","slug":"JavaScript-4-引用类型","published":1,"updated":"2022-05-03T08:09:03.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdtt0009r2vefdowg4fi","content":"<h1 id=\"1-Object类型\"><a href=\"#1-Object类型\" class=\"headerlink\" title=\"1. Object类型\"></a>1. Object类型</h1><p>创建一个对象有两种方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 构造函数</span><br><span class=\"line\"><span class=\"keyword\">const</span> student1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"># 字面量</span><br><span class=\"line\"><span class=\"keyword\">const</span> student2 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">18</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这两种方式创建对象区别不大，后者更常被使用在参数中，它能够更清晰的表达函数接收了什么，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&quot;#app&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;hello, world&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: [</span><br><span class=\"line\">        fun1 () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        fun2 () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>获取对象的属性有两种方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">18</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;test attr&#x27;</span>: <span class=\"string\">&#x27;hello!&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj[<span class=\"string\">&#x27;name&#x27;</span>]);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>);</span><br></pre></td></tr></table></figure>\n<p>两种方式都可以获取到 <code>name</code> 属性，但对于 <code>test attr</code> 属性而言，打点的方式将不可用，只能使用 <code>[]</code> 获取。<br>值得一提的是，<code>[]</code> 方式可以使用变量来动态获取属性，但<strong>除非必须使用变量来访问属性，否则我们建议使用点表示法</strong>。</p>\n<h1 id=\"2-Array类型\"><a href=\"#2-Array类型\" class=\"headerlink\" title=\"2. Array类型\"></a>2. Array类型</h1><p><code>Array</code> 用很多种创建方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> colors = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> friends = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> riders = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"string\">&#x27;kuuga&#x27;</span>, <span class=\"string\">&#x27;ruyki&#x27;</span>, <span class=\"string\">&#x27;agito&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"string\">&#x27;tokiwa sougo&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> froms = [<span class=\"string\">&#x27;muteki gamer&#x27;</span>, <span class=\"string\">&#x27;oma zio&#x27;</span>];</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>上述写法都是合理的，但需要注意如下写法可能会带来问题，在部分浏览器中，会因为最后一个逗号解析为具有４个元素的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> colors = [ <span class=\"string\">&#x27;あか&#x27;</span>, <span class=\"string\">&#x27;あお&#x27;</span>, <span class=\"string\">&#x27;しろ&#x27;</span>, ]</span><br></pre></td></tr></table></figure>\n<p>同样的，如下代码也可能带来问题，<strong>强烈建议不要使用这种语法</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> colors = [ , , , ,];</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1-Array的长度\"><a href=\"#2-1-Array的长度\" class=\"headerlink\" title=\"2.1 Array的长度\"></a>2.1 Array的长度</h2><p>使用 <code>length</code> 可以获取数组的长度：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> colors = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(colors.<span class=\"property\">length</span>);</span><br></pre></td></tr></table></figure>\n<p>如上代码会输出4。<br>有一点很有趣，修改一个 <code>Array</code> 的长度是允许的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> colors = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">colors.<span class=\"property\">length</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(colors);</span><br><span class=\"line\"></span><br><span class=\"line\">colors.<span class=\"property\">length</span> = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(colors);</span><br></pre></td></tr></table></figure>\n<p>如上代码首先将 <code>colors</code> 数组的长度修改为10，<code>colors</code> 数组的后面被填充了6个 <code>undefined</code> ，而后我们又修改其长度为3，则 <code>colors</code> 数组从第3位（下标为2）开始都被截掉了。</p>\n<h2 id=\"2-2-类型检测\"><a href=\"#2-2-类型检测\" class=\"headerlink\" title=\"2.2 类型检测\"></a>2.2 类型检测</h2><p>前面我提到过，使用 <code>typeof</code> 关键字测试数组类型会返回 <code>object</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> []);</span><br></pre></td></tr></table></figure>\n<p>我们也提到，对于这种情况我们可以使用 <code>instanceof</code> 操作符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>([] <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>);</span><br></pre></td></tr></table></figure>\n<p>这将返回 <code>true</code>。但这并不代表着问题解决了，事实上 <code>instanceof</code> 操作符在执行时会假设只有一个全局执行环境，如果页面中有两个以上的执行环境（如使用了 <code>iframe</code> 等场景），则会存在两个不同的 <code>Array</code> 构造函数，因而 <code>instanceof</code> 可能会返回一个错误的结论。为了解决这一问题，ES5新增的 <code>isArray()</code> 方法彻底解决了这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>([]));</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3-类型转换\"><a href=\"#2-3-类型转换\" class=\"headerlink\" title=\"2.3 类型转换\"></a>2.3 类型转换</h2><p>所有对象都具有 <code>toLocaleString()</code>，<code>toString()</code>，<code>valueOf()</code> 方法，当数组调用 <code>toString()</code> 方法的时候，会将所有元素组合在一起，并使用逗号分隔行成字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>([ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].<span class=\"title function_\">toString</span>());</span><br></pre></td></tr></table></figure>\n<p>上述语句输出 <code>&#39;1,2,3&#39;</code>。<br><code>toLocaleString()</code> 与 <code>toString()</code> 方法相同，两者在调用时都会使用数组的每个元素来分别调用 <code>toString()</code> 与 <code>toLocaleString()</code> 方法。<br>另外我们也可以使用 <code>join()</code> 方法使用指定的分隔符将数组转换为字符串，如下代码输出 <code>&#39;1|2|3|4&#39;</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span> ].<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;|&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>值得说明的是，如果某个元素是 <code>null</code> ，<code>undefined</code> ，那么该值在调用 <code>toLocaleString()</code>，<code>toString()</code>, <code>join</code> 时都会以空字符串表示。</p>\n<h2 id=\"2-4-使数组具备栈的特性\"><a href=\"#2-4-使数组具备栈的特性\" class=\"headerlink\" title=\"2.4 使数组具备栈的特性\"></a>2.4 使数组具备栈的特性</h2><p>栈是一种先进后出的数据结构，虽然数组并不是栈，但我们依然可以使用指定的方法使数组具备栈的特性。使用 <code>push()</code> 方法可以向数组中添加一个元素，<strong>该方法的返回值是数组的长度</strong>，对应的，我们可以使用 <code>pop()</code> 方法从数组中取出最后一个元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> ];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">push</span>(<span class=\"number\">5</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br><span class=\"line\">arr.<span class=\"title function_\">pop</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br></pre></td></tr></table></figure>\n<p>如上代码分别打印 <code>4 [ 1, 2, 3, 5 ] [ 1, 2, 3 ]</code> 。</p>\n<h2 id=\"2-5-时数组具备队列的特性\"><a href=\"#2-5-时数组具备队列的特性\" class=\"headerlink\" title=\"2.5 时数组具备队列的特性\"></a>2.5 时数组具备队列的特性</h2><p>既然提到了栈，难免要提到队列，和栈不同，队列是一种先进先出的数据结构。当我们使用 <code>shift()</code> 方法时，可以去掉数组第一项元素，也就是先进先出的实现了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> ];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">push</span>(<span class=\"number\">4</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br><span class=\"line\">arr.<span class=\"title function_\">shift</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br></pre></td></tr></table></figure>\n<p>如上代码分别打印 <code>4 [ 1, 2, 3, 4 ] [ 2, 3, 4 ]</code> 。</p>\n<h2 id=\"2-6-数组重排\"><a href=\"#2-6-数组重排\" class=\"headerlink\" title=\"2.6 数组重排\"></a>2.6 数组重排</h2><p>能够实现数组重排的方法有两个：<code>reverse()</code> 和 <code>sort()</code> ，但需要说明的是，这两个方法在比较元素大小的时候均使用 <code>ASCII</code> 码值，也就是说，元素10会小于元素2。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">10</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>]；</span><br><span class=\"line\">arr.<span class=\"title function_\">sort</span>();</span><br></pre></td></tr></table></figure>\n<p>该代码进行排序后会返回序列 <code>1, 10, 2, 4, 6</code> ，同样的，当使用 <code>reverse()</code> 时，会返回序列 <code>6, 4, 2, 10, 1</code> 。<br>这样的序列是不符合我们对数字排序的要求的，因此我们可以为 <code>sort()</code> 方法传递一个方法协助它完成排序：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">10</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\">arr.<span class=\"title function_\">sort</span>( <span class=\"function\">(<span class=\"params\">val1, val2</span>) =&gt;</span> val1 - val2 );</span><br></pre></td></tr></table></figure>\n<p>使用如上代码将得到序列 <code>1, 2, 4, 6, 10</code> 。</p>\n<h2 id=\"2-7-操作方法\"><a href=\"#2-7-操作方法\" class=\"headerlink\" title=\"2.7 操作方法\"></a>2.7 操作方法</h2><h3 id=\"2-7-1-concat\"><a href=\"#2-7-1-concat\" class=\"headerlink\" title=\"2.7.1 concat\"></a>2.7.1 concat</h3><p>当需要将两个数组连接在一起的时候，我们可以使用 <code>concat()</code> 方法，这对增量更新非常有用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].<span class=\"title function_\">concat</span>([<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]));</span><br></pre></td></tr></table></figure>\n<p>上述代码输出 <code>1, 2, 3, 5, 6, 7</code> 。</p>\n<h3 id=\"2-7-2-slice\"><a href=\"#2-7-2-slice\" class=\"headerlink\" title=\"2.7.2 slice\"></a>2.7.2 slice</h3><p><code>slice</code> 方法用于截取数组中的指定片段，它接收两个参数，第一个参数为起始位置，当不传递第二个参数时，返回参数1至结尾的数组片段：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>].<span class=\"title function_\">slice</span>(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码返回下标2开始到结尾的所有元素组成的新数组。<br>当传递第二个参数时，则返回第一个参数到第二个参数范围内的元素组成的新数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>].<span class=\"title function_\">slice</span>(<span class=\"number\">2</span>, <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n<p>另外该方法的参数允许为负数，当参数为负数时，实际使用该负数于数组长度相加得到的结果作为下标使用。</p>\n<h3 id=\"2-7-3-splice\"><a href=\"#2-7-3-splice\" class=\"headerlink\" title=\"2.7.3 splice\"></a>2.7.3 splice</h3><p><code>splice()</code> 方法用来向数组插入项目，但根据其参数的传递方式，我们可以使用这个方法实现删除，插入，替换等操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除数组前两项</span></span><br><span class=\"line\">arr.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在第二项后增加一项</span></span><br><span class=\"line\">arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\">arr.<span class=\"title function_\">splice</span>(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 替换下标为2的项目</span></span><br><span class=\"line\">arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\">arr.<span class=\"title function_\">splice</span>(<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-7-4-位置方法\"><a href=\"#2-7-4-位置方法\" class=\"headerlink\" title=\"2.7.4 位置方法\"></a>2.7.4 位置方法</h3><p>查找数组中元素的位置可以使用 <code>indexOf()</code> 和 <code>lastIndexOf()</code> 方法，这个两个方法都接收两个参数，参数1是要查找的元素，参数二为开始查找的起始位置，区别在于 <code>indexOf()</code> 从前往后查找，而 <code>lastIndexOf()</code> 从后往前查找。当两个方法找到指定的元素时，它们会返回元素的下标，反之返回-1.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从前往后查找元素 1 的位置，返回 0</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">indexOf</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第二项开始查找元素 1 的位置，返回 -1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">indexOf</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从后往前查找元素 1 的位置，返回0</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">lastIndexOf</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从倒是第一项开始查找元素 1 的位置，返回0</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">lastIndexOf</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-8-迭代方法\"><a href=\"#2-8-迭代方法\" class=\"headerlink\" title=\"2.8 迭代方法\"></a>2.8 迭代方法</h2><p>迭代数组可以使用如下五种方式：</p>\n<ul>\n<li><code>every()</code>：该函数接受回调函数并使用每一个元素执行，当所有元素的执行结果都是 <code>true</code> 时，则该函数返回 <code>true</code> 。</li>\n<li><code>fileter()</code>：该函数接受回调函数并使用每一个元素执行，返回所有能够返回 <code>true</code> 的项目组成的数组。</li>\n<li><code>forEach()</code>：使每一个元素执行回调函数，无返回值。</li>\n<li><code>map()</code>：使每一个元素执行回调函数，返回执行回调函数后的元素组成的数组。</li>\n<li><code>some()</code>：该函数接受回调函数并使用每一个元素执行，其中有一个元素执行结果为 <code>true</code> 时则该函数返回 <code>true</code> 。</li>\n</ul>\n<h2 id=\"2-9-归并方法\"><a href=\"#2-9-归并方法\" class=\"headerlink\" title=\"2.9 归并方法\"></a>2.9 归并方法</h2><p>归并方法主要是将上一次执行的结果做为下一次执行函数的参数，可以使用 <code>reduce()</code> 方法和 <code>reduceRight()</code> 方法。其中 <code>reduce()</code> 方法从项目的第一项开始而 <code>reduceRight()</code> 从项目的最后一项开始。</p>\n<h1 id=\"3-Date类型\"><a href=\"#3-Date类型\" class=\"headerlink\" title=\"3. Date类型\"></a>3. Date类型</h1><p>就像它的名字一样，<code>Date</code> 类型用于创建日期数据，<code>Date</code> 类型的 <code>valueOf()</code> 方法会返回该时间对应的毫秒数。</p>\n<h1 id=\"4-Function类型\"><a href=\"#4-Function类型\" class=\"headerlink\" title=\"4. Function类型\"></a>4. Function类型</h1><p>声明一个函数可以使用如下方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fun1</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fun2 = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fun3 = <span class=\"keyword\">new</span> <span class=\"title class_\">Function</span>(<span class=\"string\">&quot;return &#x27;hello&#x27;&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>三种方式都是合法的，但第三种语法会导致代码别解析两次，第一次解析赋值表达式，第二次解析构造函数，同时这种语法也不便于理解，因此不推荐使用。</p>\n<h2 id=\"4-1-无重载\"><a href=\"#4-1-无重载\" class=\"headerlink\" title=\"4.1 无重载\"></a>4.1 无重载</h2><p><code>JavaScript</code> 函数没有重载的特性，当重复定义函数时，函数会被覆盖。</p>\n<h2 id=\"4-2-函数申明与函数表达式\"><a href=\"#4-2-函数申明与函数表达式\" class=\"headerlink\" title=\"4.2 函数申明与函数表达式\"></a>4.2 函数申明与函数表达式</h2><p>上面提到这两种方法都是合法的，但解析器会先读取函数申明，也就是说声明式函数存在变量提升，而函数表达式不会，因而声明式的函数可以先使用后申明，而函数表达式不可以。</p>\n<h2 id=\"4-3-函数内部属性\"><a href=\"#4-3-函数内部属性\" class=\"headerlink\" title=\"4.3 函数内部属性\"></a>4.3 函数内部属性</h2><p>函数内部有两个特殊的对象它们分别是 <code>arguments</code> 和 <code>this</code> 。<br><code>arguments</code> 是一个类数组对象，它有一个 <code>callee</code> 属性保存着拥有这个 <code>arguments</code> 对象的函数指针。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fun1</span> () &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fun1 === <span class=\"variable language_\">arguments</span>.<span class=\"property\">callee</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fun1</span>();</span><br></pre></td></tr></table></figure>\n<p>上述函数返回 <code>true</code> 。<br>函数还有另外一个属性 <code>caller</code> ，该属性返回调用当前函数的函数应用，如果在全局环境调用，则返回 <code>null</code> 。</p>\n<h2 id=\"4-4-函数属性与方法\"><a href=\"#4-4-函数属性与方法\" class=\"headerlink\" title=\"4.4 函数属性与方法\"></a>4.4 函数属性与方法</h2><p>函数的 <code>length</code> 属性返回参数的个数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fun1</span> (num1, num2, num3) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果为3</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fun1.<span class=\"property\">length</span>);</span><br></pre></td></tr></table></figure>\n<p>每个函数都有两个方法 <code>apply</code> 和 <code>call</code> ，它们都可以为函数绑定 <code>this</code>，不过 <code>call</code> 的参数需要一一列举，而 <code>apply</code> 可以直接传递参数表。<br>至于 <code>bind</code> ，它会创建一个函数实例，同时将 <code>this</code> 绑定到函数内部。</p>\n<h1 id=\"5-基本包装类型\"><a href=\"#5-基本包装类型\" class=\"headerlink\" title=\"5. 基本包装类型\"></a>5. 基本包装类型</h1><p>关于本章节，没有太多可以讲的内容，一些常见的方法此处不再赘述。</p>\n<h2 id=\"5-1-Boolean\"><a href=\"#5-1-Boolean\" class=\"headerlink\" title=\"5.1 Boolean\"></a>5.1 Boolean</h2><p>没卵用系列，看如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> booleanObj = <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(booleanObj &amp;&amp; <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>如上代码返回 <code>true</code>，因为 <code>new Boolean(false)</code> 实际返回了一个对象而非 <code>Boolean</code> 值，这会给人带来误解。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> (<span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"literal\">true</span>)));</span><br></pre></td></tr></table></figure>\n<p>就像上面说的，此处返回 <code>object</code> 。</p>\n<h2 id=\"5-2-Number\"><a href=\"#5-2-Number\" class=\"headerlink\" title=\"5.2 Number\"></a>5.2 Number</h2><p><code>Number.toFixed()</code> 方法具有四舍五入的功能。</p>\n<h2 id=\"5-3-String\"><a href=\"#5-3-String\" class=\"headerlink\" title=\"5.3 String\"></a>5.3 String</h2><p><code>str.charAt(1)</code> 基本等同于 <code>str[1]</code>。<br>除此之外还可以使用 <code>str.charCodeAt()</code> 来获取指定字符的字符编码。</p>\n<h1 id=\"6-单体内置对象\"><a href=\"#6-单体内置对象\" class=\"headerlink\" title=\"6. 单体内置对象\"></a>6. 单体内置对象</h1><h2 id=\"6-1-Global\"><a href=\"#6-1-Global\" class=\"headerlink\" title=\"6.1 Global\"></a>6.1 Global</h2><p><code>Global</code> 对象提供了两个 <code>URI</code> 编码方法：<code>encodeURI()</code> 和 <code>encodeURIComponent()</code> ，前者可以编码整个 <code>URI</code> 中的空格，而后者会编码所有非字母数字字符。因而我们通常用 <code>encodeURIComponent()</code> 来编码 <code>URI</code> 中的参数部分。<br>对应的，我们也可以使用 <code>decodeURI()</code> 和 <code>decodeURIComponent()</code> 方法进行 <code>URI</code> 解码。</p>\n<p><code>eval()</code> 运行执行 <code>JavaScript</code> 代码，但该方法也会带来注入风险，在不了解的情况下不应该轻易使用。</p>\n<p>最后，<code>Global</code> 对象是无法直接访问的，但浏览器中的 <code>window</code> 对象包含了 <code>Global</code> 的一部分作为实现，也正因为如此，全局变量和函数最终都成了 <code>window</code> 对象的变量或函数。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"1-Object类型\"><a href=\"#1-Object类型\" class=\"headerlink\" title=\"1. Object类型\"></a>1. Object类型</h1><p>创建一个对象有两种方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 构造函数</span><br><span class=\"line\"><span class=\"keyword\">const</span> student1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"># 字面量</span><br><span class=\"line\"><span class=\"keyword\">const</span> student2 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">18</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这两种方式创建对象区别不大，后者更常被使用在参数中，它能够更清晰的表达函数接收了什么，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Vue</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">el</span>: <span class=\"string\">&quot;#app&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">msg</span>: <span class=\"string\">&#x27;hello, world&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">methods</span>: [</span><br><span class=\"line\">        fun1 () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        fun2 () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>获取对象的属性有两种方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">18</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;test attr&#x27;</span>: <span class=\"string\">&#x27;hello!&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj[<span class=\"string\">&#x27;name&#x27;</span>]);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>);</span><br></pre></td></tr></table></figure>\n<p>两种方式都可以获取到 <code>name</code> 属性，但对于 <code>test attr</code> 属性而言，打点的方式将不可用，只能使用 <code>[]</code> 获取。<br>值得一提的是，<code>[]</code> 方式可以使用变量来动态获取属性，但<strong>除非必须使用变量来访问属性，否则我们建议使用点表示法</strong>。</p>\n<h1 id=\"2-Array类型\"><a href=\"#2-Array类型\" class=\"headerlink\" title=\"2. Array类型\"></a>2. Array类型</h1><p><code>Array</code> 用很多种创建方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> colors = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> friends = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> riders = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"string\">&#x27;kuuga&#x27;</span>, <span class=\"string\">&#x27;ruyki&#x27;</span>, <span class=\"string\">&#x27;agito&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"string\">&#x27;tokiwa sougo&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> froms = [<span class=\"string\">&#x27;muteki gamer&#x27;</span>, <span class=\"string\">&#x27;oma zio&#x27;</span>];</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>上述写法都是合理的，但需要注意如下写法可能会带来问题，在部分浏览器中，会因为最后一个逗号解析为具有４个元素的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> colors = [ <span class=\"string\">&#x27;あか&#x27;</span>, <span class=\"string\">&#x27;あお&#x27;</span>, <span class=\"string\">&#x27;しろ&#x27;</span>, ]</span><br></pre></td></tr></table></figure>\n<p>同样的，如下代码也可能带来问题，<strong>强烈建议不要使用这种语法</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> colors = [ , , , ,];</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1-Array的长度\"><a href=\"#2-1-Array的长度\" class=\"headerlink\" title=\"2.1 Array的长度\"></a>2.1 Array的长度</h2><p>使用 <code>length</code> 可以获取数组的长度：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> colors = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(colors.<span class=\"property\">length</span>);</span><br></pre></td></tr></table></figure>\n<p>如上代码会输出4。<br>有一点很有趣，修改一个 <code>Array</code> 的长度是允许的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> colors = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">colors.<span class=\"property\">length</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(colors);</span><br><span class=\"line\"></span><br><span class=\"line\">colors.<span class=\"property\">length</span> = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(colors);</span><br></pre></td></tr></table></figure>\n<p>如上代码首先将 <code>colors</code> 数组的长度修改为10，<code>colors</code> 数组的后面被填充了6个 <code>undefined</code> ，而后我们又修改其长度为3，则 <code>colors</code> 数组从第3位（下标为2）开始都被截掉了。</p>\n<h2 id=\"2-2-类型检测\"><a href=\"#2-2-类型检测\" class=\"headerlink\" title=\"2.2 类型检测\"></a>2.2 类型检测</h2><p>前面我提到过，使用 <code>typeof</code> 关键字测试数组类型会返回 <code>object</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> []);</span><br></pre></td></tr></table></figure>\n<p>我们也提到，对于这种情况我们可以使用 <code>instanceof</code> 操作符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>([] <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Array</span>);</span><br></pre></td></tr></table></figure>\n<p>这将返回 <code>true</code>。但这并不代表着问题解决了，事实上 <code>instanceof</code> 操作符在执行时会假设只有一个全局执行环境，如果页面中有两个以上的执行环境（如使用了 <code>iframe</code> 等场景），则会存在两个不同的 <code>Array</code> 构造函数，因而 <code>instanceof</code> 可能会返回一个错误的结论。为了解决这一问题，ES5新增的 <code>isArray()</code> 方法彻底解决了这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>([]));</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3-类型转换\"><a href=\"#2-3-类型转换\" class=\"headerlink\" title=\"2.3 类型转换\"></a>2.3 类型转换</h2><p>所有对象都具有 <code>toLocaleString()</code>，<code>toString()</code>，<code>valueOf()</code> 方法，当数组调用 <code>toString()</code> 方法的时候，会将所有元素组合在一起，并使用逗号分隔行成字符串。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>([ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].<span class=\"title function_\">toString</span>());</span><br></pre></td></tr></table></figure>\n<p>上述语句输出 <code>&#39;1,2,3&#39;</code>。<br><code>toLocaleString()</code> 与 <code>toString()</code> 方法相同，两者在调用时都会使用数组的每个元素来分别调用 <code>toString()</code> 与 <code>toLocaleString()</code> 方法。<br>另外我们也可以使用 <code>join()</code> 方法使用指定的分隔符将数组转换为字符串，如下代码输出 <code>&#39;1|2|3|4&#39;</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span> ].<span class=\"title function_\">join</span>(<span class=\"string\">&#x27;|&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>值得说明的是，如果某个元素是 <code>null</code> ，<code>undefined</code> ，那么该值在调用 <code>toLocaleString()</code>，<code>toString()</code>, <code>join</code> 时都会以空字符串表示。</p>\n<h2 id=\"2-4-使数组具备栈的特性\"><a href=\"#2-4-使数组具备栈的特性\" class=\"headerlink\" title=\"2.4 使数组具备栈的特性\"></a>2.4 使数组具备栈的特性</h2><p>栈是一种先进后出的数据结构，虽然数组并不是栈，但我们依然可以使用指定的方法使数组具备栈的特性。使用 <code>push()</code> 方法可以向数组中添加一个元素，<strong>该方法的返回值是数组的长度</strong>，对应的，我们可以使用 <code>pop()</code> 方法从数组中取出最后一个元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> ];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">push</span>(<span class=\"number\">5</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br><span class=\"line\">arr.<span class=\"title function_\">pop</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br></pre></td></tr></table></figure>\n<p>如上代码分别打印 <code>4 [ 1, 2, 3, 5 ] [ 1, 2, 3 ]</code> 。</p>\n<h2 id=\"2-5-时数组具备队列的特性\"><a href=\"#2-5-时数组具备队列的特性\" class=\"headerlink\" title=\"2.5 时数组具备队列的特性\"></a>2.5 时数组具备队列的特性</h2><p>既然提到了栈，难免要提到队列，和栈不同，队列是一种先进先出的数据结构。当我们使用 <code>shift()</code> 方法时，可以去掉数组第一项元素，也就是先进先出的实现了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> ];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">push</span>(<span class=\"number\">4</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br><span class=\"line\">arr.<span class=\"title function_\">shift</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br></pre></td></tr></table></figure>\n<p>如上代码分别打印 <code>4 [ 1, 2, 3, 4 ] [ 2, 3, 4 ]</code> 。</p>\n<h2 id=\"2-6-数组重排\"><a href=\"#2-6-数组重排\" class=\"headerlink\" title=\"2.6 数组重排\"></a>2.6 数组重排</h2><p>能够实现数组重排的方法有两个：<code>reverse()</code> 和 <code>sort()</code> ，但需要说明的是，这两个方法在比较元素大小的时候均使用 <code>ASCII</code> 码值，也就是说，元素10会小于元素2。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">10</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>]；</span><br><span class=\"line\">arr.<span class=\"title function_\">sort</span>();</span><br></pre></td></tr></table></figure>\n<p>该代码进行排序后会返回序列 <code>1, 10, 2, 4, 6</code> ，同样的，当使用 <code>reverse()</code> 时，会返回序列 <code>6, 4, 2, 10, 1</code> 。<br>这样的序列是不符合我们对数字排序的要求的，因此我们可以为 <code>sort()</code> 方法传递一个方法协助它完成排序：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">10</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\">arr.<span class=\"title function_\">sort</span>( <span class=\"function\">(<span class=\"params\">val1, val2</span>) =&gt;</span> val1 - val2 );</span><br></pre></td></tr></table></figure>\n<p>使用如上代码将得到序列 <code>1, 2, 4, 6, 10</code> 。</p>\n<h2 id=\"2-7-操作方法\"><a href=\"#2-7-操作方法\" class=\"headerlink\" title=\"2.7 操作方法\"></a>2.7 操作方法</h2><h3 id=\"2-7-1-concat\"><a href=\"#2-7-1-concat\" class=\"headerlink\" title=\"2.7.1 concat\"></a>2.7.1 concat</h3><p>当需要将两个数组连接在一起的时候，我们可以使用 <code>concat()</code> 方法，这对增量更新非常有用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].<span class=\"title function_\">concat</span>([<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]));</span><br></pre></td></tr></table></figure>\n<p>上述代码输出 <code>1, 2, 3, 5, 6, 7</code> 。</p>\n<h3 id=\"2-7-2-slice\"><a href=\"#2-7-2-slice\" class=\"headerlink\" title=\"2.7.2 slice\"></a>2.7.2 slice</h3><p><code>slice</code> 方法用于截取数组中的指定片段，它接收两个参数，第一个参数为起始位置，当不传递第二个参数时，返回参数1至结尾的数组片段：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>].<span class=\"title function_\">slice</span>(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码返回下标2开始到结尾的所有元素组成的新数组。<br>当传递第二个参数时，则返回第一个参数到第二个参数范围内的元素组成的新数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>].<span class=\"title function_\">slice</span>(<span class=\"number\">2</span>, <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n<p>另外该方法的参数允许为负数，当参数为负数时，实际使用该负数于数组长度相加得到的结果作为下标使用。</p>\n<h3 id=\"2-7-3-splice\"><a href=\"#2-7-3-splice\" class=\"headerlink\" title=\"2.7.3 splice\"></a>2.7.3 splice</h3><p><code>splice()</code> 方法用来向数组插入项目，但根据其参数的传递方式，我们可以使用这个方法实现删除，插入，替换等操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除数组前两项</span></span><br><span class=\"line\">arr.<span class=\"title function_\">splice</span>(<span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在第二项后增加一项</span></span><br><span class=\"line\">arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\">arr.<span class=\"title function_\">splice</span>(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 替换下标为2的项目</span></span><br><span class=\"line\">arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\">arr.<span class=\"title function_\">splice</span>(<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-7-4-位置方法\"><a href=\"#2-7-4-位置方法\" class=\"headerlink\" title=\"2.7.4 位置方法\"></a>2.7.4 位置方法</h3><p>查找数组中元素的位置可以使用 <code>indexOf()</code> 和 <code>lastIndexOf()</code> 方法，这个两个方法都接收两个参数，参数1是要查找的元素，参数二为开始查找的起始位置，区别在于 <code>indexOf()</code> 从前往后查找，而 <code>lastIndexOf()</code> 从后往前查找。当两个方法找到指定的元素时，它们会返回元素的下标，反之返回-1.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [ <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从前往后查找元素 1 的位置，返回 0</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">indexOf</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从第二项开始查找元素 1 的位置，返回 -1</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">indexOf</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从后往前查找元素 1 的位置，返回0</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">lastIndexOf</span>(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从倒是第一项开始查找元素 1 的位置，返回0</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr.<span class=\"title function_\">lastIndexOf</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-8-迭代方法\"><a href=\"#2-8-迭代方法\" class=\"headerlink\" title=\"2.8 迭代方法\"></a>2.8 迭代方法</h2><p>迭代数组可以使用如下五种方式：</p>\n<ul>\n<li><code>every()</code>：该函数接受回调函数并使用每一个元素执行，当所有元素的执行结果都是 <code>true</code> 时，则该函数返回 <code>true</code> 。</li>\n<li><code>fileter()</code>：该函数接受回调函数并使用每一个元素执行，返回所有能够返回 <code>true</code> 的项目组成的数组。</li>\n<li><code>forEach()</code>：使每一个元素执行回调函数，无返回值。</li>\n<li><code>map()</code>：使每一个元素执行回调函数，返回执行回调函数后的元素组成的数组。</li>\n<li><code>some()</code>：该函数接受回调函数并使用每一个元素执行，其中有一个元素执行结果为 <code>true</code> 时则该函数返回 <code>true</code> 。</li>\n</ul>\n<h2 id=\"2-9-归并方法\"><a href=\"#2-9-归并方法\" class=\"headerlink\" title=\"2.9 归并方法\"></a>2.9 归并方法</h2><p>归并方法主要是将上一次执行的结果做为下一次执行函数的参数，可以使用 <code>reduce()</code> 方法和 <code>reduceRight()</code> 方法。其中 <code>reduce()</code> 方法从项目的第一项开始而 <code>reduceRight()</code> 从项目的最后一项开始。</p>\n<h1 id=\"3-Date类型\"><a href=\"#3-Date类型\" class=\"headerlink\" title=\"3. Date类型\"></a>3. Date类型</h1><p>就像它的名字一样，<code>Date</code> 类型用于创建日期数据，<code>Date</code> 类型的 <code>valueOf()</code> 方法会返回该时间对应的毫秒数。</p>\n<h1 id=\"4-Function类型\"><a href=\"#4-Function类型\" class=\"headerlink\" title=\"4. Function类型\"></a>4. Function类型</h1><p>声明一个函数可以使用如下方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fun1</span> () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fun2 = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> fun3 = <span class=\"keyword\">new</span> <span class=\"title class_\">Function</span>(<span class=\"string\">&quot;return &#x27;hello&#x27;&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>三种方式都是合法的，但第三种语法会导致代码别解析两次，第一次解析赋值表达式，第二次解析构造函数，同时这种语法也不便于理解，因此不推荐使用。</p>\n<h2 id=\"4-1-无重载\"><a href=\"#4-1-无重载\" class=\"headerlink\" title=\"4.1 无重载\"></a>4.1 无重载</h2><p><code>JavaScript</code> 函数没有重载的特性，当重复定义函数时，函数会被覆盖。</p>\n<h2 id=\"4-2-函数申明与函数表达式\"><a href=\"#4-2-函数申明与函数表达式\" class=\"headerlink\" title=\"4.2 函数申明与函数表达式\"></a>4.2 函数申明与函数表达式</h2><p>上面提到这两种方法都是合法的，但解析器会先读取函数申明，也就是说声明式函数存在变量提升，而函数表达式不会，因而声明式的函数可以先使用后申明，而函数表达式不可以。</p>\n<h2 id=\"4-3-函数内部属性\"><a href=\"#4-3-函数内部属性\" class=\"headerlink\" title=\"4.3 函数内部属性\"></a>4.3 函数内部属性</h2><p>函数内部有两个特殊的对象它们分别是 <code>arguments</code> 和 <code>this</code> 。<br><code>arguments</code> 是一个类数组对象，它有一个 <code>callee</code> 属性保存着拥有这个 <code>arguments</code> 对象的函数指针。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fun1</span> () &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fun1 === <span class=\"variable language_\">arguments</span>.<span class=\"property\">callee</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">fun1</span>();</span><br></pre></td></tr></table></figure>\n<p>上述函数返回 <code>true</code> 。<br>函数还有另外一个属性 <code>caller</code> ，该属性返回调用当前函数的函数应用，如果在全局环境调用，则返回 <code>null</code> 。</p>\n<h2 id=\"4-4-函数属性与方法\"><a href=\"#4-4-函数属性与方法\" class=\"headerlink\" title=\"4.4 函数属性与方法\"></a>4.4 函数属性与方法</h2><p>函数的 <code>length</code> 属性返回参数的个数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fun1</span> (num1, num2, num3) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出结果为3</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(fun1.<span class=\"property\">length</span>);</span><br></pre></td></tr></table></figure>\n<p>每个函数都有两个方法 <code>apply</code> 和 <code>call</code> ，它们都可以为函数绑定 <code>this</code>，不过 <code>call</code> 的参数需要一一列举，而 <code>apply</code> 可以直接传递参数表。<br>至于 <code>bind</code> ，它会创建一个函数实例，同时将 <code>this</code> 绑定到函数内部。</p>\n<h1 id=\"5-基本包装类型\"><a href=\"#5-基本包装类型\" class=\"headerlink\" title=\"5. 基本包装类型\"></a>5. 基本包装类型</h1><p>关于本章节，没有太多可以讲的内容，一些常见的方法此处不再赘述。</p>\n<h2 id=\"5-1-Boolean\"><a href=\"#5-1-Boolean\" class=\"headerlink\" title=\"5.1 Boolean\"></a>5.1 Boolean</h2><p>没卵用系列，看如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> booleanObj = <span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(booleanObj &amp;&amp; <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>如上代码返回 <code>true</code>，因为 <code>new Boolean(false)</code> 实际返回了一个对象而非 <code>Boolean</code> 值，这会给人带来误解。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> (<span class=\"keyword\">new</span> <span class=\"title class_\">Boolean</span>(<span class=\"literal\">true</span>)));</span><br></pre></td></tr></table></figure>\n<p>就像上面说的，此处返回 <code>object</code> 。</p>\n<h2 id=\"5-2-Number\"><a href=\"#5-2-Number\" class=\"headerlink\" title=\"5.2 Number\"></a>5.2 Number</h2><p><code>Number.toFixed()</code> 方法具有四舍五入的功能。</p>\n<h2 id=\"5-3-String\"><a href=\"#5-3-String\" class=\"headerlink\" title=\"5.3 String\"></a>5.3 String</h2><p><code>str.charAt(1)</code> 基本等同于 <code>str[1]</code>。<br>除此之外还可以使用 <code>str.charCodeAt()</code> 来获取指定字符的字符编码。</p>\n<h1 id=\"6-单体内置对象\"><a href=\"#6-单体内置对象\" class=\"headerlink\" title=\"6. 单体内置对象\"></a>6. 单体内置对象</h1><h2 id=\"6-1-Global\"><a href=\"#6-1-Global\" class=\"headerlink\" title=\"6.1 Global\"></a>6.1 Global</h2><p><code>Global</code> 对象提供了两个 <code>URI</code> 编码方法：<code>encodeURI()</code> 和 <code>encodeURIComponent()</code> ，前者可以编码整个 <code>URI</code> 中的空格，而后者会编码所有非字母数字字符。因而我们通常用 <code>encodeURIComponent()</code> 来编码 <code>URI</code> 中的参数部分。<br>对应的，我们也可以使用 <code>decodeURI()</code> 和 <code>decodeURIComponent()</code> 方法进行 <code>URI</code> 解码。</p>\n<p><code>eval()</code> 运行执行 <code>JavaScript</code> 代码，但该方法也会带来注入风险，在不了解的情况下不应该轻易使用。</p>\n<p>最后，<code>Global</code> 对象是无法直接访问的，但浏览器中的 <code>window</code> 对象包含了 <code>Global</code> 的一部分作为实现，也正因为如此，全局变量和函数最终都成了 <code>window</code> 对象的变量或函数。</p>\n"},{"title":"JavaScript(5)面向对象的程序设计","date":"2020-06-08T12:48:27.000Z","_content":"# 1. 对象\n创建一个对象很简单，我们可以很轻松的为其添加属性和方法。属性在创建时都会有一些特性值，它们定义了属性的行为。\n\n## 1.1 属性类型\n在 `JavaScript` 中属性被分为两种：数据属性和访问器属性。\n\n### 1.1.1 数据属性\n数据属性中包含了数据值的位置，这个位置可以写入和读取值，它有4个特性：\n- `[[Configurable]]`：是否可以被 `delete` 删除属性，是否可以修改属性，是否可以将属性修改为访问器属性等。它的默认值是 `true` 。\n- `[[Enumerable]]`：是否可以被 `for-in` 循环返回属性，它的默认值是 `true` 。\n- `[[Writeable]]`：是否可以修改该属性的值，默认值为 `true` 。\n- `[[Value]]`：该属性的数据，默认值是 `undefined` 。\n当需要修改一个数据属性的的特性时，必须使用 `Object.defineProperty()` 方法：\n~~~JavaScript\nlet obj = {}\nObject.defineProperty(obj, 'name', {\n    writable: false,\n    value: 'yuchi'\n});\n\nobj.name = 'bubu';\n\nconsole.log(obj.name);\n~~~\n上述代码打印 `yuchi` ，且由于该属性的 `writable` 被这设定为 `false` ，因而该值无法被修改，在非严格模式下，上述代码中的修改没有效果；在严格模式下，上述代码会抛出错误。\n上述规则同样适用于 'configurable` 特性，但需要注意一点，一旦将一个属性设置为 `configurable: false`， 就不可以再将其设置为 `configurable: true` 了，此时再使用 `Object.defineProperty()` 方法仅能修改 `writable` 属性。\n\n### 1.1.2 访问器属性\n访问器属性与数据属性的区别在于它不包含数据值，但它包含一对 `getter/setter` 函数。当访问一个属性的时候，会触发该属性的 `getter` 函数，当修改一个属性的时候，会触发该属性的 `setter` 函数。与数据属性相似，它也有4个属性：\n- `[[Configurable]]`：是否可以被 `delete` 删除属性，是否可以修改属性，是否可以将属性修改为访问器属性等。它的默认值是 `true` 。\n- `[[Enumerable]]`：是否可以被 `for-in` 循环返回属性，它的默认值是 `true` 。\n- `[[Get]]`：读取时调用的函数。\n- `[[Set]]`：修改时调用的函数。\n相同的，我们依然需要使用 `Object.defineProperty()` 方法来为对象定义访问器属性。\n~~~ JavaScript\nconst data = {\n    _name: ''\n};\n\nObject.defineProperty(data, 'name', {\n    get: function () {\n        return this._name\n    },\n    set: function (val) {\n        console.log(`${this._name} -> ${val}`);\n        this._name = val;\n    }\n});\n\ndata.name = 'xiaoming';\ndata.name = 'yuchi';\n~~~\n如上代码将 `data.name` 定义为访问器属性，并为其遍写了 `getter/setter` 函数，当我们修改其值时，就可以自动打印属性值的变化情况，需要注意，此处无论是 `getter()` 函数返回的 `name` ，还是 `setter()` 修改了 `name` ，都会再度触发 `getter/setter` 函数，因而我们使用下划线来表示只能通过对象方法访问的属性。\n\n## 1.2 定义多属性\n当我们需要定义多个属性，可以使用 `Object.defineProperties()` 方法，它的用法和上面类似，不过它的第二个参数是一个对象，通过 `key-value` 的结构描述了属性与特性的关系。\n~~~ JavaScript\nObject.defineProperties(data, {\n    name: {\n        get: function () {\n            return this._name\n        },\n        set: function (val) {\n            console.log(`${this._name} -> ${val}`);\n            this._name = val;\n        }\n    },\n    age: {\n        writable: false,\n        value: 18\n    }\n});\n~~~\n\n\n## 1.3 读取属性的特性\n当我们需要获取到某属性的特性时，可以使用 `Object.getOwnPropertyDescriptor()` 方法。直接看代码：\n~~~ JavaScript\nObject.defineProperties(data, {\n    name: {\n        get: function () {\n            return this._name\n        },\n        set: function (val) {\n            console.log(`${this._name} -> ${val}`);\n            this._name = val;\n        }\n    },\n    age: {\n        writable: false,\n        value: 18\n    }\n});\n\nvar descriptor = Object.getOwnPropertyDescriptor(data, 'age');\nconsole.log(descriptor.value);\nconsole.log(descriptor.writable);\n~~~\n\n# 2. 创建对象\n创建对象可以使用构造函数或者对象字面量两种方式。但这样的创建方式略微有些不优雅，因此就有了如下几种衍生的创建方式。\n\n## 2.1 工厂模式\n工厂模式是指使用一个特定的函数来封装对象创建的细节。\n~~~JavaScript\nfunction getConn(url, username, password){\n    var conn = new Object();\n    conn.url = url;\n    conn.username = username;\n    conn.password = password;\n    return conn;\n}\n~~~\n上述代码使用 `getConn` 方法来创建对象，这样做大大缩减了创建同一对象时的代码。\n单它也带来了一个新的问题，就是这样创建的对象是无法识别的，即没有办法知道这个对象的类型。\n\n## 2.2 构造函数模式\n构造函数模式有效的解决了工厂模式无法识别对象类型的问题。\n~~~ JavaScript\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayHello = function () {\n        console.log('heelo');\n    };\n}\nvar person1 = new Person('yuchi', 18, 'api caller');\n~~~\n上述代码我们定义了 `Person` 构造函数，要使用它来创建新实例，我们必须使用 `new` 操作符。创建一个对象会经历如下4个步骤：\n1. 创建一个对象。\n2. 将构造函数的作用域赋给新的对象。\n3. 执行构造函数里的代码。\n4. 返回新的对象。\n\n每一个 `Person` 构造函数实例化的对象都会保存一个单独的实例，它们都具备一个 `constructor` 属性，该属性指向了 `Person` 构造函数。\n这样我们就可以使用 `instanceof` 操作符来确定该实例的类型：\n~~~JavaScript\nconsole.log(person1.constructor === Person);\n~~~\n上面的代码返回 `true` 。\n\n另外，构造函数实际和其它函数并无区别，换言之你可以使用 `new` 来调用任何函数。不过需要注意一点，像如下代码一样不使用 `new` 操作符来实例化对象，最终会将属性绑定到 `window` 对象上。\n~~~JavaScript\nvar person2 = Person('yuchi', 18, 'coder');\nwindow.sayHello();\n~~~\n虽然使用构造函数的方式让我们解决了对象类型无法识别的问题，但仔细看我们会发现，不仅是属性，每一次实例化的时候，我们都会重新创建一个 `sayHello` 方法，即**不同实例上的同名方法是不相等的**。虽然有些场景下我们也许确实需要这样的处理机制，但似乎大多数情况下我们并不希望这样。如何解决这个问题，就要说到原型模式了。\n\n## 2.3 原型模式\n`JavaScript` 是基于原型编程的语言，因而原型是 `JavaScript` 中相当重要的概念。\n我们创建的每一个函数都有一个 `prototype` 属性，它是一个指向原型对象的指针。原型对象里包含了该特定类型所有实例可以共享的属性与方法。\n~~~JavaScript\nfunction Person() {\n\n}\n\nPerson.prototype.sayHello = function () {\n    console.log('hello');\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.sayHello();\nperson2.sayHello();\n~~~\n上述的代码中，我们为 `prototype` 属性添加了一个 `sayHello` 方法，而后所有的实例都可以使用该方法。\n我们之前提到过，使用构造函数创建的实例有各自不同的属性和方法，哪怕它们的创建机制是一样的，不用实例上的同名方法依然是不相等的。但是用原型来创建的方法很好的解决了这个问题，下面的代码将返回 `true` 。\n~~~JavaScript\nperson1.sayHello === person2.sayHello;\n~~~\n在原型模式的一些特性之前，我们首先要理解原型对象。\n本小节开始我们就提到了，每个函数都有一个 `prototype` 属性，它是一个指向原型对象的指针。当我们创建一个自定义的构造函数后，`prototype` 原型对象里默认只保存了一个属性—— `constructor` 属性，它是一个指向 `prototype` 属性所在的函数的指针。这样说也许非常晦涩难懂，我们简单的理解为我们调用的那个构造函数，即：\n~~~JavaScript\nPerson.prototype.constructor === Person;\n~~~\n上述语句返回 `true` 。\n当我们使用构造函数来实例化一个对象后，该对象同样保存了一个指向原型对象的指针，我们通常称之为 `[[Prototype]]` ，在 `chrome` 等浏览器里，可以使用 `__proto__` 来访问到它。我们既然提到了 `__proto__` 与构造函数的 `prototype` 都是指向原型对象，就很容易得到如下代码会返回 `true` ：\n~~~JavaScript\nPerson.prototype === person1.__proto__;\n~~~\n我们必须要提到一点：构造函数与实例间的关联正是通过原型对象来建立**而非直接由构造函数与实例间建立**。实例的 `__proto__` 是否指向构造函数的原型对象，我们可以使用 `isPrototypeOf` 方法来进行判断。如下代码返回 `true` 。\n~~~JavaScript\nPerson.prototype.isPrototypeOf(person1);\n~~~\n\n当代码开始读取实例的某个属性或方法时，会进行一次搜索：当实例具备属性或方法时，返回该属性或方法；当实例不具备属性或方法时，查询它的原型对象是否具备该属性或方法。\n虽然我们可以获取到原型对象中的属性值，却不能修改它，当试图修改原型对象中的属性或方法时，实际只是为实例定义了一个同名属性或方法。根据刚才我们讲到的搜索方法，实例的属性将会屏蔽掉原型对象里的属性，即使将该值设置为 `null` ，我们也无法再次使它获取到原型对象里的属性。不过我们可以使用 `delete` 操作符将实例上的属性或方法完全删除掉，这样再次访问时就会继续访问原型对象上的属性和方法了。\n~~~JavaScript\nfunction Person() {\n}\nPerson.prototype.name = 'yuchi';\n\nvar person1 = new Person();\n\n// 输出yuchi\nconsole.log(person1.name);\n\nperson1.name = 'lala';\n// 输出 lala\nconsole.log(person1.name);\n\nperson1.name = null\n// 输出null\nconsole.log(person1.name);\n\ndelete person1.name;\n// 输出yuchi\nconsole.log(person1.name);\n~~~\n我们可以使用 `hasOwnProperty` 方法来判断一个属性究竟在实例上还是原型对象上。\n~~~ JavaScript\n// 结果为false\nperson1.hasOwnProperty('name');\n~~~\n由于 `hasOwnProperty` 只能判断属性是否在实例上，当我们需要判断一个属性是否存在与原型上时，可以将它与 `in` 操作符配合起来使用。`in` 操作符仅在属性可以访问时返回 `true` 而不会关心属性在实例上还是原型上。因此，当使用 `in` 操作符时返回 `true` 而 `hasOwnProperty` 返回 `false` 时，就可以认为该属性位于原型对象。\n~~~JavaScript\n!person1.hasOwnProperty('name') && ('name' in person1);\n~~~\n当我们有大量的属性与方法需要添加到原型对象上时，可以使用字面量的语法来减少 `Person.prototype` 的键入：\n~~~JavaScript\nPerson.prototype = {\n    name: 'yuchi',\n    age: 23,\n    sayHello: function() {\n        console.log('hello');\n    }\n};\n~~~\n不过你可能需要注意了，这样的写法本质上覆盖了 `Person.prototype` 的所有属性和方法，所以此时的 `constructor` 已经无法确定对象的类型了。\n~~~JavaScript\nfunction Person(){}\n\nPerson.prototype = {\n    name: 'yuchi',\n    age: 23,\n    sayHello: function() {\n        console.log('hello');\n    }\n};\n\nPerson.prototype.constructor === Person;\n~~~\n上述的代码将会返回 `false` 。解决这个问题也很简单，我们只需要显式的指定 `constructor` 即可。\n~~~JavaScript\nfunction Person(){}\n\nPerson.prototype = {\n    constructor: Person,\n    name: 'yuchi',\n    age: 23,\n    sayHello: function() {\n        console.log('hello');\n    }\n};\n\nPerson.prototype.constructor === Person;\n~~~\n这样做之后，代码又可以正常的返回 `true` 了。不过这样的作法并非没有代价，对原型对象的修改可以立即作用在所有已创建的实例上，让我们看看下面的代码：\n~~~JavaScript\nfunction Person(){}\n\nvar person1 = new Person();\nPerson.prototype = {\n    constructor: Person,\n    name: 'yuchi',\n    age: 23,\n    sayHello: function() {\n        console.log('hello');\n    }\n};\n\nperson1.sayHello();\n~~~\n该段代码会抛出异常：`Uncaught TypeError: person1.sayHello is not a function` 。\n这是因为我们在创建了实例后又重写了整个原型对象，事实上，调用构造函数时会为实例添加一个指向最初原型的 `[[Prototype]]` 指针。修改改对象的内容等同于切断了它与最初的原型之间的联系。\n最后，我们虽然使用原型来解决了很多问题，但这并不代表原型对象是完美的。\n~~~JavaScript\nfunction Person(){}\n\nPerson.prototype.obj = {name: 'yuchi', age: 18};\nPerson.prototype.friends = ['xiaohong', 'xiaoming', 'xiaogang'];\n\nvar person1 = new Person()\nvar person2 = new Person()\n\nperson1.obj.name = 'bubu'\nperson2.obj.name\n\nperson1.friends.push('xiaowang')\nperson1.friends\n~~~\n上述代码中对于引用类型的修改最终都直接作用到了原型对象的属性上了，当我们需要使属性共享时，这样是没有问题的。但实例通常要求拥有自己的独立的属性，因而在实际的场景里我们很少单独使用原型模式。\n\n\n## 2.4 组合使用构造函数模式和原型模式\n创建一个自定义的类型最常见的方式就是组合使用构造函数和原型模式。使用构造函数来定义实例属性，使用原型模式来定义共享的属性。\n~~~JavaScript\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n}\n\nPerson.prototype = {\n    constructor: Person,\n    sayHello: function(){console.log('hello')}\n}\n~~~\n\n## 2.5 动态原型模式\n动态原型模式是使用构造函数的模式来定义示例属性，根据需要动态的添加共享属性的模式。\n~~~JavaScript\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n\n    if (type this.sayHello != 'function') {\n        Person.prototype.sayHello = function () { console.log('hello'); };\n    }\n}\n~~~\n上述代码会在初次调用构造函数时检测是否具有 `sayHello` 方法，仅在其不存在时动态的对原型添加 `sayHello` 方法。同样要注意此处不应该使用字面量的方法来修改原型，因为它会切断已有实例与原型方法之间的联系。\n\n## 2.6 寄生构造函数模式\n寄生构造函数通常用来对不方便修改的构造函数追加方法（这和 `Ruby` 使用 `Open Class` 来遍写 `Monkey Patch` 有一点相似）。\n~~~ JavaScript\nfunction NumberArray() {\n    var arr = Array();\n    arr.push.apply(arr, arguments);\n    arr.numberSort = function () {\n        return arr.sort(function(val1, val2){return val1 - val2});\n    };\n    return arr;\n}\n~~~\n上述代码我们封装了一个 `NumberArray` 构造函数，并借用  `Array` 构造函数扩展了一个用来给数字进行排序的方法。\n\n## 2.7 稳妥构造函数模式\n稳妥构造函数要求不使用 `new` 操作符初始化示例，且在构造函数内部使用局部变量。\n~~~JavaScript\nfunction Person(name) {\n    var o = new Object();\n    var name = name;\n\n    o.sayName = function () {\n        console.log(name);\n    };\n\n    return o;\n}\n\nvar person = Person('yuchi');\nperson.sayName();\n~~~\n上述代码示例的 `person` 对象将无法直接访问 `name` 属性。这样的代码会更安全。\n\n# 3. 继承\n继承是面向对象中的一个重要概念。`JavaScript` 的继承要从原型链开始说起。\n\n## 3.1 原型链\n在上一节中我们说过，每一个函数都有一个 `prototype` 指针指向了构造函数的原型对象，每个实例同样有个 `[[Prototype]]` 指针指向了它的构造函数的原型对象。\n当我们使一个对象的原型对象等于另一个类型的实例时，就行成了一种原型相互指向的链式结构，这就是原型链。\n~~~JavaScript\nfunction SuperType() {\n    this.superName = 'super name';\n}\n\nfunction SubType() {\n    this.subName = 'sub name';\n}\n\nSuperType.prototype.saySuperName = function () {\n    console.log(this.superName);\n};\n\nSubType.prototype = new SuperType();\n\nSubType.prototype.saySubName = function () {\n    console.log(this.subName);\n};\n\nvar subType = new SubType();\nsubType.saySuperName();\nsubType.saySubName();\n~~~\n如上代码实现了一个简单的继承，`subType` 不仅可以调用自己的方法 `saySubName` ，还可以通过原型链调用 `saySuperName` 方法。同时要注意，现在 `subType` 的 `constructor` 指向了 `SuperType` 构造函数。\n确定原型和实例的关系依然可以使用 `instanceof` 或者 `isPrototypeOf` 方法，由于原型链的关系，只要当前实例的原型链上出现了将要判断的原型，就会返回 `true` 。\n~~~JavaScript\nconsole.log(subType instanceof Object);\nconsole.log(subType instanceof SubType);\nconsole.log(subType instanceof SuperType);\n\nconsole.log(Object.prototype.isPrototypeOf(subType));\nconsole.log(SubType.prototype.isPrototypeOf(subType));\nconsole.log(SuperType.prototype.isPrototypeOf(subType));\n~~~\n上面的代码都会返回 `true` 。\n另外需要注意，对子类型添加方法的操作需要放在修改子类型原型对象之后，否则子类型的新方法将会被覆盖掉。同样的，对子类型添加方法时也不可以使用对象字面量。\n使用原型链虽然可以实现继承，但原型链实际存在如下问题：\n- 所有子类型的属性都来源与超类型的实例，引用类型会共享。\n- 创建子类型时无法向父类型进行参数扩展。\n\n## 3.2 借用构造函数\n所谓借用构造函数，就是在子类型中去调用超类型的构造函数，而非直接使用超类构造函数定义的属性。\n~~~ JavaScript\nfunction SuperType(arr) {\n    this.arr = arr;\n}\n\nfunction SubType(arr, title) {\n    SuperType.call(this, arr);\n    this.title = title;\n}\n\nvar subType = new SubType([1, 2, 3, 4], 'oo');\n~~~\n上述代码中，我们在子类型的构造函数上执行了父类型的构造函数，同时在子类型构造函数里抽象了对应的参数传递入口，解决了上一小节中提到的问题。\n\n## 3.3 组合继承\n我们在使用构造函数定义对象的章节曾经提到，使用构造函数定义对象时，每一个实例上的同名方法都是不同的，此处使用构造函数实现的继承一样存在这个问题。并且如果使用这种方式实现继承，定义在超类型的原型上的方法将无法继承到子类型上，因而我们将使用两者结合的组合继承。\n组合继承类似于前面提到的组合使用构造函数模式和原型模式，即借用构造函数方法来继承属性，而后使用原型链来继承方法。\n~~~JavaScript\nfunction SuperType(arr) {\n    this.arr = arr;\n}\n\nSuperType.prototype.sayArr = function () {\n    console.log(this.arr);\n}\n\nfunction SubType(arr, title) {\n    SuperType.call(this, arr);\n    this.title = title;\n}\n\nSubType.prototype = new SuperType();\n\nvar subType1 = new SubType([1, 2, 3, 4], 'oo1');\nvar subType2 = new SubType([2, 3, 4, 5], 'oo2');\n\nsubType1.arr.push(200);\n\nconsole.log(subType1.arr);\nconsole.log(subType2.arr);\nconsole.log(subType1.sayArr());\nconsole.log(subType2.sayArr());\n~~~\n像这样修改了代码之后，我们可以使用父类型的方法了，这也是一种比较常见的实现继承的方式。\n\n## 3.4 原型式继承\n原型式继承使用如下格式进行来基于一个已有的对象创建一个类似的，新的对象：\n~~~JavaScript\nfunction object(o) {\n    function F() { }\n    F.prototype = o;\n    return new F();\n}\n~~~\n在 `ECMA Script5` 中定义了 `Object.create` 方法用来实现同样的操作。\n这样的方式实现的继承和原型链继承一样，引用类型的数据会在多个实例间共享。\n\n## 3.5 寄生式继承\n寄生式继承是原型式继承的延续，它使用一个函数来对继承的子类型进行扩展。\n~~~JavaScript\nfunction createObject(o) {\n    var clone = object(o);\n    clone.sayHi = function () {\n        console.log('hi');\n    }\n    return clone;\n}\n~~~\n\n## 3.6 寄生组合式继承\n组合继承存在一个问题，即使用组合继承会调用两次超类型的构造函数（第一次在修改子类型的原型对象，第二次在实例化时）。\n我们可以使用寄生组合式继承来解决这个问题：\n~~~JavaScript\nfunction SuperType(name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nSuperType.prototype.sayName = function () {\n    alert(this.name);\n}\n\nfunction SubType(name, age) {\n    SuperType.call(this, name);\n    this.age = age;\n}\n\ninheritPrototype(SubType, SuperType);\n\nSubType.prototype.sayAge = function () {\n    alert(this.age);\n}\n\nfunction inheritPrototype(subType, superType) {\n    var prototype = object(superType.prototype);\n    prototype.constructor = subType;\n    subType.prototype = prototype;\n}\n\nfunction object(o) {\n    function F() { }\n    F.prototype = o;\n    return new F();\n}\n~~~\n在上述的代码中，我们使用了寄生组合式来实现继承。\n在组合继承中，为了继承父类型的方法，我们第一次调用了父类型的构造函数以获取父类型实例，进而使子类型的原型能够指向父类型。而后继承属性的时候我们实则又调用了一次父类型的构造函数，用于将其绑定到子类型上。\n我们不难看出，在组合继承中我们只是希望获得父类型的方法，属性我们另外使用了借用构造函数的技巧来继承。因而在寄生组合式继承里我们直接选择了绕开调用父类型构造函数的过程，直接使用原型式继承的方式获取了一个和父类型原型相似的对象，并将该对象直接赋值给子类型的原型对象实现原型链继承，当然了在这个过程中我们还可以修改原型链继承中导致的子类型 `constructor` 丢失。","source":"_posts/JavaScript-5-面向对象的程序设计.md","raw":"---\ntitle: JavaScript(5)面向对象的程序设计\ndate: 2020-06-08 20:48:27\ntags:\n  - JavaScript\n  - 前端\ncategories:\n  - JavaScript高级程序设计\n---\n# 1. 对象\n创建一个对象很简单，我们可以很轻松的为其添加属性和方法。属性在创建时都会有一些特性值，它们定义了属性的行为。\n\n## 1.1 属性类型\n在 `JavaScript` 中属性被分为两种：数据属性和访问器属性。\n\n### 1.1.1 数据属性\n数据属性中包含了数据值的位置，这个位置可以写入和读取值，它有4个特性：\n- `[[Configurable]]`：是否可以被 `delete` 删除属性，是否可以修改属性，是否可以将属性修改为访问器属性等。它的默认值是 `true` 。\n- `[[Enumerable]]`：是否可以被 `for-in` 循环返回属性，它的默认值是 `true` 。\n- `[[Writeable]]`：是否可以修改该属性的值，默认值为 `true` 。\n- `[[Value]]`：该属性的数据，默认值是 `undefined` 。\n当需要修改一个数据属性的的特性时，必须使用 `Object.defineProperty()` 方法：\n~~~JavaScript\nlet obj = {}\nObject.defineProperty(obj, 'name', {\n    writable: false,\n    value: 'yuchi'\n});\n\nobj.name = 'bubu';\n\nconsole.log(obj.name);\n~~~\n上述代码打印 `yuchi` ，且由于该属性的 `writable` 被这设定为 `false` ，因而该值无法被修改，在非严格模式下，上述代码中的修改没有效果；在严格模式下，上述代码会抛出错误。\n上述规则同样适用于 'configurable` 特性，但需要注意一点，一旦将一个属性设置为 `configurable: false`， 就不可以再将其设置为 `configurable: true` 了，此时再使用 `Object.defineProperty()` 方法仅能修改 `writable` 属性。\n\n### 1.1.2 访问器属性\n访问器属性与数据属性的区别在于它不包含数据值，但它包含一对 `getter/setter` 函数。当访问一个属性的时候，会触发该属性的 `getter` 函数，当修改一个属性的时候，会触发该属性的 `setter` 函数。与数据属性相似，它也有4个属性：\n- `[[Configurable]]`：是否可以被 `delete` 删除属性，是否可以修改属性，是否可以将属性修改为访问器属性等。它的默认值是 `true` 。\n- `[[Enumerable]]`：是否可以被 `for-in` 循环返回属性，它的默认值是 `true` 。\n- `[[Get]]`：读取时调用的函数。\n- `[[Set]]`：修改时调用的函数。\n相同的，我们依然需要使用 `Object.defineProperty()` 方法来为对象定义访问器属性。\n~~~ JavaScript\nconst data = {\n    _name: ''\n};\n\nObject.defineProperty(data, 'name', {\n    get: function () {\n        return this._name\n    },\n    set: function (val) {\n        console.log(`${this._name} -> ${val}`);\n        this._name = val;\n    }\n});\n\ndata.name = 'xiaoming';\ndata.name = 'yuchi';\n~~~\n如上代码将 `data.name` 定义为访问器属性，并为其遍写了 `getter/setter` 函数，当我们修改其值时，就可以自动打印属性值的变化情况，需要注意，此处无论是 `getter()` 函数返回的 `name` ，还是 `setter()` 修改了 `name` ，都会再度触发 `getter/setter` 函数，因而我们使用下划线来表示只能通过对象方法访问的属性。\n\n## 1.2 定义多属性\n当我们需要定义多个属性，可以使用 `Object.defineProperties()` 方法，它的用法和上面类似，不过它的第二个参数是一个对象，通过 `key-value` 的结构描述了属性与特性的关系。\n~~~ JavaScript\nObject.defineProperties(data, {\n    name: {\n        get: function () {\n            return this._name\n        },\n        set: function (val) {\n            console.log(`${this._name} -> ${val}`);\n            this._name = val;\n        }\n    },\n    age: {\n        writable: false,\n        value: 18\n    }\n});\n~~~\n\n\n## 1.3 读取属性的特性\n当我们需要获取到某属性的特性时，可以使用 `Object.getOwnPropertyDescriptor()` 方法。直接看代码：\n~~~ JavaScript\nObject.defineProperties(data, {\n    name: {\n        get: function () {\n            return this._name\n        },\n        set: function (val) {\n            console.log(`${this._name} -> ${val}`);\n            this._name = val;\n        }\n    },\n    age: {\n        writable: false,\n        value: 18\n    }\n});\n\nvar descriptor = Object.getOwnPropertyDescriptor(data, 'age');\nconsole.log(descriptor.value);\nconsole.log(descriptor.writable);\n~~~\n\n# 2. 创建对象\n创建对象可以使用构造函数或者对象字面量两种方式。但这样的创建方式略微有些不优雅，因此就有了如下几种衍生的创建方式。\n\n## 2.1 工厂模式\n工厂模式是指使用一个特定的函数来封装对象创建的细节。\n~~~JavaScript\nfunction getConn(url, username, password){\n    var conn = new Object();\n    conn.url = url;\n    conn.username = username;\n    conn.password = password;\n    return conn;\n}\n~~~\n上述代码使用 `getConn` 方法来创建对象，这样做大大缩减了创建同一对象时的代码。\n单它也带来了一个新的问题，就是这样创建的对象是无法识别的，即没有办法知道这个对象的类型。\n\n## 2.2 构造函数模式\n构造函数模式有效的解决了工厂模式无法识别对象类型的问题。\n~~~ JavaScript\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayHello = function () {\n        console.log('heelo');\n    };\n}\nvar person1 = new Person('yuchi', 18, 'api caller');\n~~~\n上述代码我们定义了 `Person` 构造函数，要使用它来创建新实例，我们必须使用 `new` 操作符。创建一个对象会经历如下4个步骤：\n1. 创建一个对象。\n2. 将构造函数的作用域赋给新的对象。\n3. 执行构造函数里的代码。\n4. 返回新的对象。\n\n每一个 `Person` 构造函数实例化的对象都会保存一个单独的实例，它们都具备一个 `constructor` 属性，该属性指向了 `Person` 构造函数。\n这样我们就可以使用 `instanceof` 操作符来确定该实例的类型：\n~~~JavaScript\nconsole.log(person1.constructor === Person);\n~~~\n上面的代码返回 `true` 。\n\n另外，构造函数实际和其它函数并无区别，换言之你可以使用 `new` 来调用任何函数。不过需要注意一点，像如下代码一样不使用 `new` 操作符来实例化对象，最终会将属性绑定到 `window` 对象上。\n~~~JavaScript\nvar person2 = Person('yuchi', 18, 'coder');\nwindow.sayHello();\n~~~\n虽然使用构造函数的方式让我们解决了对象类型无法识别的问题，但仔细看我们会发现，不仅是属性，每一次实例化的时候，我们都会重新创建一个 `sayHello` 方法，即**不同实例上的同名方法是不相等的**。虽然有些场景下我们也许确实需要这样的处理机制，但似乎大多数情况下我们并不希望这样。如何解决这个问题，就要说到原型模式了。\n\n## 2.3 原型模式\n`JavaScript` 是基于原型编程的语言，因而原型是 `JavaScript` 中相当重要的概念。\n我们创建的每一个函数都有一个 `prototype` 属性，它是一个指向原型对象的指针。原型对象里包含了该特定类型所有实例可以共享的属性与方法。\n~~~JavaScript\nfunction Person() {\n\n}\n\nPerson.prototype.sayHello = function () {\n    console.log('hello');\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.sayHello();\nperson2.sayHello();\n~~~\n上述的代码中，我们为 `prototype` 属性添加了一个 `sayHello` 方法，而后所有的实例都可以使用该方法。\n我们之前提到过，使用构造函数创建的实例有各自不同的属性和方法，哪怕它们的创建机制是一样的，不用实例上的同名方法依然是不相等的。但是用原型来创建的方法很好的解决了这个问题，下面的代码将返回 `true` 。\n~~~JavaScript\nperson1.sayHello === person2.sayHello;\n~~~\n在原型模式的一些特性之前，我们首先要理解原型对象。\n本小节开始我们就提到了，每个函数都有一个 `prototype` 属性，它是一个指向原型对象的指针。当我们创建一个自定义的构造函数后，`prototype` 原型对象里默认只保存了一个属性—— `constructor` 属性，它是一个指向 `prototype` 属性所在的函数的指针。这样说也许非常晦涩难懂，我们简单的理解为我们调用的那个构造函数，即：\n~~~JavaScript\nPerson.prototype.constructor === Person;\n~~~\n上述语句返回 `true` 。\n当我们使用构造函数来实例化一个对象后，该对象同样保存了一个指向原型对象的指针，我们通常称之为 `[[Prototype]]` ，在 `chrome` 等浏览器里，可以使用 `__proto__` 来访问到它。我们既然提到了 `__proto__` 与构造函数的 `prototype` 都是指向原型对象，就很容易得到如下代码会返回 `true` ：\n~~~JavaScript\nPerson.prototype === person1.__proto__;\n~~~\n我们必须要提到一点：构造函数与实例间的关联正是通过原型对象来建立**而非直接由构造函数与实例间建立**。实例的 `__proto__` 是否指向构造函数的原型对象，我们可以使用 `isPrototypeOf` 方法来进行判断。如下代码返回 `true` 。\n~~~JavaScript\nPerson.prototype.isPrototypeOf(person1);\n~~~\n\n当代码开始读取实例的某个属性或方法时，会进行一次搜索：当实例具备属性或方法时，返回该属性或方法；当实例不具备属性或方法时，查询它的原型对象是否具备该属性或方法。\n虽然我们可以获取到原型对象中的属性值，却不能修改它，当试图修改原型对象中的属性或方法时，实际只是为实例定义了一个同名属性或方法。根据刚才我们讲到的搜索方法，实例的属性将会屏蔽掉原型对象里的属性，即使将该值设置为 `null` ，我们也无法再次使它获取到原型对象里的属性。不过我们可以使用 `delete` 操作符将实例上的属性或方法完全删除掉，这样再次访问时就会继续访问原型对象上的属性和方法了。\n~~~JavaScript\nfunction Person() {\n}\nPerson.prototype.name = 'yuchi';\n\nvar person1 = new Person();\n\n// 输出yuchi\nconsole.log(person1.name);\n\nperson1.name = 'lala';\n// 输出 lala\nconsole.log(person1.name);\n\nperson1.name = null\n// 输出null\nconsole.log(person1.name);\n\ndelete person1.name;\n// 输出yuchi\nconsole.log(person1.name);\n~~~\n我们可以使用 `hasOwnProperty` 方法来判断一个属性究竟在实例上还是原型对象上。\n~~~ JavaScript\n// 结果为false\nperson1.hasOwnProperty('name');\n~~~\n由于 `hasOwnProperty` 只能判断属性是否在实例上，当我们需要判断一个属性是否存在与原型上时，可以将它与 `in` 操作符配合起来使用。`in` 操作符仅在属性可以访问时返回 `true` 而不会关心属性在实例上还是原型上。因此，当使用 `in` 操作符时返回 `true` 而 `hasOwnProperty` 返回 `false` 时，就可以认为该属性位于原型对象。\n~~~JavaScript\n!person1.hasOwnProperty('name') && ('name' in person1);\n~~~\n当我们有大量的属性与方法需要添加到原型对象上时，可以使用字面量的语法来减少 `Person.prototype` 的键入：\n~~~JavaScript\nPerson.prototype = {\n    name: 'yuchi',\n    age: 23,\n    sayHello: function() {\n        console.log('hello');\n    }\n};\n~~~\n不过你可能需要注意了，这样的写法本质上覆盖了 `Person.prototype` 的所有属性和方法，所以此时的 `constructor` 已经无法确定对象的类型了。\n~~~JavaScript\nfunction Person(){}\n\nPerson.prototype = {\n    name: 'yuchi',\n    age: 23,\n    sayHello: function() {\n        console.log('hello');\n    }\n};\n\nPerson.prototype.constructor === Person;\n~~~\n上述的代码将会返回 `false` 。解决这个问题也很简单，我们只需要显式的指定 `constructor` 即可。\n~~~JavaScript\nfunction Person(){}\n\nPerson.prototype = {\n    constructor: Person,\n    name: 'yuchi',\n    age: 23,\n    sayHello: function() {\n        console.log('hello');\n    }\n};\n\nPerson.prototype.constructor === Person;\n~~~\n这样做之后，代码又可以正常的返回 `true` 了。不过这样的作法并非没有代价，对原型对象的修改可以立即作用在所有已创建的实例上，让我们看看下面的代码：\n~~~JavaScript\nfunction Person(){}\n\nvar person1 = new Person();\nPerson.prototype = {\n    constructor: Person,\n    name: 'yuchi',\n    age: 23,\n    sayHello: function() {\n        console.log('hello');\n    }\n};\n\nperson1.sayHello();\n~~~\n该段代码会抛出异常：`Uncaught TypeError: person1.sayHello is not a function` 。\n这是因为我们在创建了实例后又重写了整个原型对象，事实上，调用构造函数时会为实例添加一个指向最初原型的 `[[Prototype]]` 指针。修改改对象的内容等同于切断了它与最初的原型之间的联系。\n最后，我们虽然使用原型来解决了很多问题，但这并不代表原型对象是完美的。\n~~~JavaScript\nfunction Person(){}\n\nPerson.prototype.obj = {name: 'yuchi', age: 18};\nPerson.prototype.friends = ['xiaohong', 'xiaoming', 'xiaogang'];\n\nvar person1 = new Person()\nvar person2 = new Person()\n\nperson1.obj.name = 'bubu'\nperson2.obj.name\n\nperson1.friends.push('xiaowang')\nperson1.friends\n~~~\n上述代码中对于引用类型的修改最终都直接作用到了原型对象的属性上了，当我们需要使属性共享时，这样是没有问题的。但实例通常要求拥有自己的独立的属性，因而在实际的场景里我们很少单独使用原型模式。\n\n\n## 2.4 组合使用构造函数模式和原型模式\n创建一个自定义的类型最常见的方式就是组合使用构造函数和原型模式。使用构造函数来定义实例属性，使用原型模式来定义共享的属性。\n~~~JavaScript\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n}\n\nPerson.prototype = {\n    constructor: Person,\n    sayHello: function(){console.log('hello')}\n}\n~~~\n\n## 2.5 动态原型模式\n动态原型模式是使用构造函数的模式来定义示例属性，根据需要动态的添加共享属性的模式。\n~~~JavaScript\nfunction Person(name, age){\n    this.name = name;\n    this.age = age;\n\n    if (type this.sayHello != 'function') {\n        Person.prototype.sayHello = function () { console.log('hello'); };\n    }\n}\n~~~\n上述代码会在初次调用构造函数时检测是否具有 `sayHello` 方法，仅在其不存在时动态的对原型添加 `sayHello` 方法。同样要注意此处不应该使用字面量的方法来修改原型，因为它会切断已有实例与原型方法之间的联系。\n\n## 2.6 寄生构造函数模式\n寄生构造函数通常用来对不方便修改的构造函数追加方法（这和 `Ruby` 使用 `Open Class` 来遍写 `Monkey Patch` 有一点相似）。\n~~~ JavaScript\nfunction NumberArray() {\n    var arr = Array();\n    arr.push.apply(arr, arguments);\n    arr.numberSort = function () {\n        return arr.sort(function(val1, val2){return val1 - val2});\n    };\n    return arr;\n}\n~~~\n上述代码我们封装了一个 `NumberArray` 构造函数，并借用  `Array` 构造函数扩展了一个用来给数字进行排序的方法。\n\n## 2.7 稳妥构造函数模式\n稳妥构造函数要求不使用 `new` 操作符初始化示例，且在构造函数内部使用局部变量。\n~~~JavaScript\nfunction Person(name) {\n    var o = new Object();\n    var name = name;\n\n    o.sayName = function () {\n        console.log(name);\n    };\n\n    return o;\n}\n\nvar person = Person('yuchi');\nperson.sayName();\n~~~\n上述代码示例的 `person` 对象将无法直接访问 `name` 属性。这样的代码会更安全。\n\n# 3. 继承\n继承是面向对象中的一个重要概念。`JavaScript` 的继承要从原型链开始说起。\n\n## 3.1 原型链\n在上一节中我们说过，每一个函数都有一个 `prototype` 指针指向了构造函数的原型对象，每个实例同样有个 `[[Prototype]]` 指针指向了它的构造函数的原型对象。\n当我们使一个对象的原型对象等于另一个类型的实例时，就行成了一种原型相互指向的链式结构，这就是原型链。\n~~~JavaScript\nfunction SuperType() {\n    this.superName = 'super name';\n}\n\nfunction SubType() {\n    this.subName = 'sub name';\n}\n\nSuperType.prototype.saySuperName = function () {\n    console.log(this.superName);\n};\n\nSubType.prototype = new SuperType();\n\nSubType.prototype.saySubName = function () {\n    console.log(this.subName);\n};\n\nvar subType = new SubType();\nsubType.saySuperName();\nsubType.saySubName();\n~~~\n如上代码实现了一个简单的继承，`subType` 不仅可以调用自己的方法 `saySubName` ，还可以通过原型链调用 `saySuperName` 方法。同时要注意，现在 `subType` 的 `constructor` 指向了 `SuperType` 构造函数。\n确定原型和实例的关系依然可以使用 `instanceof` 或者 `isPrototypeOf` 方法，由于原型链的关系，只要当前实例的原型链上出现了将要判断的原型，就会返回 `true` 。\n~~~JavaScript\nconsole.log(subType instanceof Object);\nconsole.log(subType instanceof SubType);\nconsole.log(subType instanceof SuperType);\n\nconsole.log(Object.prototype.isPrototypeOf(subType));\nconsole.log(SubType.prototype.isPrototypeOf(subType));\nconsole.log(SuperType.prototype.isPrototypeOf(subType));\n~~~\n上面的代码都会返回 `true` 。\n另外需要注意，对子类型添加方法的操作需要放在修改子类型原型对象之后，否则子类型的新方法将会被覆盖掉。同样的，对子类型添加方法时也不可以使用对象字面量。\n使用原型链虽然可以实现继承，但原型链实际存在如下问题：\n- 所有子类型的属性都来源与超类型的实例，引用类型会共享。\n- 创建子类型时无法向父类型进行参数扩展。\n\n## 3.2 借用构造函数\n所谓借用构造函数，就是在子类型中去调用超类型的构造函数，而非直接使用超类构造函数定义的属性。\n~~~ JavaScript\nfunction SuperType(arr) {\n    this.arr = arr;\n}\n\nfunction SubType(arr, title) {\n    SuperType.call(this, arr);\n    this.title = title;\n}\n\nvar subType = new SubType([1, 2, 3, 4], 'oo');\n~~~\n上述代码中，我们在子类型的构造函数上执行了父类型的构造函数，同时在子类型构造函数里抽象了对应的参数传递入口，解决了上一小节中提到的问题。\n\n## 3.3 组合继承\n我们在使用构造函数定义对象的章节曾经提到，使用构造函数定义对象时，每一个实例上的同名方法都是不同的，此处使用构造函数实现的继承一样存在这个问题。并且如果使用这种方式实现继承，定义在超类型的原型上的方法将无法继承到子类型上，因而我们将使用两者结合的组合继承。\n组合继承类似于前面提到的组合使用构造函数模式和原型模式，即借用构造函数方法来继承属性，而后使用原型链来继承方法。\n~~~JavaScript\nfunction SuperType(arr) {\n    this.arr = arr;\n}\n\nSuperType.prototype.sayArr = function () {\n    console.log(this.arr);\n}\n\nfunction SubType(arr, title) {\n    SuperType.call(this, arr);\n    this.title = title;\n}\n\nSubType.prototype = new SuperType();\n\nvar subType1 = new SubType([1, 2, 3, 4], 'oo1');\nvar subType2 = new SubType([2, 3, 4, 5], 'oo2');\n\nsubType1.arr.push(200);\n\nconsole.log(subType1.arr);\nconsole.log(subType2.arr);\nconsole.log(subType1.sayArr());\nconsole.log(subType2.sayArr());\n~~~\n像这样修改了代码之后，我们可以使用父类型的方法了，这也是一种比较常见的实现继承的方式。\n\n## 3.4 原型式继承\n原型式继承使用如下格式进行来基于一个已有的对象创建一个类似的，新的对象：\n~~~JavaScript\nfunction object(o) {\n    function F() { }\n    F.prototype = o;\n    return new F();\n}\n~~~\n在 `ECMA Script5` 中定义了 `Object.create` 方法用来实现同样的操作。\n这样的方式实现的继承和原型链继承一样，引用类型的数据会在多个实例间共享。\n\n## 3.5 寄生式继承\n寄生式继承是原型式继承的延续，它使用一个函数来对继承的子类型进行扩展。\n~~~JavaScript\nfunction createObject(o) {\n    var clone = object(o);\n    clone.sayHi = function () {\n        console.log('hi');\n    }\n    return clone;\n}\n~~~\n\n## 3.6 寄生组合式继承\n组合继承存在一个问题，即使用组合继承会调用两次超类型的构造函数（第一次在修改子类型的原型对象，第二次在实例化时）。\n我们可以使用寄生组合式继承来解决这个问题：\n~~~JavaScript\nfunction SuperType(name) {\n    this.name = name;\n    this.colors = ['red', 'blue', 'green'];\n}\n\nSuperType.prototype.sayName = function () {\n    alert(this.name);\n}\n\nfunction SubType(name, age) {\n    SuperType.call(this, name);\n    this.age = age;\n}\n\ninheritPrototype(SubType, SuperType);\n\nSubType.prototype.sayAge = function () {\n    alert(this.age);\n}\n\nfunction inheritPrototype(subType, superType) {\n    var prototype = object(superType.prototype);\n    prototype.constructor = subType;\n    subType.prototype = prototype;\n}\n\nfunction object(o) {\n    function F() { }\n    F.prototype = o;\n    return new F();\n}\n~~~\n在上述的代码中，我们使用了寄生组合式来实现继承。\n在组合继承中，为了继承父类型的方法，我们第一次调用了父类型的构造函数以获取父类型实例，进而使子类型的原型能够指向父类型。而后继承属性的时候我们实则又调用了一次父类型的构造函数，用于将其绑定到子类型上。\n我们不难看出，在组合继承中我们只是希望获得父类型的方法，属性我们另外使用了借用构造函数的技巧来继承。因而在寄生组合式继承里我们直接选择了绕开调用父类型构造函数的过程，直接使用原型式继承的方式获取了一个和父类型原型相似的对象，并将该对象直接赋值给子类型的原型对象实现原型链继承，当然了在这个过程中我们还可以修改原型链继承中导致的子类型 `constructor` 丢失。","slug":"JavaScript-5-面向对象的程序设计","published":1,"updated":"2022-05-03T08:09:03.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdtu000br2vef8vkfmsc","content":"<h1 id=\"1-对象\"><a href=\"#1-对象\" class=\"headerlink\" title=\"1. 对象\"></a>1. 对象</h1><p>创建一个对象很简单，我们可以很轻松的为其添加属性和方法。属性在创建时都会有一些特性值，它们定义了属性的行为。</p>\n<h2 id=\"1-1-属性类型\"><a href=\"#1-1-属性类型\" class=\"headerlink\" title=\"1.1 属性类型\"></a>1.1 属性类型</h2><p>在 <code>JavaScript</code> 中属性被分为两种：数据属性和访问器属性。</p>\n<h3 id=\"1-1-1-数据属性\"><a href=\"#1-1-1-数据属性\" class=\"headerlink\" title=\"1.1.1 数据属性\"></a>1.1.1 数据属性</h3><p>数据属性中包含了数据值的位置，这个位置可以写入和读取值，它有4个特性：</p>\n<ul>\n<li><code>[[Configurable]]</code>：是否可以被 <code>delete</code> 删除属性，是否可以修改属性，是否可以将属性修改为访问器属性等。它的默认值是 <code>true</code> 。</li>\n<li><code>[[Enumerable]]</code>：是否可以被 <code>for-in</code> 循环返回属性，它的默认值是 <code>true</code> 。</li>\n<li><code>[[Writeable]]</code>：是否可以修改该属性的值，默认值为 <code>true</code> 。</li>\n<li><code>[[Value]]</code>：该属性的数据，默认值是 <code>undefined</code> 。<br>当需要修改一个数据属性的的特性时，必须使用 <code>Object.defineProperty()</code> 方法：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&#x27;name&#x27;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">writable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"string\">&#x27;yuchi&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"property\">name</span> = <span class=\"string\">&#x27;bubu&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>);</span><br></pre></td></tr></table></figure>\n上述代码打印 <code>yuchi</code> ，且由于该属性的 <code>writable</code> 被这设定为 <code>false</code> ，因而该值无法被修改，在非严格模式下，上述代码中的修改没有效果；在严格模式下，上述代码会抛出错误。<br>上述规则同样适用于 ‘configurable<code>特性，但需要注意一点，一旦将一个属性设置为</code>configurable: false<code>， 就不可以再将其设置为 </code>configurable: true<code>了，此时再使用</code>Object.defineProperty()<code>方法仅能修改</code>writable&#96; 属性。</li>\n</ul>\n<h3 id=\"1-1-2-访问器属性\"><a href=\"#1-1-2-访问器属性\" class=\"headerlink\" title=\"1.1.2 访问器属性\"></a>1.1.2 访问器属性</h3><p>访问器属性与数据属性的区别在于它不包含数据值，但它包含一对 <code>getter/setter</code> 函数。当访问一个属性的时候，会触发该属性的 <code>getter</code> 函数，当修改一个属性的时候，会触发该属性的 <code>setter</code> 函数。与数据属性相似，它也有4个属性：</p>\n<ul>\n<li><code>[[Configurable]]</code>：是否可以被 <code>delete</code> 删除属性，是否可以修改属性，是否可以将属性修改为访问器属性等。它的默认值是 <code>true</code> 。</li>\n<li><code>[[Enumerable]]</code>：是否可以被 <code>for-in</code> 循环返回属性，它的默认值是 <code>true</code> 。</li>\n<li><code>[[Get]]</code>：读取时调用的函数。</li>\n<li><code>[[Set]]</code>：修改时调用的函数。<br>相同的，我们依然需要使用 <code>Object.defineProperty()</code> 方法来为对象定义访问器属性。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">    <span class=\"attr\">_name</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(data, <span class=\"string\">&#x27;name&#x27;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>._name&#125;</span> -&gt; <span class=\"subst\">$&#123;val&#125;</span>`</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span> = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">data.<span class=\"property\">name</span> = <span class=\"string\">&#x27;xiaoming&#x27;</span>;</span><br><span class=\"line\">data.<span class=\"property\">name</span> = <span class=\"string\">&#x27;yuchi&#x27;</span>;</span><br></pre></td></tr></table></figure>\n如上代码将 <code>data.name</code> 定义为访问器属性，并为其遍写了 <code>getter/setter</code> 函数，当我们修改其值时，就可以自动打印属性值的变化情况，需要注意，此处无论是 <code>getter()</code> 函数返回的 <code>name</code> ，还是 <code>setter()</code> 修改了 <code>name</code> ，都会再度触发 <code>getter/setter</code> 函数，因而我们使用下划线来表示只能通过对象方法访问的属性。</li>\n</ul>\n<h2 id=\"1-2-定义多属性\"><a href=\"#1-2-定义多属性\" class=\"headerlink\" title=\"1.2 定义多属性\"></a>1.2 定义多属性</h2><p>当我们需要定义多个属性，可以使用 <code>Object.defineProperties()</code> 方法，它的用法和上面类似，不过它的第二个参数是一个对象，通过 <code>key-value</code> 的结构描述了属性与特性的关系。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperties</span>(data, &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>._name&#125;</span> -&gt; <span class=\"subst\">$&#123;val&#125;</span>`</span>);</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span> = val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">writable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">value</span>: <span class=\"number\">18</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"1-3-读取属性的特性\"><a href=\"#1-3-读取属性的特性\" class=\"headerlink\" title=\"1.3 读取属性的特性\"></a>1.3 读取属性的特性</h2><p>当我们需要获取到某属性的特性时，可以使用 <code>Object.getOwnPropertyDescriptor()</code> 方法。直接看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperties</span>(data, &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>._name&#125;</span> -&gt; <span class=\"subst\">$&#123;val&#125;</span>`</span>);</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span> = val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">writable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">value</span>: <span class=\"number\">18</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> descriptor = <span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyDescriptor</span>(data, <span class=\"string\">&#x27;age&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(descriptor.<span class=\"property\">value</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(descriptor.<span class=\"property\">writable</span>);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-创建对象\"><a href=\"#2-创建对象\" class=\"headerlink\" title=\"2. 创建对象\"></a>2. 创建对象</h1><p>创建对象可以使用构造函数或者对象字面量两种方式。但这样的创建方式略微有些不优雅，因此就有了如下几种衍生的创建方式。</p>\n<h2 id=\"2-1-工厂模式\"><a href=\"#2-1-工厂模式\" class=\"headerlink\" title=\"2.1 工厂模式\"></a>2.1 工厂模式</h2><p>工厂模式是指使用一个特定的函数来封装对象创建的细节。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getConn</span>(<span class=\"params\">url, username, password</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> conn = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    conn.<span class=\"property\">url</span> = url;</span><br><span class=\"line\">    conn.<span class=\"property\">username</span> = username;</span><br><span class=\"line\">    conn.<span class=\"property\">password</span> = password;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码使用 <code>getConn</code> 方法来创建对象，这样做大大缩减了创建同一对象时的代码。<br>单它也带来了一个新的问题，就是这样创建的对象是无法识别的，即没有办法知道这个对象的类型。</p>\n<h2 id=\"2-2-构造函数模式\"><a href=\"#2-2-构造函数模式\" class=\"headerlink\" title=\"2.2 构造函数模式\"></a>2.2 构造函数模式</h2><p>构造函数模式有效的解决了工厂模式无法识别对象类型的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name, age, job</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">job</span> = job;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">sayHello</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;heelo&#x27;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;yuchi&#x27;</span>, <span class=\"number\">18</span>, <span class=\"string\">&#x27;api caller&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码我们定义了 <code>Person</code> 构造函数，要使用它来创建新实例，我们必须使用 <code>new</code> 操作符。创建一个对象会经历如下4个步骤：</p>\n<ol>\n<li>创建一个对象。</li>\n<li>将构造函数的作用域赋给新的对象。</li>\n<li>执行构造函数里的代码。</li>\n<li>返回新的对象。</li>\n</ol>\n<p>每一个 <code>Person</code> 构造函数实例化的对象都会保存一个单独的实例，它们都具备一个 <code>constructor</code> 属性，该属性指向了 <code>Person</code> 构造函数。<br>这样我们就可以使用 <code>instanceof</code> 操作符来确定该实例的类型：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的代码返回 <code>true</code> 。</p>\n<p>另外，构造函数实际和其它函数并无区别，换言之你可以使用 <code>new</code> 来调用任何函数。不过需要注意一点，像如下代码一样不使用 <code>new</code> 操作符来实例化对象，最终会将属性绑定到 <code>window</code> 对象上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;yuchi&#x27;</span>, <span class=\"number\">18</span>, <span class=\"string\">&#x27;coder&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">sayHello</span>();</span><br></pre></td></tr></table></figure>\n<p>虽然使用构造函数的方式让我们解决了对象类型无法识别的问题，但仔细看我们会发现，不仅是属性，每一次实例化的时候，我们都会重新创建一个 <code>sayHello</code> 方法，即<strong>不同实例上的同名方法是不相等的</strong>。虽然有些场景下我们也许确实需要这样的处理机制，但似乎大多数情况下我们并不希望这样。如何解决这个问题，就要说到原型模式了。</p>\n<h2 id=\"2-3-原型模式\"><a href=\"#2-3-原型模式\" class=\"headerlink\" title=\"2.3 原型模式\"></a>2.3 原型模式</h2><p><code>JavaScript</code> 是基于原型编程的语言，因而原型是 <code>JavaScript</code> 中相当重要的概念。<br>我们创建的每一个函数都有一个 <code>prototype</code> 属性，它是一个指向原型对象的指针。原型对象里包含了该特定类型所有实例可以共享的属性与方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayHello</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"title function_\">sayHello</span>();</span><br><span class=\"line\">person2.<span class=\"title function_\">sayHello</span>();</span><br></pre></td></tr></table></figure>\n<p>上述的代码中，我们为 <code>prototype</code> 属性添加了一个 <code>sayHello</code> 方法，而后所有的实例都可以使用该方法。<br>我们之前提到过，使用构造函数创建的实例有各自不同的属性和方法，哪怕它们的创建机制是一样的，不用实例上的同名方法依然是不相等的。但是用原型来创建的方法很好的解决了这个问题，下面的代码将返回 <code>true</code> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person1.<span class=\"property\">sayHello</span> === person2.<span class=\"property\">sayHello</span>;</span><br></pre></td></tr></table></figure>\n<p>在原型模式的一些特性之前，我们首先要理解原型对象。<br>本小节开始我们就提到了，每个函数都有一个 <code>prototype</code> 属性，它是一个指向原型对象的指针。当我们创建一个自定义的构造函数后，<code>prototype</code> 原型对象里默认只保存了一个属性—— <code>constructor</code> 属性，它是一个指向 <code>prototype</code> 属性所在的函数的指针。这样说也许非常晦涩难懂，我们简单的理解为我们调用的那个构造函数，即：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>;</span><br></pre></td></tr></table></figure>\n<p>上述语句返回 <code>true</code> 。<br>当我们使用构造函数来实例化一个对象后，该对象同样保存了一个指向原型对象的指针，我们通常称之为 <code>[[Prototype]]</code> ，在 <code>chrome</code> 等浏览器里，可以使用 <code>__proto__</code> 来访问到它。我们既然提到了 <code>__proto__</code> 与构造函数的 <code>prototype</code> 都是指向原型对象，就很容易得到如下代码会返回 <code>true</code> ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> === person1.<span class=\"property\">__proto__</span>;</span><br></pre></td></tr></table></figure>\n<p>我们必须要提到一点：构造函数与实例间的关联正是通过原型对象来建立<strong>而非直接由构造函数与实例间建立</strong>。实例的 <code>__proto__</code> 是否指向构造函数的原型对象，我们可以使用 <code>isPrototypeOf</code> 方法来进行判断。如下代码返回 <code>true</code> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"title function_\">isPrototypeOf</span>(person1);</span><br></pre></td></tr></table></figure>\n\n<p>当代码开始读取实例的某个属性或方法时，会进行一次搜索：当实例具备属性或方法时，返回该属性或方法；当实例不具备属性或方法时，查询它的原型对象是否具备该属性或方法。<br>虽然我们可以获取到原型对象中的属性值，却不能修改它，当试图修改原型对象中的属性或方法时，实际只是为实例定义了一个同名属性或方法。根据刚才我们讲到的搜索方法，实例的属性将会屏蔽掉原型对象里的属性，即使将该值设置为 <code>null</code> ，我们也无法再次使它获取到原型对象里的属性。不过我们可以使用 <code>delete</code> 操作符将实例上的属性或方法完全删除掉，这样再次访问时就会继续访问原型对象上的属性和方法了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">name</span> = <span class=\"string\">&#x27;yuchi&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出yuchi</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1.<span class=\"property\">name</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"property\">name</span> = <span class=\"string\">&#x27;lala&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 输出 lala</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1.<span class=\"property\">name</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"property\">name</span> = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"comment\">// 输出null</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1.<span class=\"property\">name</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> person1.<span class=\"property\">name</span>;</span><br><span class=\"line\"><span class=\"comment\">// 输出yuchi</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1.<span class=\"property\">name</span>);</span><br></pre></td></tr></table></figure>\n<p>我们可以使用 <code>hasOwnProperty</code> 方法来判断一个属性究竟在实例上还是原型对象上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果为false</span></span><br><span class=\"line\">person1.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>由于 <code>hasOwnProperty</code> 只能判断属性是否在实例上，当我们需要判断一个属性是否存在与原型上时，可以将它与 <code>in</code> 操作符配合起来使用。<code>in</code> 操作符仅在属性可以访问时返回 <code>true</code> 而不会关心属性在实例上还是原型上。因此，当使用 <code>in</code> 操作符时返回 <code>true</code> 而 <code>hasOwnProperty</code> 返回 <code>false</code> 时，就可以认为该属性位于原型对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!person1.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&#x27;name&#x27;</span>) &amp;&amp; (<span class=\"string\">&#x27;name&#x27;</span> <span class=\"keyword\">in</span> person1);</span><br></pre></td></tr></table></figure>\n<p>当我们有大量的属性与方法需要添加到原型对象上时，可以使用字面量的语法来减少 <code>Person.prototype</code> 的键入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayHello</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>不过你可能需要注意了，这样的写法本质上覆盖了 <code>Person.prototype</code> 的所有属性和方法，所以此时的 <code>constructor</code> 已经无法确定对象的类型了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayHello</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>;</span><br></pre></td></tr></table></figure>\n<p>上述的代码将会返回 <code>false</code> 。解决这个问题也很简单，我们只需要显式的指定 <code>constructor</code> 即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: <span class=\"title class_\">Person</span>,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayHello</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>;</span><br></pre></td></tr></table></figure>\n<p>这样做之后，代码又可以正常的返回 <code>true</code> 了。不过这样的作法并非没有代价，对原型对象的修改可以立即作用在所有已创建的实例上，让我们看看下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: <span class=\"title class_\">Person</span>,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayHello</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"title function_\">sayHello</span>();</span><br></pre></td></tr></table></figure>\n<p>该段代码会抛出异常：<code>Uncaught TypeError: person1.sayHello is not a function</code> 。<br>这是因为我们在创建了实例后又重写了整个原型对象，事实上，调用构造函数时会为实例添加一个指向最初原型的 <code>[[Prototype]]</code> 指针。修改改对象的内容等同于切断了它与最初的原型之间的联系。<br>最后，我们虽然使用原型来解决了很多问题，但这并不代表原型对象是完美的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">obj</span> = &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span>&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">friends</span> = [<span class=\"string\">&#x27;xiaohong&#x27;</span>, <span class=\"string\">&#x27;xiaoming&#x27;</span>, <span class=\"string\">&#x27;xiaogang&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>()</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"property\">obj</span>.<span class=\"property\">name</span> = <span class=\"string\">&#x27;bubu&#x27;</span></span><br><span class=\"line\">person2.<span class=\"property\">obj</span>.<span class=\"property\">name</span></span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"property\">friends</span>.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;xiaowang&#x27;</span>)</span><br><span class=\"line\">person1.<span class=\"property\">friends</span></span><br></pre></td></tr></table></figure>\n<p>上述代码中对于引用类型的修改最终都直接作用到了原型对象的属性上了，当我们需要使属性共享时，这样是没有问题的。但实例通常要求拥有自己的独立的属性，因而在实际的场景里我们很少单独使用原型模式。</p>\n<h2 id=\"2-4-组合使用构造函数模式和原型模式\"><a href=\"#2-4-组合使用构造函数模式和原型模式\" class=\"headerlink\" title=\"2.4 组合使用构造函数模式和原型模式\"></a>2.4 组合使用构造函数模式和原型模式</h2><p>创建一个自定义的类型最常见的方式就是组合使用构造函数和原型模式。使用构造函数来定义实例属性，使用原型模式来定义共享的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name, age</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: <span class=\"title class_\">Person</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayHello</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5-动态原型模式\"><a href=\"#2-5-动态原型模式\" class=\"headerlink\" title=\"2.5 动态原型模式\"></a>2.5 动态原型模式</h2><p>动态原型模式是使用构造函数的模式来定义示例属性，根据需要动态的添加共享属性的模式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name, age</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type <span class=\"variable language_\">this</span>.<span class=\"property\">sayHello</span> != <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayHello</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>); &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码会在初次调用构造函数时检测是否具有 <code>sayHello</code> 方法，仅在其不存在时动态的对原型添加 <code>sayHello</code> 方法。同样要注意此处不应该使用字面量的方法来修改原型，因为它会切断已有实例与原型方法之间的联系。</p>\n<h2 id=\"2-6-寄生构造函数模式\"><a href=\"#2-6-寄生构造函数模式\" class=\"headerlink\" title=\"2.6 寄生构造函数模式\"></a>2.6 寄生构造函数模式</h2><p>寄生构造函数通常用来对不方便修改的构造函数追加方法（这和 <code>Ruby</code> 使用 <code>Open Class</code> 来遍写 <code>Monkey Patch</code> 有一点相似）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">NumberArray</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = <span class=\"title class_\">Array</span>();</span><br><span class=\"line\">    arr.<span class=\"property\">push</span>.<span class=\"title function_\">apply</span>(arr, <span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">    arr.<span class=\"property\">numberSort</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr.<span class=\"title function_\">sort</span>(<span class=\"keyword\">function</span>(<span class=\"params\">val1, val2</span>)&#123;<span class=\"keyword\">return</span> val1 - val2&#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码我们封装了一个 <code>NumberArray</code> 构造函数，并借用  <code>Array</code> 构造函数扩展了一个用来给数字进行排序的方法。</p>\n<h2 id=\"2-7-稳妥构造函数模式\"><a href=\"#2-7-稳妥构造函数模式\" class=\"headerlink\" title=\"2.7 稳妥构造函数模式\"></a>2.7 稳妥构造函数模式</h2><p>稳妥构造函数要求不使用 <code>new</code> 操作符初始化示例，且在构造函数内部使用局部变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">    o.<span class=\"property\">sayName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;yuchi&#x27;</span>);</span><br><span class=\"line\">person.<span class=\"title function_\">sayName</span>();</span><br></pre></td></tr></table></figure>\n<p>上述代码示例的 <code>person</code> 对象将无法直接访问 <code>name</code> 属性。这样的代码会更安全。</p>\n<h1 id=\"3-继承\"><a href=\"#3-继承\" class=\"headerlink\" title=\"3. 继承\"></a>3. 继承</h1><p>继承是面向对象中的一个重要概念。<code>JavaScript</code> 的继承要从原型链开始说起。</p>\n<h2 id=\"3-1-原型链\"><a href=\"#3-1-原型链\" class=\"headerlink\" title=\"3.1 原型链\"></a>3.1 原型链</h2><p>在上一节中我们说过，每一个函数都有一个 <code>prototype</code> 指针指向了构造函数的原型对象，每个实例同样有个 <code>[[Prototype]]</code> 指针指向了它的构造函数的原型对象。<br>当我们使一个对象的原型对象等于另一个类型的实例时，就行成了一种原型相互指向的链式结构，这就是原型链。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SuperType</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">superName</span> = <span class=\"string\">&#x27;super name&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SubType</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">subName</span> = <span class=\"string\">&#x27;sub name&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SuperType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">saySuperName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">superName</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SubType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title class_\">SuperType</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SubType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">saySubName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">subName</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> subType = <span class=\"keyword\">new</span> <span class=\"title class_\">SubType</span>();</span><br><span class=\"line\">subType.<span class=\"title function_\">saySuperName</span>();</span><br><span class=\"line\">subType.<span class=\"title function_\">saySubName</span>();</span><br></pre></td></tr></table></figure>\n<p>如上代码实现了一个简单的继承，<code>subType</code> 不仅可以调用自己的方法 <code>saySubName</code> ，还可以通过原型链调用 <code>saySuperName</code> 方法。同时要注意，现在 <code>subType</code> 的 <code>constructor</code> 指向了 <code>SuperType</code> 构造函数。<br>确定原型和实例的关系依然可以使用 <code>instanceof</code> 或者 <code>isPrototypeOf</code> 方法，由于原型链的关系，只要当前实例的原型链上出现了将要判断的原型，就会返回 <code>true</code> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType <span class=\"keyword\">instanceof</span> <span class=\"title class_\">SubType</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType <span class=\"keyword\">instanceof</span> <span class=\"title class_\">SuperType</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"title function_\">isPrototypeOf</span>(subType));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">SubType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"title function_\">isPrototypeOf</span>(subType));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">SuperType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"title function_\">isPrototypeOf</span>(subType));</span><br></pre></td></tr></table></figure>\n<p>上面的代码都会返回 <code>true</code> 。<br>另外需要注意，对子类型添加方法的操作需要放在修改子类型原型对象之后，否则子类型的新方法将会被覆盖掉。同样的，对子类型添加方法时也不可以使用对象字面量。<br>使用原型链虽然可以实现继承，但原型链实际存在如下问题：</p>\n<ul>\n<li>所有子类型的属性都来源与超类型的实例，引用类型会共享。</li>\n<li>创建子类型时无法向父类型进行参数扩展。</li>\n</ul>\n<h2 id=\"3-2-借用构造函数\"><a href=\"#3-2-借用构造函数\" class=\"headerlink\" title=\"3.2 借用构造函数\"></a>3.2 借用构造函数</h2><p>所谓借用构造函数，就是在子类型中去调用超类型的构造函数，而非直接使用超类构造函数定义的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SuperType</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">arr</span> = arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SubType</span>(<span class=\"params\">arr, title</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">SuperType</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, arr);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">title</span> = title;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> subType = <span class=\"keyword\">new</span> <span class=\"title class_\">SubType</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"string\">&#x27;oo&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码中，我们在子类型的构造函数上执行了父类型的构造函数，同时在子类型构造函数里抽象了对应的参数传递入口，解决了上一小节中提到的问题。</p>\n<h2 id=\"3-3-组合继承\"><a href=\"#3-3-组合继承\" class=\"headerlink\" title=\"3.3 组合继承\"></a>3.3 组合继承</h2><p>我们在使用构造函数定义对象的章节曾经提到，使用构造函数定义对象时，每一个实例上的同名方法都是不同的，此处使用构造函数实现的继承一样存在这个问题。并且如果使用这种方式实现继承，定义在超类型的原型上的方法将无法继承到子类型上，因而我们将使用两者结合的组合继承。<br>组合继承类似于前面提到的组合使用构造函数模式和原型模式，即借用构造函数方法来继承属性，而后使用原型链来继承方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SuperType</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">arr</span> = arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SuperType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayArr</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">arr</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SubType</span>(<span class=\"params\">arr, title</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">SuperType</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, arr);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">title</span> = title;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SubType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title class_\">SuperType</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> subType1 = <span class=\"keyword\">new</span> <span class=\"title class_\">SubType</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"string\">&#x27;oo1&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> subType2 = <span class=\"keyword\">new</span> <span class=\"title class_\">SubType</span>([<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], <span class=\"string\">&#x27;oo2&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">subType1.<span class=\"property\">arr</span>.<span class=\"title function_\">push</span>(<span class=\"number\">200</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType1.<span class=\"property\">arr</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType2.<span class=\"property\">arr</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType1.<span class=\"title function_\">sayArr</span>());</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType2.<span class=\"title function_\">sayArr</span>());</span><br></pre></td></tr></table></figure>\n<p>像这样修改了代码之后，我们可以使用父类型的方法了，这也是一种比较常见的实现继承的方式。</p>\n<h2 id=\"3-4-原型式继承\"><a href=\"#3-4-原型式继承\" class=\"headerlink\" title=\"3.4 原型式继承\"></a>3.4 原型式继承</h2><p>原型式继承使用如下格式进行来基于一个已有的对象创建一个类似的，新的对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">object</span>(<span class=\"params\">o</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">F</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">    F.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">F</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>ECMA Script5</code> 中定义了 <code>Object.create</code> 方法用来实现同样的操作。<br>这样的方式实现的继承和原型链继承一样，引用类型的数据会在多个实例间共享。</p>\n<h2 id=\"3-5-寄生式继承\"><a href=\"#3-5-寄生式继承\" class=\"headerlink\" title=\"3.5 寄生式继承\"></a>3.5 寄生式继承</h2><p>寄生式继承是原型式继承的延续，它使用一个函数来对继承的子类型进行扩展。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createObject</span>(<span class=\"params\">o</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> clone = <span class=\"title function_\">object</span>(o);</span><br><span class=\"line\">    clone.<span class=\"property\">sayHi</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hi&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6-寄生组合式继承\"><a href=\"#3-6-寄生组合式继承\" class=\"headerlink\" title=\"3.6 寄生组合式继承\"></a>3.6 寄生组合式继承</h2><p>组合继承存在一个问题，即使用组合继承会调用两次超类型的构造函数（第一次在修改子类型的原型对象，第二次在实例化时）。<br>我们可以使用寄生组合式继承来解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SuperType</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">colors</span> = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;blue&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SuperType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SubType</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">SuperType</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, name);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">inheritPrototype</span>(<span class=\"title class_\">SubType</span>, <span class=\"title class_\">SuperType</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SubType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayAge</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">age</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">inheritPrototype</span>(<span class=\"params\">subType, superType</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prototype = <span class=\"title function_\">object</span>(superType.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\">    prototype.<span class=\"property\">constructor</span> = subType;</span><br><span class=\"line\">    subType.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = prototype;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">object</span>(<span class=\"params\">o</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">F</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">    F.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">F</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述的代码中，我们使用了寄生组合式来实现继承。<br>在组合继承中，为了继承父类型的方法，我们第一次调用了父类型的构造函数以获取父类型实例，进而使子类型的原型能够指向父类型。而后继承属性的时候我们实则又调用了一次父类型的构造函数，用于将其绑定到子类型上。<br>我们不难看出，在组合继承中我们只是希望获得父类型的方法，属性我们另外使用了借用构造函数的技巧来继承。因而在寄生组合式继承里我们直接选择了绕开调用父类型构造函数的过程，直接使用原型式继承的方式获取了一个和父类型原型相似的对象，并将该对象直接赋值给子类型的原型对象实现原型链继承，当然了在这个过程中我们还可以修改原型链继承中导致的子类型 <code>constructor</code> 丢失。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"1-对象\"><a href=\"#1-对象\" class=\"headerlink\" title=\"1. 对象\"></a>1. 对象</h1><p>创建一个对象很简单，我们可以很轻松的为其添加属性和方法。属性在创建时都会有一些特性值，它们定义了属性的行为。</p>\n<h2 id=\"1-1-属性类型\"><a href=\"#1-1-属性类型\" class=\"headerlink\" title=\"1.1 属性类型\"></a>1.1 属性类型</h2><p>在 <code>JavaScript</code> 中属性被分为两种：数据属性和访问器属性。</p>\n<h3 id=\"1-1-1-数据属性\"><a href=\"#1-1-1-数据属性\" class=\"headerlink\" title=\"1.1.1 数据属性\"></a>1.1.1 数据属性</h3><p>数据属性中包含了数据值的位置，这个位置可以写入和读取值，它有4个特性：</p>\n<ul>\n<li><code>[[Configurable]]</code>：是否可以被 <code>delete</code> 删除属性，是否可以修改属性，是否可以将属性修改为访问器属性等。它的默认值是 <code>true</code> 。</li>\n<li><code>[[Enumerable]]</code>：是否可以被 <code>for-in</code> 循环返回属性，它的默认值是 <code>true</code> 。</li>\n<li><code>[[Writeable]]</code>：是否可以修改该属性的值，默认值为 <code>true</code> 。</li>\n<li><code>[[Value]]</code>：该属性的数据，默认值是 <code>undefined</code> 。<br>当需要修改一个数据属性的的特性时，必须使用 <code>Object.defineProperty()</code> 方法：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;&#125;</span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(obj, <span class=\"string\">&#x27;name&#x27;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">writable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">value</span>: <span class=\"string\">&#x27;yuchi&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"property\">name</span> = <span class=\"string\">&#x27;bubu&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">name</span>);</span><br></pre></td></tr></table></figure>\n上述代码打印 <code>yuchi</code> ，且由于该属性的 <code>writable</code> 被这设定为 <code>false</code> ，因而该值无法被修改，在非严格模式下，上述代码中的修改没有效果；在严格模式下，上述代码会抛出错误。<br>上述规则同样适用于 ‘configurable<code>特性，但需要注意一点，一旦将一个属性设置为</code>configurable: false<code>， 就不可以再将其设置为 </code>configurable: true<code>了，此时再使用</code>Object.defineProperty()<code>方法仅能修改</code>writable&#96; 属性。</li>\n</ul>\n<h3 id=\"1-1-2-访问器属性\"><a href=\"#1-1-2-访问器属性\" class=\"headerlink\" title=\"1.1.2 访问器属性\"></a>1.1.2 访问器属性</h3><p>访问器属性与数据属性的区别在于它不包含数据值，但它包含一对 <code>getter/setter</code> 函数。当访问一个属性的时候，会触发该属性的 <code>getter</code> 函数，当修改一个属性的时候，会触发该属性的 <code>setter</code> 函数。与数据属性相似，它也有4个属性：</p>\n<ul>\n<li><code>[[Configurable]]</code>：是否可以被 <code>delete</code> 删除属性，是否可以修改属性，是否可以将属性修改为访问器属性等。它的默认值是 <code>true</code> 。</li>\n<li><code>[[Enumerable]]</code>：是否可以被 <code>for-in</code> 循环返回属性，它的默认值是 <code>true</code> 。</li>\n<li><code>[[Get]]</code>：读取时调用的函数。</li>\n<li><code>[[Set]]</code>：修改时调用的函数。<br>相同的，我们依然需要使用 <code>Object.defineProperty()</code> 方法来为对象定义访问器属性。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">    <span class=\"attr\">_name</span>: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(data, <span class=\"string\">&#x27;name&#x27;</span>, &#123;</span><br><span class=\"line\">    <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>._name&#125;</span> -&gt; <span class=\"subst\">$&#123;val&#125;</span>`</span>);</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span> = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">data.<span class=\"property\">name</span> = <span class=\"string\">&#x27;xiaoming&#x27;</span>;</span><br><span class=\"line\">data.<span class=\"property\">name</span> = <span class=\"string\">&#x27;yuchi&#x27;</span>;</span><br></pre></td></tr></table></figure>\n如上代码将 <code>data.name</code> 定义为访问器属性，并为其遍写了 <code>getter/setter</code> 函数，当我们修改其值时，就可以自动打印属性值的变化情况，需要注意，此处无论是 <code>getter()</code> 函数返回的 <code>name</code> ，还是 <code>setter()</code> 修改了 <code>name</code> ，都会再度触发 <code>getter/setter</code> 函数，因而我们使用下划线来表示只能通过对象方法访问的属性。</li>\n</ul>\n<h2 id=\"1-2-定义多属性\"><a href=\"#1-2-定义多属性\" class=\"headerlink\" title=\"1.2 定义多属性\"></a>1.2 定义多属性</h2><p>当我们需要定义多个属性，可以使用 <code>Object.defineProperties()</code> 方法，它的用法和上面类似，不过它的第二个参数是一个对象，通过 <code>key-value</code> 的结构描述了属性与特性的关系。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperties</span>(data, &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>._name&#125;</span> -&gt; <span class=\"subst\">$&#123;val&#125;</span>`</span>);</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span> = val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">writable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">value</span>: <span class=\"number\">18</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"1-3-读取属性的特性\"><a href=\"#1-3-读取属性的特性\" class=\"headerlink\" title=\"1.3 读取属性的特性\"></a>1.3 读取属性的特性</h2><p>当我们需要获取到某属性的特性时，可以使用 <code>Object.getOwnPropertyDescriptor()</code> 方法。直接看代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperties</span>(data, &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">set</span>: <span class=\"keyword\">function</span> (<span class=\"params\">val</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>._name&#125;</span> -&gt; <span class=\"subst\">$&#123;val&#125;</span>`</span>);</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">_name</span> = val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">writable</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        <span class=\"attr\">value</span>: <span class=\"number\">18</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> descriptor = <span class=\"title class_\">Object</span>.<span class=\"title function_\">getOwnPropertyDescriptor</span>(data, <span class=\"string\">&#x27;age&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(descriptor.<span class=\"property\">value</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(descriptor.<span class=\"property\">writable</span>);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-创建对象\"><a href=\"#2-创建对象\" class=\"headerlink\" title=\"2. 创建对象\"></a>2. 创建对象</h1><p>创建对象可以使用构造函数或者对象字面量两种方式。但这样的创建方式略微有些不优雅，因此就有了如下几种衍生的创建方式。</p>\n<h2 id=\"2-1-工厂模式\"><a href=\"#2-1-工厂模式\" class=\"headerlink\" title=\"2.1 工厂模式\"></a>2.1 工厂模式</h2><p>工厂模式是指使用一个特定的函数来封装对象创建的细节。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getConn</span>(<span class=\"params\">url, username, password</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> conn = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    conn.<span class=\"property\">url</span> = url;</span><br><span class=\"line\">    conn.<span class=\"property\">username</span> = username;</span><br><span class=\"line\">    conn.<span class=\"property\">password</span> = password;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码使用 <code>getConn</code> 方法来创建对象，这样做大大缩减了创建同一对象时的代码。<br>单它也带来了一个新的问题，就是这样创建的对象是无法识别的，即没有办法知道这个对象的类型。</p>\n<h2 id=\"2-2-构造函数模式\"><a href=\"#2-2-构造函数模式\" class=\"headerlink\" title=\"2.2 构造函数模式\"></a>2.2 构造函数模式</h2><p>构造函数模式有效的解决了工厂模式无法识别对象类型的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name, age, job</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">job</span> = job;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">sayHello</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;heelo&#x27;</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;yuchi&#x27;</span>, <span class=\"number\">18</span>, <span class=\"string\">&#x27;api caller&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码我们定义了 <code>Person</code> 构造函数，要使用它来创建新实例，我们必须使用 <code>new</code> 操作符。创建一个对象会经历如下4个步骤：</p>\n<ol>\n<li>创建一个对象。</li>\n<li>将构造函数的作用域赋给新的对象。</li>\n<li>执行构造函数里的代码。</li>\n<li>返回新的对象。</li>\n</ol>\n<p>每一个 <code>Person</code> 构造函数实例化的对象都会保存一个单独的实例，它们都具备一个 <code>constructor</code> 属性，该属性指向了 <code>Person</code> 构造函数。<br>这样我们就可以使用 <code>instanceof</code> 操作符来确定该实例的类型：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的代码返回 <code>true</code> 。</p>\n<p>另外，构造函数实际和其它函数并无区别，换言之你可以使用 <code>new</code> 来调用任何函数。不过需要注意一点，像如下代码一样不使用 <code>new</code> 操作符来实例化对象，最终会将属性绑定到 <code>window</code> 对象上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;yuchi&#x27;</span>, <span class=\"number\">18</span>, <span class=\"string\">&#x27;coder&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">sayHello</span>();</span><br></pre></td></tr></table></figure>\n<p>虽然使用构造函数的方式让我们解决了对象类型无法识别的问题，但仔细看我们会发现，不仅是属性，每一次实例化的时候，我们都会重新创建一个 <code>sayHello</code> 方法，即<strong>不同实例上的同名方法是不相等的</strong>。虽然有些场景下我们也许确实需要这样的处理机制，但似乎大多数情况下我们并不希望这样。如何解决这个问题，就要说到原型模式了。</p>\n<h2 id=\"2-3-原型模式\"><a href=\"#2-3-原型模式\" class=\"headerlink\" title=\"2.3 原型模式\"></a>2.3 原型模式</h2><p><code>JavaScript</code> 是基于原型编程的语言，因而原型是 <code>JavaScript</code> 中相当重要的概念。<br>我们创建的每一个函数都有一个 <code>prototype</code> 属性，它是一个指向原型对象的指针。原型对象里包含了该特定类型所有实例可以共享的属性与方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayHello</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"title function_\">sayHello</span>();</span><br><span class=\"line\">person2.<span class=\"title function_\">sayHello</span>();</span><br></pre></td></tr></table></figure>\n<p>上述的代码中，我们为 <code>prototype</code> 属性添加了一个 <code>sayHello</code> 方法，而后所有的实例都可以使用该方法。<br>我们之前提到过，使用构造函数创建的实例有各自不同的属性和方法，哪怕它们的创建机制是一样的，不用实例上的同名方法依然是不相等的。但是用原型来创建的方法很好的解决了这个问题，下面的代码将返回 <code>true</code> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person1.<span class=\"property\">sayHello</span> === person2.<span class=\"property\">sayHello</span>;</span><br></pre></td></tr></table></figure>\n<p>在原型模式的一些特性之前，我们首先要理解原型对象。<br>本小节开始我们就提到了，每个函数都有一个 <code>prototype</code> 属性，它是一个指向原型对象的指针。当我们创建一个自定义的构造函数后，<code>prototype</code> 原型对象里默认只保存了一个属性—— <code>constructor</code> 属性，它是一个指向 <code>prototype</code> 属性所在的函数的指针。这样说也许非常晦涩难懂，我们简单的理解为我们调用的那个构造函数，即：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>;</span><br></pre></td></tr></table></figure>\n<p>上述语句返回 <code>true</code> 。<br>当我们使用构造函数来实例化一个对象后，该对象同样保存了一个指向原型对象的指针，我们通常称之为 <code>[[Prototype]]</code> ，在 <code>chrome</code> 等浏览器里，可以使用 <code>__proto__</code> 来访问到它。我们既然提到了 <code>__proto__</code> 与构造函数的 <code>prototype</code> 都是指向原型对象，就很容易得到如下代码会返回 <code>true</code> ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> === person1.<span class=\"property\">__proto__</span>;</span><br></pre></td></tr></table></figure>\n<p>我们必须要提到一点：构造函数与实例间的关联正是通过原型对象来建立<strong>而非直接由构造函数与实例间建立</strong>。实例的 <code>__proto__</code> 是否指向构造函数的原型对象，我们可以使用 <code>isPrototypeOf</code> 方法来进行判断。如下代码返回 <code>true</code> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"title function_\">isPrototypeOf</span>(person1);</span><br></pre></td></tr></table></figure>\n\n<p>当代码开始读取实例的某个属性或方法时，会进行一次搜索：当实例具备属性或方法时，返回该属性或方法；当实例不具备属性或方法时，查询它的原型对象是否具备该属性或方法。<br>虽然我们可以获取到原型对象中的属性值，却不能修改它，当试图修改原型对象中的属性或方法时，实际只是为实例定义了一个同名属性或方法。根据刚才我们讲到的搜索方法，实例的属性将会屏蔽掉原型对象里的属性，即使将该值设置为 <code>null</code> ，我们也无法再次使它获取到原型对象里的属性。不过我们可以使用 <code>delete</code> 操作符将实例上的属性或方法完全删除掉，这样再次访问时就会继续访问原型对象上的属性和方法了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">name</span> = <span class=\"string\">&#x27;yuchi&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出yuchi</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1.<span class=\"property\">name</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"property\">name</span> = <span class=\"string\">&#x27;lala&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 输出 lala</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1.<span class=\"property\">name</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"property\">name</span> = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"comment\">// 输出null</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1.<span class=\"property\">name</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> person1.<span class=\"property\">name</span>;</span><br><span class=\"line\"><span class=\"comment\">// 输出yuchi</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person1.<span class=\"property\">name</span>);</span><br></pre></td></tr></table></figure>\n<p>我们可以使用 <code>hasOwnProperty</code> 方法来判断一个属性究竟在实例上还是原型对象上。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结果为false</span></span><br><span class=\"line\">person1.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>由于 <code>hasOwnProperty</code> 只能判断属性是否在实例上，当我们需要判断一个属性是否存在与原型上时，可以将它与 <code>in</code> 操作符配合起来使用。<code>in</code> 操作符仅在属性可以访问时返回 <code>true</code> 而不会关心属性在实例上还是原型上。因此，当使用 <code>in</code> 操作符时返回 <code>true</code> 而 <code>hasOwnProperty</code> 返回 <code>false</code> 时，就可以认为该属性位于原型对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!person1.<span class=\"title function_\">hasOwnProperty</span>(<span class=\"string\">&#x27;name&#x27;</span>) &amp;&amp; (<span class=\"string\">&#x27;name&#x27;</span> <span class=\"keyword\">in</span> person1);</span><br></pre></td></tr></table></figure>\n<p>当我们有大量的属性与方法需要添加到原型对象上时，可以使用字面量的语法来减少 <code>Person.prototype</code> 的键入：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayHello</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>不过你可能需要注意了，这样的写法本质上覆盖了 <code>Person.prototype</code> 的所有属性和方法，所以此时的 <code>constructor</code> 已经无法确定对象的类型了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayHello</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>;</span><br></pre></td></tr></table></figure>\n<p>上述的代码将会返回 <code>false</code> 。解决这个问题也很简单，我们只需要显式的指定 <code>constructor</code> 即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: <span class=\"title class_\">Person</span>,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayHello</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> === <span class=\"title class_\">Person</span>;</span><br></pre></td></tr></table></figure>\n<p>这样做之后，代码又可以正常的返回 <code>true</code> 了。不过这样的作法并非没有代价，对原型对象的修改可以立即作用在所有已创建的实例上，让我们看看下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: <span class=\"title class_\">Person</span>,</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">23</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayHello</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"title function_\">sayHello</span>();</span><br></pre></td></tr></table></figure>\n<p>该段代码会抛出异常：<code>Uncaught TypeError: person1.sayHello is not a function</code> 。<br>这是因为我们在创建了实例后又重写了整个原型对象，事实上，调用构造函数时会为实例添加一个指向最初原型的 <code>[[Prototype]]</code> 指针。修改改对象的内容等同于切断了它与最初的原型之间的联系。<br>最后，我们虽然使用原型来解决了很多问题，但这并不代表原型对象是完美的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\"></span>)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">obj</span> = &#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">18</span>&#125;;</span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">friends</span> = [<span class=\"string\">&#x27;xiaohong&#x27;</span>, <span class=\"string\">&#x27;xiaoming&#x27;</span>, <span class=\"string\">&#x27;xiaogang&#x27;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>()</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"property\">obj</span>.<span class=\"property\">name</span> = <span class=\"string\">&#x27;bubu&#x27;</span></span><br><span class=\"line\">person2.<span class=\"property\">obj</span>.<span class=\"property\">name</span></span><br><span class=\"line\"></span><br><span class=\"line\">person1.<span class=\"property\">friends</span>.<span class=\"title function_\">push</span>(<span class=\"string\">&#x27;xiaowang&#x27;</span>)</span><br><span class=\"line\">person1.<span class=\"property\">friends</span></span><br></pre></td></tr></table></figure>\n<p>上述代码中对于引用类型的修改最终都直接作用到了原型对象的属性上了，当我们需要使属性共享时，这样是没有问题的。但实例通常要求拥有自己的独立的属性，因而在实际的场景里我们很少单独使用原型模式。</p>\n<h2 id=\"2-4-组合使用构造函数模式和原型模式\"><a href=\"#2-4-组合使用构造函数模式和原型模式\" class=\"headerlink\" title=\"2.4 组合使用构造函数模式和原型模式\"></a>2.4 组合使用构造函数模式和原型模式</h2><p>创建一个自定义的类型最常见的方式就是组合使用构造函数和原型模式。使用构造函数来定义实例属性，使用原型模式来定义共享的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name, age</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">constructor</span>: <span class=\"title class_\">Person</span>,</span><br><span class=\"line\">    <span class=\"attr\">sayHello</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>)&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5-动态原型模式\"><a href=\"#2-5-动态原型模式\" class=\"headerlink\" title=\"2.5 动态原型模式\"></a>2.5 动态原型模式</h2><p>动态原型模式是使用构造函数的模式来定义示例属性，根据需要动态的添加共享属性的模式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name, age</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type <span class=\"variable language_\">this</span>.<span class=\"property\">sayHello</span> != <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayHello</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hello&#x27;</span>); &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码会在初次调用构造函数时检测是否具有 <code>sayHello</code> 方法，仅在其不存在时动态的对原型添加 <code>sayHello</code> 方法。同样要注意此处不应该使用字面量的方法来修改原型，因为它会切断已有实例与原型方法之间的联系。</p>\n<h2 id=\"2-6-寄生构造函数模式\"><a href=\"#2-6-寄生构造函数模式\" class=\"headerlink\" title=\"2.6 寄生构造函数模式\"></a>2.6 寄生构造函数模式</h2><p>寄生构造函数通常用来对不方便修改的构造函数追加方法（这和 <code>Ruby</code> 使用 <code>Open Class</code> 来遍写 <code>Monkey Patch</code> 有一点相似）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">NumberArray</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = <span class=\"title class_\">Array</span>();</span><br><span class=\"line\">    arr.<span class=\"property\">push</span>.<span class=\"title function_\">apply</span>(arr, <span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">    arr.<span class=\"property\">numberSort</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr.<span class=\"title function_\">sort</span>(<span class=\"keyword\">function</span>(<span class=\"params\">val1, val2</span>)&#123;<span class=\"keyword\">return</span> val1 - val2&#125;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码我们封装了一个 <code>NumberArray</code> 构造函数，并借用  <code>Array</code> 构造函数扩展了一个用来给数字进行排序的方法。</p>\n<h2 id=\"2-7-稳妥构造函数模式\"><a href=\"#2-7-稳妥构造函数模式\" class=\"headerlink\" title=\"2.7 稳妥构造函数模式\"></a>2.7 稳妥构造函数模式</h2><p>稳妥构造函数要求不使用 <code>new</code> 操作符初始化示例，且在构造函数内部使用局部变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name = name;</span><br><span class=\"line\"></span><br><span class=\"line\">    o.<span class=\"property\">sayName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;yuchi&#x27;</span>);</span><br><span class=\"line\">person.<span class=\"title function_\">sayName</span>();</span><br></pre></td></tr></table></figure>\n<p>上述代码示例的 <code>person</code> 对象将无法直接访问 <code>name</code> 属性。这样的代码会更安全。</p>\n<h1 id=\"3-继承\"><a href=\"#3-继承\" class=\"headerlink\" title=\"3. 继承\"></a>3. 继承</h1><p>继承是面向对象中的一个重要概念。<code>JavaScript</code> 的继承要从原型链开始说起。</p>\n<h2 id=\"3-1-原型链\"><a href=\"#3-1-原型链\" class=\"headerlink\" title=\"3.1 原型链\"></a>3.1 原型链</h2><p>在上一节中我们说过，每一个函数都有一个 <code>prototype</code> 指针指向了构造函数的原型对象，每个实例同样有个 <code>[[Prototype]]</code> 指针指向了它的构造函数的原型对象。<br>当我们使一个对象的原型对象等于另一个类型的实例时，就行成了一种原型相互指向的链式结构，这就是原型链。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SuperType</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">superName</span> = <span class=\"string\">&#x27;super name&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SubType</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">subName</span> = <span class=\"string\">&#x27;sub name&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SuperType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">saySuperName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">superName</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SubType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title class_\">SuperType</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SubType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">saySubName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">subName</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> subType = <span class=\"keyword\">new</span> <span class=\"title class_\">SubType</span>();</span><br><span class=\"line\">subType.<span class=\"title function_\">saySuperName</span>();</span><br><span class=\"line\">subType.<span class=\"title function_\">saySubName</span>();</span><br></pre></td></tr></table></figure>\n<p>如上代码实现了一个简单的继承，<code>subType</code> 不仅可以调用自己的方法 <code>saySubName</code> ，还可以通过原型链调用 <code>saySuperName</code> 方法。同时要注意，现在 <code>subType</code> 的 <code>constructor</code> 指向了 <code>SuperType</code> 构造函数。<br>确定原型和实例的关系依然可以使用 <code>instanceof</code> 或者 <code>isPrototypeOf</code> 方法，由于原型链的关系，只要当前实例的原型链上出现了将要判断的原型，就会返回 <code>true</code> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType <span class=\"keyword\">instanceof</span> <span class=\"title class_\">Object</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType <span class=\"keyword\">instanceof</span> <span class=\"title class_\">SubType</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType <span class=\"keyword\">instanceof</span> <span class=\"title class_\">SuperType</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"title function_\">isPrototypeOf</span>(subType));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">SubType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"title function_\">isPrototypeOf</span>(subType));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">SuperType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"title function_\">isPrototypeOf</span>(subType));</span><br></pre></td></tr></table></figure>\n<p>上面的代码都会返回 <code>true</code> 。<br>另外需要注意，对子类型添加方法的操作需要放在修改子类型原型对象之后，否则子类型的新方法将会被覆盖掉。同样的，对子类型添加方法时也不可以使用对象字面量。<br>使用原型链虽然可以实现继承，但原型链实际存在如下问题：</p>\n<ul>\n<li>所有子类型的属性都来源与超类型的实例，引用类型会共享。</li>\n<li>创建子类型时无法向父类型进行参数扩展。</li>\n</ul>\n<h2 id=\"3-2-借用构造函数\"><a href=\"#3-2-借用构造函数\" class=\"headerlink\" title=\"3.2 借用构造函数\"></a>3.2 借用构造函数</h2><p>所谓借用构造函数，就是在子类型中去调用超类型的构造函数，而非直接使用超类构造函数定义的属性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SuperType</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">arr</span> = arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SubType</span>(<span class=\"params\">arr, title</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">SuperType</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, arr);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">title</span> = title;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> subType = <span class=\"keyword\">new</span> <span class=\"title class_\">SubType</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"string\">&#x27;oo&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>上述代码中，我们在子类型的构造函数上执行了父类型的构造函数，同时在子类型构造函数里抽象了对应的参数传递入口，解决了上一小节中提到的问题。</p>\n<h2 id=\"3-3-组合继承\"><a href=\"#3-3-组合继承\" class=\"headerlink\" title=\"3.3 组合继承\"></a>3.3 组合继承</h2><p>我们在使用构造函数定义对象的章节曾经提到，使用构造函数定义对象时，每一个实例上的同名方法都是不同的，此处使用构造函数实现的继承一样存在这个问题。并且如果使用这种方式实现继承，定义在超类型的原型上的方法将无法继承到子类型上，因而我们将使用两者结合的组合继承。<br>组合继承类似于前面提到的组合使用构造函数模式和原型模式，即借用构造函数方法来继承属性，而后使用原型链来继承方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SuperType</span>(<span class=\"params\">arr</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">arr</span> = arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SuperType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayArr</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">arr</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SubType</span>(<span class=\"params\">arr, title</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">SuperType</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, arr);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">title</span> = title;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SubType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = <span class=\"keyword\">new</span> <span class=\"title class_\">SuperType</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> subType1 = <span class=\"keyword\">new</span> <span class=\"title class_\">SubType</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>], <span class=\"string\">&#x27;oo1&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> subType2 = <span class=\"keyword\">new</span> <span class=\"title class_\">SubType</span>([<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>], <span class=\"string\">&#x27;oo2&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">subType1.<span class=\"property\">arr</span>.<span class=\"title function_\">push</span>(<span class=\"number\">200</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType1.<span class=\"property\">arr</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType2.<span class=\"property\">arr</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType1.<span class=\"title function_\">sayArr</span>());</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(subType2.<span class=\"title function_\">sayArr</span>());</span><br></pre></td></tr></table></figure>\n<p>像这样修改了代码之后，我们可以使用父类型的方法了，这也是一种比较常见的实现继承的方式。</p>\n<h2 id=\"3-4-原型式继承\"><a href=\"#3-4-原型式继承\" class=\"headerlink\" title=\"3.4 原型式继承\"></a>3.4 原型式继承</h2><p>原型式继承使用如下格式进行来基于一个已有的对象创建一个类似的，新的对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">object</span>(<span class=\"params\">o</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">F</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">    F.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">F</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 <code>ECMA Script5</code> 中定义了 <code>Object.create</code> 方法用来实现同样的操作。<br>这样的方式实现的继承和原型链继承一样，引用类型的数据会在多个实例间共享。</p>\n<h2 id=\"3-5-寄生式继承\"><a href=\"#3-5-寄生式继承\" class=\"headerlink\" title=\"3.5 寄生式继承\"></a>3.5 寄生式继承</h2><p>寄生式继承是原型式继承的延续，它使用一个函数来对继承的子类型进行扩展。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">createObject</span>(<span class=\"params\">o</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> clone = <span class=\"title function_\">object</span>(o);</span><br><span class=\"line\">    clone.<span class=\"property\">sayHi</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;hi&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clone;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6-寄生组合式继承\"><a href=\"#3-6-寄生组合式继承\" class=\"headerlink\" title=\"3.6 寄生组合式继承\"></a>3.6 寄生组合式继承</h2><p>组合继承存在一个问题，即使用组合继承会调用两次超类型的构造函数（第一次在修改子类型的原型对象，第二次在实例化时）。<br>我们可以使用寄生组合式继承来解决这个问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SuperType</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">colors</span> = [<span class=\"string\">&#x27;red&#x27;</span>, <span class=\"string\">&#x27;blue&#x27;</span>, <span class=\"string\">&#x27;green&#x27;</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SuperType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayName</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">SubType</span>(<span class=\"params\">name, age</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">SuperType</span>.<span class=\"title function_\">call</span>(<span class=\"variable language_\">this</span>, name);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">age</span> = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">inheritPrototype</span>(<span class=\"title class_\">SubType</span>, <span class=\"title class_\">SuperType</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">SubType</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">sayAge</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">alert</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">age</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">inheritPrototype</span>(<span class=\"params\">subType, superType</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prototype = <span class=\"title function_\">object</span>(superType.<span class=\"property\"><span class=\"keyword\">prototype</span></span>);</span><br><span class=\"line\">    prototype.<span class=\"property\">constructor</span> = subType;</span><br><span class=\"line\">    subType.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = prototype;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">object</span>(<span class=\"params\">o</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">F</span>(<span class=\"params\"></span>) &#123; &#125;</span><br><span class=\"line\">    F.<span class=\"property\"><span class=\"keyword\">prototype</span></span> = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title function_\">F</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述的代码中，我们使用了寄生组合式来实现继承。<br>在组合继承中，为了继承父类型的方法，我们第一次调用了父类型的构造函数以获取父类型实例，进而使子类型的原型能够指向父类型。而后继承属性的时候我们实则又调用了一次父类型的构造函数，用于将其绑定到子类型上。<br>我们不难看出，在组合继承中我们只是希望获得父类型的方法，属性我们另外使用了借用构造函数的技巧来继承。因而在寄生组合式继承里我们直接选择了绕开调用父类型构造函数的过程，直接使用原型式继承的方式获取了一个和父类型原型相似的对象，并将该对象直接赋值给子类型的原型对象实现原型链继承，当然了在这个过程中我们还可以修改原型链继承中导致的子类型 <code>constructor</code> 丢失。</p>\n"},{"title":"JavaScript(6)函数表达式","date":"2020-06-15T13:29:13.000Z","_content":"# 1. 递归\n# 2. 闭包\n## 2.1 闭包与变量\n## 2.2 this对象\n## 2.3 内存泄漏的问题\n# 3. 模仿块级作用域\n# 4. 私有变量\n# 5. 静态私有变量","source":"_posts/JavaScript-6-函数表达式.md","raw":"---\ntitle: JavaScript(6)函数表达式\ndate: 2020-06-15 21:29:13\ntags:\n  - JavaScript\n  - 前端\ncategories:\n  - JavaScript高级程序设计\n---\n# 1. 递归\n# 2. 闭包\n## 2.1 闭包与变量\n## 2.2 this对象\n## 2.3 内存泄漏的问题\n# 3. 模仿块级作用域\n# 4. 私有变量\n# 5. 静态私有变量","slug":"JavaScript-6-函数表达式","published":1,"updated":"2022-05-03T08:09:03.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdtx000fr2ve7nxm4e1t","content":"<h1 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h1><h1 id=\"2-闭包\"><a href=\"#2-闭包\" class=\"headerlink\" title=\"2. 闭包\"></a>2. 闭包</h1><h2 id=\"2-1-闭包与变量\"><a href=\"#2-1-闭包与变量\" class=\"headerlink\" title=\"2.1 闭包与变量\"></a>2.1 闭包与变量</h2><h2 id=\"2-2-this对象\"><a href=\"#2-2-this对象\" class=\"headerlink\" title=\"2.2 this对象\"></a>2.2 this对象</h2><h2 id=\"2-3-内存泄漏的问题\"><a href=\"#2-3-内存泄漏的问题\" class=\"headerlink\" title=\"2.3 内存泄漏的问题\"></a>2.3 内存泄漏的问题</h2><h1 id=\"3-模仿块级作用域\"><a href=\"#3-模仿块级作用域\" class=\"headerlink\" title=\"3. 模仿块级作用域\"></a>3. 模仿块级作用域</h1><h1 id=\"4-私有变量\"><a href=\"#4-私有变量\" class=\"headerlink\" title=\"4. 私有变量\"></a>4. 私有变量</h1><h1 id=\"5-静态私有变量\"><a href=\"#5-静态私有变量\" class=\"headerlink\" title=\"5. 静态私有变量\"></a>5. 静态私有变量</h1>","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"1-递归\"><a href=\"#1-递归\" class=\"headerlink\" title=\"1. 递归\"></a>1. 递归</h1><h1 id=\"2-闭包\"><a href=\"#2-闭包\" class=\"headerlink\" title=\"2. 闭包\"></a>2. 闭包</h1><h2 id=\"2-1-闭包与变量\"><a href=\"#2-1-闭包与变量\" class=\"headerlink\" title=\"2.1 闭包与变量\"></a>2.1 闭包与变量</h2><h2 id=\"2-2-this对象\"><a href=\"#2-2-this对象\" class=\"headerlink\" title=\"2.2 this对象\"></a>2.2 this对象</h2><h2 id=\"2-3-内存泄漏的问题\"><a href=\"#2-3-内存泄漏的问题\" class=\"headerlink\" title=\"2.3 内存泄漏的问题\"></a>2.3 内存泄漏的问题</h2><h1 id=\"3-模仿块级作用域\"><a href=\"#3-模仿块级作用域\" class=\"headerlink\" title=\"3. 模仿块级作用域\"></a>3. 模仿块级作用域</h1><h1 id=\"4-私有变量\"><a href=\"#4-私有变量\" class=\"headerlink\" title=\"4. 私有变量\"></a>4. 私有变量</h1><h1 id=\"5-静态私有变量\"><a href=\"#5-静态私有变量\" class=\"headerlink\" title=\"5. 静态私有变量\"></a>5. 静态私有变量</h1>"},{"_content":"# Linux下如何安装Ruby\n\n## 1. 安装\n\n使用`Ruby`自然首先要安装（废话。\n\n通常我们会使用`RVM`来进行`Ruby`的版本管理：\n\n[RVM官网]([http://rvm.io/](http://rvm.io/))\n\n### 1.1. 安装GPG keys\n~~~shell\ngpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\n~~~\n\n### 1.2. 安装RVM\n使用如下命令安装`RVM`\n~~~bash\n\\curl -sSL https://get.rvm.io | bash -s stable\n~~~\n如果希望默认安装`Ruby`和`Ruby on Rails`也可以直接使用如下命令\n~~~bash\n\\curl -sSL https://get.rvm.io | bash -s stable --rails\n~~~\n\n### 1.3. 查看版本\n~~~bash\nsource /etc/profile.d/rvm.sh\n\nrvm -v\n~~~\n\n### 1.4.  安装指定版本的`Ruby`\n~~~bash\nrvm install 2.5.3\n~~~\n\n## 2. 避雷\n\n### 2.1. 安装`Ruby`时提示`Error running 'requirements\\_debian\\_update\\_system ruby-2.5.3'`\n~~~bash\n rvm autolibs 1\n~~~\n\n### 2.2. 安装`Rails`时提示`ERROR: Failed to build gem native extension.`\n~~~bash\nsudo apt-get install ruby-dev\n~~~\n\n### 2.3. 安装`SQLite3`时提示`ERROR: Failed to build gem native extension.`\n~~~bash\napt-get install sqlite-dev\n~~~\n\n\n","source":"_posts/Linux下如何安装Ruby.md","raw":"# Linux下如何安装Ruby\n\n## 1. 安装\n\n使用`Ruby`自然首先要安装（废话。\n\n通常我们会使用`RVM`来进行`Ruby`的版本管理：\n\n[RVM官网]([http://rvm.io/](http://rvm.io/))\n\n### 1.1. 安装GPG keys\n~~~shell\ngpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\n~~~\n\n### 1.2. 安装RVM\n使用如下命令安装`RVM`\n~~~bash\n\\curl -sSL https://get.rvm.io | bash -s stable\n~~~\n如果希望默认安装`Ruby`和`Ruby on Rails`也可以直接使用如下命令\n~~~bash\n\\curl -sSL https://get.rvm.io | bash -s stable --rails\n~~~\n\n### 1.3. 查看版本\n~~~bash\nsource /etc/profile.d/rvm.sh\n\nrvm -v\n~~~\n\n### 1.4.  安装指定版本的`Ruby`\n~~~bash\nrvm install 2.5.3\n~~~\n\n## 2. 避雷\n\n### 2.1. 安装`Ruby`时提示`Error running 'requirements\\_debian\\_update\\_system ruby-2.5.3'`\n~~~bash\n rvm autolibs 1\n~~~\n\n### 2.2. 安装`Rails`时提示`ERROR: Failed to build gem native extension.`\n~~~bash\nsudo apt-get install ruby-dev\n~~~\n\n### 2.3. 安装`SQLite3`时提示`ERROR: Failed to build gem native extension.`\n~~~bash\napt-get install sqlite-dev\n~~~\n\n\n","slug":"Linux下如何安装Ruby","published":1,"date":"2022-05-03T08:46:25.172Z","updated":"2022-05-03T08:46:25.172Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdtz000hr2ve6pn7cbnh","content":"<h1 id=\"Linux下如何安装Ruby\"><a href=\"#Linux下如何安装Ruby\" class=\"headerlink\" title=\"Linux下如何安装Ruby\"></a>Linux下如何安装Ruby</h1><h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><p>使用<code>Ruby</code>自然首先要安装（废话。</p>\n<p>通常我们会使用<code>RVM</code>来进行<code>Ruby</code>的版本管理：</p>\n<p><a href=\"%5Bhttp://rvm.io/%5D(http://rvm.io/)\">RVM官网</a></p>\n<h3 id=\"1-1-安装GPG-keys\"><a href=\"#1-1-安装GPG-keys\" class=\"headerlink\" title=\"1.1. 安装GPG keys\"></a>1.1. 安装GPG keys</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-安装RVM\"><a href=\"#1-2-安装RVM\" class=\"headerlink\" title=\"1.2. 安装RVM\"></a>1.2. 安装RVM</h3><p>使用如下命令安装<code>RVM</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\curl -sSL https://get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure>\n<p>如果希望默认安装<code>Ruby</code>和<code>Ruby on Rails</code>也可以直接使用如下命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\curl -sSL https://get.rvm.io | bash -s stable --rails</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-查看版本\"><a href=\"#1-3-查看版本\" class=\"headerlink\" title=\"1.3. 查看版本\"></a>1.3. 查看版本</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile.d/rvm.sh</span><br><span class=\"line\"></span><br><span class=\"line\">rvm -v</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-安装指定版本的Ruby\"><a href=\"#1-4-安装指定版本的Ruby\" class=\"headerlink\" title=\"1.4.  安装指定版本的Ruby\"></a>1.4.  安装指定版本的<code>Ruby</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.5.3</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-避雷\"><a href=\"#2-避雷\" class=\"headerlink\" title=\"2. 避雷\"></a>2. 避雷</h2><h3 id=\"2-1-安装Ruby时提示Error-running-39-requirements-debian-update-system-ruby-2-5-3-39\"><a href=\"#2-1-安装Ruby时提示Error-running-39-requirements-debian-update-system-ruby-2-5-3-39\" class=\"headerlink\" title=\"2.1. 安装Ruby时提示Error running &#39;requirements\\_debian\\_update\\_system ruby-2.5.3&#39;\"></a>2.1. 安装<code>Ruby</code>时提示<code>Error running &#39;requirements\\_debian\\_update\\_system ruby-2.5.3&#39;</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm autolibs 1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-安装Rails时提示ERROR-Failed-to-build-gem-native-extension\"><a href=\"#2-2-安装Rails时提示ERROR-Failed-to-build-gem-native-extension\" class=\"headerlink\" title=\"2.2. 安装Rails时提示ERROR: Failed to build gem native extension.\"></a>2.2. 安装<code>Rails</code>时提示<code>ERROR: Failed to build gem native extension.</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install ruby-dev</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-安装SQLite3时提示ERROR-Failed-to-build-gem-native-extension\"><a href=\"#2-3-安装SQLite3时提示ERROR-Failed-to-build-gem-native-extension\" class=\"headerlink\" title=\"2.3. 安装SQLite3时提示ERROR: Failed to build gem native extension.\"></a>2.3. 安装<code>SQLite3</code>时提示<code>ERROR: Failed to build gem native extension.</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install sqlite-dev</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"Linux下如何安装Ruby\"><a href=\"#Linux下如何安装Ruby\" class=\"headerlink\" title=\"Linux下如何安装Ruby\"></a>Linux下如何安装Ruby</h1><h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><p>使用<code>Ruby</code>自然首先要安装（废话。</p>\n<p>通常我们会使用<code>RVM</code>来进行<code>Ruby</code>的版本管理：</p>\n<p><a href=\"%5Bhttp://rvm.io/%5D(http://rvm.io/)\">RVM官网</a></p>\n<h3 id=\"1-1-安装GPG-keys\"><a href=\"#1-1-安装GPG-keys\" class=\"headerlink\" title=\"1.1. 安装GPG keys\"></a>1.1. 安装GPG keys</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-安装RVM\"><a href=\"#1-2-安装RVM\" class=\"headerlink\" title=\"1.2. 安装RVM\"></a>1.2. 安装RVM</h3><p>使用如下命令安装<code>RVM</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\curl -sSL https://get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure>\n<p>如果希望默认安装<code>Ruby</code>和<code>Ruby on Rails</code>也可以直接使用如下命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\curl -sSL https://get.rvm.io | bash -s stable --rails</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-查看版本\"><a href=\"#1-3-查看版本\" class=\"headerlink\" title=\"1.3. 查看版本\"></a>1.3. 查看版本</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> /etc/profile.d/rvm.sh</span><br><span class=\"line\"></span><br><span class=\"line\">rvm -v</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-安装指定版本的Ruby\"><a href=\"#1-4-安装指定版本的Ruby\" class=\"headerlink\" title=\"1.4.  安装指定版本的Ruby\"></a>1.4.  安装指定版本的<code>Ruby</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.5.3</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-避雷\"><a href=\"#2-避雷\" class=\"headerlink\" title=\"2. 避雷\"></a>2. 避雷</h2><h3 id=\"2-1-安装Ruby时提示Error-running-39-requirements-debian-update-system-ruby-2-5-3-39\"><a href=\"#2-1-安装Ruby时提示Error-running-39-requirements-debian-update-system-ruby-2-5-3-39\" class=\"headerlink\" title=\"2.1. 安装Ruby时提示Error running &#39;requirements\\_debian\\_update\\_system ruby-2.5.3&#39;\"></a>2.1. 安装<code>Ruby</code>时提示<code>Error running &#39;requirements\\_debian\\_update\\_system ruby-2.5.3&#39;</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm autolibs 1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-安装Rails时提示ERROR-Failed-to-build-gem-native-extension\"><a href=\"#2-2-安装Rails时提示ERROR-Failed-to-build-gem-native-extension\" class=\"headerlink\" title=\"2.2. 安装Rails时提示ERROR: Failed to build gem native extension.\"></a>2.2. 安装<code>Rails</code>时提示<code>ERROR: Failed to build gem native extension.</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install ruby-dev</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-安装SQLite3时提示ERROR-Failed-to-build-gem-native-extension\"><a href=\"#2-3-安装SQLite3时提示ERROR-Failed-to-build-gem-native-extension\" class=\"headerlink\" title=\"2.3. 安装SQLite3时提示ERROR: Failed to build gem native extension.\"></a>2.3. 安装<code>SQLite3</code>时提示<code>ERROR: Failed to build gem native extension.</code></h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install sqlite-dev</span><br></pre></td></tr></table></figure>\n\n\n"},{"_content":"# Linux下安装NodeJs\n\n不得不说`Linux`下坑确实多，使用`apt-get`安装的`NodeJS`是4.2.6版本的，而使用`nvm`又老是遇到问题\n\n~~~bash\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash\n~~~\n或者\n~~~bash\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash\n~~~\n如果执行后使用`nvm -v`提示的是`nvm:common is not found`，则运行如下内容即可\n~~~bash\nsource ~/.nvm/nvm.sh\nsource ~/.profile\nsource ~/.bashrc\n~~~\n如果正常输出版本号则可以直接安装\n~~~bash\nnvm install 10.15.3\n~~~\n","source":"_posts/Linux下安装nodeJs.md","raw":"# Linux下安装NodeJs\n\n不得不说`Linux`下坑确实多，使用`apt-get`安装的`NodeJS`是4.2.6版本的，而使用`nvm`又老是遇到问题\n\n~~~bash\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash\n~~~\n或者\n~~~bash\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash\n~~~\n如果执行后使用`nvm -v`提示的是`nvm:common is not found`，则运行如下内容即可\n~~~bash\nsource ~/.nvm/nvm.sh\nsource ~/.profile\nsource ~/.bashrc\n~~~\n如果正常输出版本号则可以直接安装\n~~~bash\nnvm install 10.15.3\n~~~\n","slug":"Linux下安装nodeJs","published":1,"date":"2022-05-03T08:46:25.182Z","updated":"2022-05-03T08:46:25.182Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdu0000nr2veaic6biq6","content":"<h1 id=\"Linux下安装NodeJs\"><a href=\"#Linux下安装NodeJs\" class=\"headerlink\" title=\"Linux下安装NodeJs\"></a>Linux下安装NodeJs</h1><p>不得不说<code>Linux</code>下坑确实多，使用<code>apt-get</code>安装的<code>NodeJS</code>是4.2.6版本的，而使用<code>nvm</code>又老是遇到问题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</span><br></pre></td></tr></table></figure>\n<p>如果执行后使用<code>nvm -v</code>提示的是<code>nvm:common is not found</code>，则运行如下内容即可</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.nvm/nvm.sh</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.profile</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>如果正常输出版本号则可以直接安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm install 10.15.3</span><br></pre></td></tr></table></figure>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"Linux下安装NodeJs\"><a href=\"#Linux下安装NodeJs\" class=\"headerlink\" title=\"Linux下安装NodeJs\"></a>Linux下安装NodeJs</h1><p>不得不说<code>Linux</code>下坑确实多，使用<code>apt-get</code>安装的<code>NodeJS</code>是4.2.6版本的，而使用<code>nvm</code>又老是遇到问题</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</span><br></pre></td></tr></table></figure>\n<p>如果执行后使用<code>nvm -v</code>提示的是<code>nvm:common is not found</code>，则运行如下内容即可</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">source</span> ~/.nvm/nvm.sh</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.profile</span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>\n<p>如果正常输出版本号则可以直接安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvm install 10.15.3</span><br></pre></td></tr></table></figure>\n"},{"_content":"# Linux服务器无法使用mstsc工具链接的解决方案\n\n最近更换了阿里云的云服务器系统为`ubuntu`后发现使用`windows`自带的`mstsc`工具无法连接，需要使用阿里云的救援连接安装并启动`xrdp`：\n~~~shell\nsudo apt-get update\n\nsudo apt-get install xrdp\n\nservice xrdp start\n\nchkconfig xrdp on\n~~~\n","source":"_posts/Linux实例服务器无法使用mstsc连接.md","raw":"# Linux服务器无法使用mstsc工具链接的解决方案\n\n最近更换了阿里云的云服务器系统为`ubuntu`后发现使用`windows`自带的`mstsc`工具无法连接，需要使用阿里云的救援连接安装并启动`xrdp`：\n~~~shell\nsudo apt-get update\n\nsudo apt-get install xrdp\n\nservice xrdp start\n\nchkconfig xrdp on\n~~~\n","slug":"Linux实例服务器无法使用mstsc连接","published":1,"date":"2022-05-03T08:46:25.182Z","updated":"2022-05-03T08:46:25.182Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdu1000rr2ve6tf6c0v6","content":"<h1 id=\"Linux服务器无法使用mstsc工具链接的解决方案\"><a href=\"#Linux服务器无法使用mstsc工具链接的解决方案\" class=\"headerlink\" title=\"Linux服务器无法使用mstsc工具链接的解决方案\"></a>Linux服务器无法使用mstsc工具链接的解决方案</h1><p>最近更换了阿里云的云服务器系统为<code>ubuntu</code>后发现使用<code>windows</code>自带的<code>mstsc</code>工具无法连接，需要使用阿里云的救援连接安装并启动<code>xrdp</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install xrdp</span><br><span class=\"line\"></span><br><span class=\"line\">service xrdp start</span><br><span class=\"line\"></span><br><span class=\"line\">chkconfig xrdp on</span><br></pre></td></tr></table></figure>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"Linux服务器无法使用mstsc工具链接的解决方案\"><a href=\"#Linux服务器无法使用mstsc工具链接的解决方案\" class=\"headerlink\" title=\"Linux服务器无法使用mstsc工具链接的解决方案\"></a>Linux服务器无法使用mstsc工具链接的解决方案</h1><p>最近更换了阿里云的云服务器系统为<code>ubuntu</code>后发现使用<code>windows</code>自带的<code>mstsc</code>工具无法连接，需要使用阿里云的救援连接安装并启动<code>xrdp</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\">sudo apt-get install xrdp</span><br><span class=\"line\"></span><br><span class=\"line\">service xrdp start</span><br><span class=\"line\"></span><br><span class=\"line\">chkconfig xrdp on</span><br></pre></td></tr></table></figure>\n"},{"_content":"# MongoDB配置\n\n## 1. 安装一路向下\n## 2. 完了之后先在安装盘根目录创建一个`/data/db`文件夹\n## 3. 在安装目录的`bin`目录下执行\n~~~\nmongod --dbpath D:\\software\\MongoDB\\data\\db\n~~~\n## 4. 去安装目录下启动`mongod.exe`\n![启动成功](https://upload-images.jianshu.io/upload_images/13085799-72ea5889003fddb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 5.配置`MongoDB Service`\n先在`/data/db`文件夹下新建一个`log`文件夹\n\n安装根目录下创建`mongo.config`文件\n\n~~~\ndbpath=/data/db文件夹目录\n\nlogpath=log文件夹目录\\mongo.log\n~~~\n\n在安装目录的`bin`目录下执行管理员CMD\n\n~~~\nmongod --config \"mongo.config目录\" --install --serviceName \"MongoDB\"\n~~~\n\n![完成](https://upload-images.jianshu.io/upload_images/13085799-5733c1d55a46d741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/MongoDB配置.md","raw":"# MongoDB配置\n\n## 1. 安装一路向下\n## 2. 完了之后先在安装盘根目录创建一个`/data/db`文件夹\n## 3. 在安装目录的`bin`目录下执行\n~~~\nmongod --dbpath D:\\software\\MongoDB\\data\\db\n~~~\n## 4. 去安装目录下启动`mongod.exe`\n![启动成功](https://upload-images.jianshu.io/upload_images/13085799-72ea5889003fddb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 5.配置`MongoDB Service`\n先在`/data/db`文件夹下新建一个`log`文件夹\n\n安装根目录下创建`mongo.config`文件\n\n~~~\ndbpath=/data/db文件夹目录\n\nlogpath=log文件夹目录\\mongo.log\n~~~\n\n在安装目录的`bin`目录下执行管理员CMD\n\n~~~\nmongod --config \"mongo.config目录\" --install --serviceName \"MongoDB\"\n~~~\n\n![完成](https://upload-images.jianshu.io/upload_images/13085799-5733c1d55a46d741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"MongoDB配置","published":1,"date":"2022-05-03T08:46:25.142Z","updated":"2022-05-03T08:46:25.142Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdu3000vr2vegkmb9a31","content":"<h1 id=\"MongoDB配置\"><a href=\"#MongoDB配置\" class=\"headerlink\" title=\"MongoDB配置\"></a>MongoDB配置</h1><h2 id=\"1-安装一路向下\"><a href=\"#1-安装一路向下\" class=\"headerlink\" title=\"1. 安装一路向下\"></a>1. 安装一路向下</h2><h2 id=\"2-完了之后先在安装盘根目录创建一个-data-db文件夹\"><a href=\"#2-完了之后先在安装盘根目录创建一个-data-db文件夹\" class=\"headerlink\" title=\"2. 完了之后先在安装盘根目录创建一个/data/db文件夹\"></a>2. 完了之后先在安装盘根目录创建一个<code>/data/db</code>文件夹</h2><h2 id=\"3-在安装目录的bin目录下执行\"><a href=\"#3-在安装目录的bin目录下执行\" class=\"headerlink\" title=\"3. 在安装目录的bin目录下执行\"></a>3. 在安装目录的<code>bin</code>目录下执行</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod --dbpath D:\\software\\MongoDB\\data\\db</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-去安装目录下启动mongod-exe\"><a href=\"#4-去安装目录下启动mongod-exe\" class=\"headerlink\" title=\"4. 去安装目录下启动mongod.exe\"></a>4. 去安装目录下启动<code>mongod.exe</code></h2><p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-72ea5889003fddb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"启动成功\"></p>\n<h2 id=\"5-配置MongoDB-Service\"><a href=\"#5-配置MongoDB-Service\" class=\"headerlink\" title=\"5.配置MongoDB Service\"></a>5.配置<code>MongoDB Service</code></h2><p>先在<code>/data/db</code>文件夹下新建一个<code>log</code>文件夹</p>\n<p>安装根目录下创建<code>mongo.config</code>文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dbpath=/data/db文件夹目录</span><br><span class=\"line\"></span><br><span class=\"line\">logpath=log文件夹目录\\mongo.log</span><br></pre></td></tr></table></figure>\n\n<p>在安装目录的<code>bin</code>目录下执行管理员CMD</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod --config &quot;mongo.config目录&quot; --install --serviceName &quot;MongoDB&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-5733c1d55a46d741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"完成\"></p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"MongoDB配置\"><a href=\"#MongoDB配置\" class=\"headerlink\" title=\"MongoDB配置\"></a>MongoDB配置</h1><h2 id=\"1-安装一路向下\"><a href=\"#1-安装一路向下\" class=\"headerlink\" title=\"1. 安装一路向下\"></a>1. 安装一路向下</h2><h2 id=\"2-完了之后先在安装盘根目录创建一个-data-db文件夹\"><a href=\"#2-完了之后先在安装盘根目录创建一个-data-db文件夹\" class=\"headerlink\" title=\"2. 完了之后先在安装盘根目录创建一个/data/db文件夹\"></a>2. 完了之后先在安装盘根目录创建一个<code>/data/db</code>文件夹</h2><h2 id=\"3-在安装目录的bin目录下执行\"><a href=\"#3-在安装目录的bin目录下执行\" class=\"headerlink\" title=\"3. 在安装目录的bin目录下执行\"></a>3. 在安装目录的<code>bin</code>目录下执行</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod --dbpath D:\\software\\MongoDB\\data\\db</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-去安装目录下启动mongod-exe\"><a href=\"#4-去安装目录下启动mongod-exe\" class=\"headerlink\" title=\"4. 去安装目录下启动mongod.exe\"></a>4. 去安装目录下启动<code>mongod.exe</code></h2><p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-72ea5889003fddb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"启动成功\"></p>\n<h2 id=\"5-配置MongoDB-Service\"><a href=\"#5-配置MongoDB-Service\" class=\"headerlink\" title=\"5.配置MongoDB Service\"></a>5.配置<code>MongoDB Service</code></h2><p>先在<code>/data/db</code>文件夹下新建一个<code>log</code>文件夹</p>\n<p>安装根目录下创建<code>mongo.config</code>文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dbpath=/data/db文件夹目录</span><br><span class=\"line\"></span><br><span class=\"line\">logpath=log文件夹目录\\mongo.log</span><br></pre></td></tr></table></figure>\n\n<p>在安装目录的<code>bin</code>目录下执行管理员CMD</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongod --config &quot;mongo.config目录&quot; --install --serviceName &quot;MongoDB&quot;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-5733c1d55a46d741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"完成\"></p>\n"},{"_content":"# 使用Nginx配置简单的反向代理\n\n先讲一下场景，手里有两个域名，一台云服务器，一堆垃圾项目。\n\n现在想要的是，访问域名A，能够访问的是3000端口下的应用A；访问域名B，访问的是3001端口下的应用B；\n\n## 1. 安装nginx\n参考一下百度就好，不赘述了。\n\n## 2. 写配置文件\n配置文件在`nginx/nginx.conf`下完成，部分使用`nginx`官方文档安装的同学可能会进不去目录。\n\n在`nginx.conf`文件中配置以下内容\n~~~nginx\nserver {\n  listen  80;\n  server_name domin001.com;\n\n  location / {\n    proxy_pass http://127.0.0.1:3000;\n  }\n}\n\nserver {\n  listen  80;\n  server_name domin002.com;\n\n  location / {\n    proxy_pass http://127.0.0.1:3001;\n  }\n}\n~~~\n上面的配置描述了当用户输入`domin001.com`进入网站是，实际由`http://127.0.0.1:3000`代理。同样是对于`domin002.com`，也是使用了对应的`http://127.0.0.1:3001`进行代理。\n\ntip:需要注意的是，对于部分`javascript`,`ruby`等玩家来说，分号可能并不是必要的内容，但很不幸`nginx `的配置文件是有分号需求的。\n\n\n## 3. 更新\n今天早上测试了一下发现了一些问题，将配置修改为如下\n~~~nginx\nserver {\n  listen  80;\n  server_name domin001.com;\n\n  location / {\n    proxy_pass http://127.0.0.1:3000;\n  }\n}\n\nserver {\n  listen  80;\n  server_name domin002.com;\n\n  location / {\n    proxy_pass http://127.0.0.1:3001;\n  }\n}\n~~~\n\n与上面的区别在于以下\n- 1.添加了带www与不带www的代理\n- 2.对于`server_name`有个很奇怪的地方是，不带`www`的域名一定要写在前面，目前不太明白原理\n- 3.空格符分隔\n","source":"_posts/Nginx配置简单的反向代理.md","raw":"# 使用Nginx配置简单的反向代理\n\n先讲一下场景，手里有两个域名，一台云服务器，一堆垃圾项目。\n\n现在想要的是，访问域名A，能够访问的是3000端口下的应用A；访问域名B，访问的是3001端口下的应用B；\n\n## 1. 安装nginx\n参考一下百度就好，不赘述了。\n\n## 2. 写配置文件\n配置文件在`nginx/nginx.conf`下完成，部分使用`nginx`官方文档安装的同学可能会进不去目录。\n\n在`nginx.conf`文件中配置以下内容\n~~~nginx\nserver {\n  listen  80;\n  server_name domin001.com;\n\n  location / {\n    proxy_pass http://127.0.0.1:3000;\n  }\n}\n\nserver {\n  listen  80;\n  server_name domin002.com;\n\n  location / {\n    proxy_pass http://127.0.0.1:3001;\n  }\n}\n~~~\n上面的配置描述了当用户输入`domin001.com`进入网站是，实际由`http://127.0.0.1:3000`代理。同样是对于`domin002.com`，也是使用了对应的`http://127.0.0.1:3001`进行代理。\n\ntip:需要注意的是，对于部分`javascript`,`ruby`等玩家来说，分号可能并不是必要的内容，但很不幸`nginx `的配置文件是有分号需求的。\n\n\n## 3. 更新\n今天早上测试了一下发现了一些问题，将配置修改为如下\n~~~nginx\nserver {\n  listen  80;\n  server_name domin001.com;\n\n  location / {\n    proxy_pass http://127.0.0.1:3000;\n  }\n}\n\nserver {\n  listen  80;\n  server_name domin002.com;\n\n  location / {\n    proxy_pass http://127.0.0.1:3001;\n  }\n}\n~~~\n\n与上面的区别在于以下\n- 1.添加了带www与不带www的代理\n- 2.对于`server_name`有个很奇怪的地方是，不带`www`的域名一定要写在前面，目前不太明白原理\n- 3.空格符分隔\n","slug":"Nginx配置简单的反向代理","published":1,"date":"2022-05-03T08:46:25.142Z","updated":"2022-05-03T08:46:25.142Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdu3000yr2ve0zxr1xod","content":"<h1 id=\"使用Nginx配置简单的反向代理\"><a href=\"#使用Nginx配置简单的反向代理\" class=\"headerlink\" title=\"使用Nginx配置简单的反向代理\"></a>使用Nginx配置简单的反向代理</h1><p>先讲一下场景，手里有两个域名，一台云服务器，一堆垃圾项目。</p>\n<p>现在想要的是，访问域名A，能够访问的是3000端口下的应用A；访问域名B，访问的是3001端口下的应用B；</p>\n<h2 id=\"1-安装nginx\"><a href=\"#1-安装nginx\" class=\"headerlink\" title=\"1. 安装nginx\"></a>1. 安装nginx</h2><p>参考一下百度就好，不赘述了。</p>\n<h2 id=\"2-写配置文件\"><a href=\"#2-写配置文件\" class=\"headerlink\" title=\"2. 写配置文件\"></a>2. 写配置文件</h2><p>配置文件在<code>nginx/nginx.conf</code>下完成，部分使用<code>nginx</code>官方文档安装的同学可能会进不去目录。</p>\n<p>在<code>nginx.conf</code>文件中配置以下内容</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span>  <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> domin001.com;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://127.0.0.1:3000;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span>  <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> domin002.com;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://127.0.0.1:3001;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的配置描述了当用户输入<code>domin001.com</code>进入网站是，实际由<code>http://127.0.0.1:3000</code>代理。同样是对于<code>domin002.com</code>，也是使用了对应的<code>http://127.0.0.1:3001</code>进行代理。</p>\n<p>tip:需要注意的是，对于部分<code>javascript</code>,<code>ruby</code>等玩家来说，分号可能并不是必要的内容，但很不幸<code>nginx </code>的配置文件是有分号需求的。</p>\n<h2 id=\"3-更新\"><a href=\"#3-更新\" class=\"headerlink\" title=\"3. 更新\"></a>3. 更新</h2><p>今天早上测试了一下发现了一些问题，将配置修改为如下</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span>  <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> domin001.com;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://127.0.0.1:3000;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span>  <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> domin002.com;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://127.0.0.1:3001;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与上面的区别在于以下</p>\n<ul>\n<li>1.添加了带www与不带www的代理</li>\n<li>2.对于<code>server_name</code>有个很奇怪的地方是，不带<code>www</code>的域名一定要写在前面，目前不太明白原理</li>\n<li>3.空格符分隔</li>\n</ul>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"使用Nginx配置简单的反向代理\"><a href=\"#使用Nginx配置简单的反向代理\" class=\"headerlink\" title=\"使用Nginx配置简单的反向代理\"></a>使用Nginx配置简单的反向代理</h1><p>先讲一下场景，手里有两个域名，一台云服务器，一堆垃圾项目。</p>\n<p>现在想要的是，访问域名A，能够访问的是3000端口下的应用A；访问域名B，访问的是3001端口下的应用B；</p>\n<h2 id=\"1-安装nginx\"><a href=\"#1-安装nginx\" class=\"headerlink\" title=\"1. 安装nginx\"></a>1. 安装nginx</h2><p>参考一下百度就好，不赘述了。</p>\n<h2 id=\"2-写配置文件\"><a href=\"#2-写配置文件\" class=\"headerlink\" title=\"2. 写配置文件\"></a>2. 写配置文件</h2><p>配置文件在<code>nginx/nginx.conf</code>下完成，部分使用<code>nginx</code>官方文档安装的同学可能会进不去目录。</p>\n<p>在<code>nginx.conf</code>文件中配置以下内容</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span>  <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> domin001.com;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://127.0.0.1:3000;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span>  <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> domin002.com;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://127.0.0.1:3001;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的配置描述了当用户输入<code>domin001.com</code>进入网站是，实际由<code>http://127.0.0.1:3000</code>代理。同样是对于<code>domin002.com</code>，也是使用了对应的<code>http://127.0.0.1:3001</code>进行代理。</p>\n<p>tip:需要注意的是，对于部分<code>javascript</code>,<code>ruby</code>等玩家来说，分号可能并不是必要的内容，但很不幸<code>nginx </code>的配置文件是有分号需求的。</p>\n<h2 id=\"3-更新\"><a href=\"#3-更新\" class=\"headerlink\" title=\"3. 更新\"></a>3. 更新</h2><p>今天早上测试了一下发现了一些问题，将配置修改为如下</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span>  <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> domin001.com;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://127.0.0.1:3000;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span>  <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> domin002.com;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">proxy_pass</span> http://127.0.0.1:3001;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与上面的区别在于以下</p>\n<ul>\n<li>1.添加了带www与不带www的代理</li>\n<li>2.对于<code>server_name</code>有个很奇怪的地方是，不带<code>www</code>的域名一定要写在前面，目前不太明白原理</li>\n<li>3.空格符分隔</li>\n</ul>\n"},{"_content":"# PringStackTrace方法的一点碎碎念\n\n今天一直在写界面，晚一点的时候想随便写个点后端然后扔服务器上看看效果，然后运行发现一直在报NullPointerException空指针异常，找到try-catch的地方看了半天也是一脸懵逼，然后想起了之前学过的一个方法，可以将异常信息打印到控制台，错记成了getStackTrace()方法，然后并没有打印出来对应的信息，于是乎做了很久无用功一直没有找到问题的关键所在，后来删掉重新写的时候用智能提示生成异常处理段落时，发现生成的是一个PrintStackTrace()方法，运行后发现在服务器抛出了ClassNotFoundException，才发现原来晚一点写代码的时候思路已经不清晰了，没有导入对应的jar包。\n\n犯的都是小错误但是却花了很多时间，看来以后真的是要多记笔记才行，光靠自己的记忆力总是不能很快的想起来需要的东西= =。\n\n果真好记性不如烂笔头一点都没有说出。。。\n\n","source":"_posts/PringStackTrace方法的一点碎碎念.md","raw":"# PringStackTrace方法的一点碎碎念\n\n今天一直在写界面，晚一点的时候想随便写个点后端然后扔服务器上看看效果，然后运行发现一直在报NullPointerException空指针异常，找到try-catch的地方看了半天也是一脸懵逼，然后想起了之前学过的一个方法，可以将异常信息打印到控制台，错记成了getStackTrace()方法，然后并没有打印出来对应的信息，于是乎做了很久无用功一直没有找到问题的关键所在，后来删掉重新写的时候用智能提示生成异常处理段落时，发现生成的是一个PrintStackTrace()方法，运行后发现在服务器抛出了ClassNotFoundException，才发现原来晚一点写代码的时候思路已经不清晰了，没有导入对应的jar包。\n\n犯的都是小错误但是却花了很多时间，看来以后真的是要多记笔记才行，光靠自己的记忆力总是不能很快的想起来需要的东西= =。\n\n果真好记性不如烂笔头一点都没有说出。。。\n\n","slug":"PringStackTrace方法的一点碎碎念","published":1,"date":"2022-05-03T08:46:25.182Z","updated":"2022-05-03T08:46:25.182Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdu50011r2ve6f9aa3xu","content":"<h1 id=\"PringStackTrace方法的一点碎碎念\"><a href=\"#PringStackTrace方法的一点碎碎念\" class=\"headerlink\" title=\"PringStackTrace方法的一点碎碎念\"></a>PringStackTrace方法的一点碎碎念</h1><p>今天一直在写界面，晚一点的时候想随便写个点后端然后扔服务器上看看效果，然后运行发现一直在报NullPointerException空指针异常，找到try-catch的地方看了半天也是一脸懵逼，然后想起了之前学过的一个方法，可以将异常信息打印到控制台，错记成了getStackTrace()方法，然后并没有打印出来对应的信息，于是乎做了很久无用功一直没有找到问题的关键所在，后来删掉重新写的时候用智能提示生成异常处理段落时，发现生成的是一个PrintStackTrace()方法，运行后发现在服务器抛出了ClassNotFoundException，才发现原来晚一点写代码的时候思路已经不清晰了，没有导入对应的jar包。</p>\n<p>犯的都是小错误但是却花了很多时间，看来以后真的是要多记笔记才行，光靠自己的记忆力总是不能很快的想起来需要的东西&#x3D; &#x3D;。</p>\n<p>果真好记性不如烂笔头一点都没有说出。。。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"PringStackTrace方法的一点碎碎念\"><a href=\"#PringStackTrace方法的一点碎碎念\" class=\"headerlink\" title=\"PringStackTrace方法的一点碎碎念\"></a>PringStackTrace方法的一点碎碎念</h1><p>今天一直在写界面，晚一点的时候想随便写个点后端然后扔服务器上看看效果，然后运行发现一直在报NullPointerException空指针异常，找到try-catch的地方看了半天也是一脸懵逼，然后想起了之前学过的一个方法，可以将异常信息打印到控制台，错记成了getStackTrace()方法，然后并没有打印出来对应的信息，于是乎做了很久无用功一直没有找到问题的关键所在，后来删掉重新写的时候用智能提示生成异常处理段落时，发现生成的是一个PrintStackTrace()方法，运行后发现在服务器抛出了ClassNotFoundException，才发现原来晚一点写代码的时候思路已经不清晰了，没有导入对应的jar包。</p>\n<p>犯的都是小错误但是却花了很多时间，看来以后真的是要多记笔记才行，光靠自己的记忆力总是不能很快的想起来需要的东西&#x3D; &#x3D;。</p>\n<p>果真好记性不如烂笔头一点都没有说出。。。</p>\n"},{"_content":"# Rails Migrate关于MySQL Lock的一点问题\n\n**问题描述**\n\n本周将数据由`PSQL`迁移到了`MySQL`，在迁移顺利进行之后，于周三进行了一个小规模的`BUG`修复，为修复数据表中的错误，增加了4个`migration`文件，运行如下指令:\n~~~ shell\nRAILS_ENV=production rails db:migrate\n~~~\n\n得到如下报错:\n~~~ log\nActiveRecord::ConcurrentMigrationError:\nFailed to release advisory lock\n~~~\n\n**解决方案**\n\n`Rails 6` 文档中提到了如下内容\n> Advisory Locks are enabled by default on MySQL and are used to make database migrations concurrent safe. You can disable advisory locks by setting advisory_locks to false:\n> [Configuring Rails Applications](https://edgeguides.rubyonrails.org/configuring.html#configuring-a-mysql-or-mariadb-database)\n\n该特性在`Rails 6`开始支持，对于不太方便升级`Rails`的朋友，实际上上述的异常并不会影响迁移的执行（如果影响到我想应该不是该问题导致的），一个我并不太推荐的方法是使用`Rails 6`的工程来跑特定的迁移。\n","source":"_posts/Rails-Migrate关于MySQL-lock的一点问题.md","raw":"# Rails Migrate关于MySQL Lock的一点问题\n\n**问题描述**\n\n本周将数据由`PSQL`迁移到了`MySQL`，在迁移顺利进行之后，于周三进行了一个小规模的`BUG`修复，为修复数据表中的错误，增加了4个`migration`文件，运行如下指令:\n~~~ shell\nRAILS_ENV=production rails db:migrate\n~~~\n\n得到如下报错:\n~~~ log\nActiveRecord::ConcurrentMigrationError:\nFailed to release advisory lock\n~~~\n\n**解决方案**\n\n`Rails 6` 文档中提到了如下内容\n> Advisory Locks are enabled by default on MySQL and are used to make database migrations concurrent safe. You can disable advisory locks by setting advisory_locks to false:\n> [Configuring Rails Applications](https://edgeguides.rubyonrails.org/configuring.html#configuring-a-mysql-or-mariadb-database)\n\n该特性在`Rails 6`开始支持，对于不太方便升级`Rails`的朋友，实际上上述的异常并不会影响迁移的执行（如果影响到我想应该不是该问题导致的），一个我并不太推荐的方法是使用`Rails 6`的工程来跑特定的迁移。\n","slug":"Rails-Migrate关于MySQL-lock的一点问题","published":1,"date":"2022-05-03T08:46:25.152Z","updated":"2022-05-03T08:46:25.152Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdu50014r2ve74wf3gmt","content":"<h1 id=\"Rails-Migrate关于MySQL-Lock的一点问题\"><a href=\"#Rails-Migrate关于MySQL-Lock的一点问题\" class=\"headerlink\" title=\"Rails Migrate关于MySQL Lock的一点问题\"></a>Rails Migrate关于MySQL Lock的一点问题</h1><p><strong>问题描述</strong></p>\n<p>本周将数据由<code>PSQL</code>迁移到了<code>MySQL</code>，在迁移顺利进行之后，于周三进行了一个小规模的<code>BUG</code>修复，为修复数据表中的错误，增加了4个<code>migration</code>文件，运行如下指令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAILS_ENV=production rails db:migrate</span><br></pre></td></tr></table></figure>\n\n<p>得到如下报错:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActiveRecord::ConcurrentMigrationError:</span><br><span class=\"line\">Failed to release advisory lock</span><br></pre></td></tr></table></figure>\n\n<p><strong>解决方案</strong></p>\n<p><code>Rails 6</code> 文档中提到了如下内容</p>\n<blockquote>\n<p>Advisory Locks are enabled by default on MySQL and are used to make database migrations concurrent safe. You can disable advisory locks by setting advisory_locks to false:<br><a href=\"https://edgeguides.rubyonrails.org/configuring.html#configuring-a-mysql-or-mariadb-database\">Configuring Rails Applications</a></p>\n</blockquote>\n<p>该特性在<code>Rails 6</code>开始支持，对于不太方便升级<code>Rails</code>的朋友，实际上上述的异常并不会影响迁移的执行（如果影响到我想应该不是该问题导致的），一个我并不太推荐的方法是使用<code>Rails 6</code>的工程来跑特定的迁移。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"Rails-Migrate关于MySQL-Lock的一点问题\"><a href=\"#Rails-Migrate关于MySQL-Lock的一点问题\" class=\"headerlink\" title=\"Rails Migrate关于MySQL Lock的一点问题\"></a>Rails Migrate关于MySQL Lock的一点问题</h1><p><strong>问题描述</strong></p>\n<p>本周将数据由<code>PSQL</code>迁移到了<code>MySQL</code>，在迁移顺利进行之后，于周三进行了一个小规模的<code>BUG</code>修复，为修复数据表中的错误，增加了4个<code>migration</code>文件，运行如下指令:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RAILS_ENV=production rails db:migrate</span><br></pre></td></tr></table></figure>\n\n<p>得到如下报错:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActiveRecord::ConcurrentMigrationError:</span><br><span class=\"line\">Failed to release advisory lock</span><br></pre></td></tr></table></figure>\n\n<p><strong>解决方案</strong></p>\n<p><code>Rails 6</code> 文档中提到了如下内容</p>\n<blockquote>\n<p>Advisory Locks are enabled by default on MySQL and are used to make database migrations concurrent safe. You can disable advisory locks by setting advisory_locks to false:<br><a href=\"https://edgeguides.rubyonrails.org/configuring.html#configuring-a-mysql-or-mariadb-database\">Configuring Rails Applications</a></p>\n</blockquote>\n<p>该特性在<code>Rails 6</code>开始支持，对于不太方便升级<code>Rails</code>的朋友，实际上上述的异常并不会影响迁移的执行（如果影响到我想应该不是该问题导致的），一个我并不太推荐的方法是使用<code>Rails 6</code>的工程来跑特定的迁移。</p>\n"},{"_content":"# Rails test等命令卡死常用的解决方案\n\n**问题描述**\n\n之前配合测试的实习生跑`TeamCity`时发现写好的`rails test`经常构建超时，上了测试服务器试了一下发现运行`rails test`会卡死，同时包含`rails c/rails g`等命令一样会卡死。\n\n**解决方案**\n\n通常情况下都和`spring`有关，该插件用于在`development`环境下加速，在除`development`外的环境里是不应该安装的，使用如下命令可以将其关闭。\n~~~ shell\nspring stop\n~~~\n\n同时也应该规范`bundle`操作行为，对于`spring/web-console/listen`等这一类开发环境才使用的`gem`应该置于`Gemfile`中的`development`组，然后在生产环境使用如下命令排除`development group`的依赖：\n~~~ shell\nbundle install --without development\n~~~\n","source":"_posts/Rails-test等命令卡死常用的解决方案.md","raw":"# Rails test等命令卡死常用的解决方案\n\n**问题描述**\n\n之前配合测试的实习生跑`TeamCity`时发现写好的`rails test`经常构建超时，上了测试服务器试了一下发现运行`rails test`会卡死，同时包含`rails c/rails g`等命令一样会卡死。\n\n**解决方案**\n\n通常情况下都和`spring`有关，该插件用于在`development`环境下加速，在除`development`外的环境里是不应该安装的，使用如下命令可以将其关闭。\n~~~ shell\nspring stop\n~~~\n\n同时也应该规范`bundle`操作行为，对于`spring/web-console/listen`等这一类开发环境才使用的`gem`应该置于`Gemfile`中的`development`组，然后在生产环境使用如下命令排除`development group`的依赖：\n~~~ shell\nbundle install --without development\n~~~\n","slug":"Rails-test等命令卡死常用的解决方案","published":1,"date":"2022-05-03T08:46:25.152Z","updated":"2022-05-03T08:46:25.152Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdu60017r2ve8y86ehxs","content":"<h1 id=\"Rails-test等命令卡死常用的解决方案\"><a href=\"#Rails-test等命令卡死常用的解决方案\" class=\"headerlink\" title=\"Rails test等命令卡死常用的解决方案\"></a>Rails test等命令卡死常用的解决方案</h1><p><strong>问题描述</strong></p>\n<p>之前配合测试的实习生跑<code>TeamCity</code>时发现写好的<code>rails test</code>经常构建超时，上了测试服务器试了一下发现运行<code>rails test</code>会卡死，同时包含<code>rails c/rails g</code>等命令一样会卡死。</p>\n<p><strong>解决方案</strong></p>\n<p>通常情况下都和<code>spring</code>有关，该插件用于在<code>development</code>环境下加速，在除<code>development</code>外的环境里是不应该安装的，使用如下命令可以将其关闭。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring stop</span><br></pre></td></tr></table></figure>\n\n<p>同时也应该规范<code>bundle</code>操作行为，对于<code>spring/web-console/listen</code>等这一类开发环境才使用的<code>gem</code>应该置于<code>Gemfile</code>中的<code>development</code>组，然后在生产环境使用如下命令排除<code>development group</code>的依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bundle install --without development</span><br></pre></td></tr></table></figure>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"Rails-test等命令卡死常用的解决方案\"><a href=\"#Rails-test等命令卡死常用的解决方案\" class=\"headerlink\" title=\"Rails test等命令卡死常用的解决方案\"></a>Rails test等命令卡死常用的解决方案</h1><p><strong>问题描述</strong></p>\n<p>之前配合测试的实习生跑<code>TeamCity</code>时发现写好的<code>rails test</code>经常构建超时，上了测试服务器试了一下发现运行<code>rails test</code>会卡死，同时包含<code>rails c/rails g</code>等命令一样会卡死。</p>\n<p><strong>解决方案</strong></p>\n<p>通常情况下都和<code>spring</code>有关，该插件用于在<code>development</code>环境下加速，在除<code>development</code>外的环境里是不应该安装的，使用如下命令可以将其关闭。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring stop</span><br></pre></td></tr></table></figure>\n\n<p>同时也应该规范<code>bundle</code>操作行为，对于<code>spring/web-console/listen</code>等这一类开发环境才使用的<code>gem</code>应该置于<code>Gemfile</code>中的<code>development</code>组，然后在生产环境使用如下命令排除<code>development group</code>的依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bundle install --without development</span><br></pre></td></tr></table></figure>\n"},{"_content":"# Rails使用puma带证书启动\n\n**问题描述**\n\n不常见的场景，偶尔间因为没有`Nginx`服务器可以用，但又需要测试`HTTPS`，因此使用这种方式来带证书启动。\n\n**解决方案**\n\n~~~ shell\nrails s puma -p 3000 -b 'ssl://0.0.0.0:3000?key=config/your_key_file.key&cert=config/your_certificate_file.crt'\n~~~","source":"_posts/Rails使用puma带证书启动.md","raw":"# Rails使用puma带证书启动\n\n**问题描述**\n\n不常见的场景，偶尔间因为没有`Nginx`服务器可以用，但又需要测试`HTTPS`，因此使用这种方式来带证书启动。\n\n**解决方案**\n\n~~~ shell\nrails s puma -p 3000 -b 'ssl://0.0.0.0:3000?key=config/your_key_file.key&cert=config/your_certificate_file.crt'\n~~~","slug":"Rails使用puma带证书启动","published":1,"date":"2022-05-03T08:46:25.152Z","updated":"2022-05-03T08:46:25.152Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdu70018r2ve104478sj","content":"<h1 id=\"Rails使用puma带证书启动\"><a href=\"#Rails使用puma带证书启动\" class=\"headerlink\" title=\"Rails使用puma带证书启动\"></a>Rails使用puma带证书启动</h1><p><strong>问题描述</strong></p>\n<p>不常见的场景，偶尔间因为没有<code>Nginx</code>服务器可以用，但又需要测试<code>HTTPS</code>，因此使用这种方式来带证书启动。</p>\n<p><strong>解决方案</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rails s puma -p 3000 -b &#x27;ssl://0.0.0.0:3000?key=config/your_key_file.key&amp;cert=config/your_certificate_file.crt&#x27;</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"Rails使用puma带证书启动\"><a href=\"#Rails使用puma带证书启动\" class=\"headerlink\" title=\"Rails使用puma带证书启动\"></a>Rails使用puma带证书启动</h1><p><strong>问题描述</strong></p>\n<p>不常见的场景，偶尔间因为没有<code>Nginx</code>服务器可以用，但又需要测试<code>HTTPS</code>，因此使用这种方式来带证书启动。</p>\n<p><strong>解决方案</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rails s puma -p 3000 -b &#x27;ssl://0.0.0.0:3000?key=config/your_key_file.key&amp;cert=config/your_certificate_file.crt&#x27;</span><br></pre></td></tr></table></figure>"},{"_content":"# Rails和HTTP 422那点事儿\n\n**问题描述**\n用`Ruby on Rails`开发点接口的时候遇到了`HTTP 422`问题。回去看了眼公司的项目，发现在`environments`里写了一句这个：\n~~~ ruby\nconfig.action_controller.allow_forgery_protection = false\n~~~\n参考了一下`Ruby on Rails`文档中对于`CSRF`的描述：\n> 默认情况下，Rails 自带的非侵入式脚本适配器会在每个非 GET Ajax 调用中添加名为 X-CSRF-Token 的首部，其值为安全令牌。如果没有这个首部，Rails 不会接受非 GET Ajax 请求。使用其他库调用 Ajax 时，同样要在默认首部中添加 X-CSRF-Token。要想获取令牌，请查看应用视图中由 <%= csrf_meta_tags %> 这行代码生成的 <meta name='csrf-token' content='THE-TOKEN'> 标签。\n除了指定的接口外，都需要认证。\n> ——[Ruby on Rails 安全指南](https://ruby-china.github.io/rails-guides/security.html#csrf-countermeasures)\n\n上述配置是非常不推荐的。\n\n**解决方案**\n\n`CSRF`又称为跨站点请求伪造攻击，大意是通过一些手段骗取用户的`cookie`来向源站点发起请求，以达到在用户浑然不觉的情况下使用其账户进行操作的攻击，也是极为常见的一种`WEB`安全问题。 \n\n`Rails`对于`CSRF`的防御策略是在每个页面上生成一个只有服务器才知道的`token`用于验证发起请求的站点究竟是不是允许请求的站点，当服务器验证`token`失败时，会返回`HTTP 422`拒绝本次请求。 当我们在`Rails`里编写表单提交时，应该尽可能的避免编写原生表单，而是应该使用如下代码代替之：\n\n```erb\n<%= form_for @user do |f| %>\n  <%= f.text_field :username %>\n  <%= f.text_field :password %>\n<% end %>\n```\n\n这是`Rails`的`View Helper`方法，使用该段代码生成的表单将自动添加验证`token`，开发者不必额外关注即可解决安全隐患。 在部分手动提交表单（如`AJAX`）的场景里，我们可以使用`form_authenticity_token`方法获取到`token`:\n\n```erb\n<form action=\"/sessions\" method=\"post\">\n  <input type='hidden' value=\"<%= form_authenticity_token %>\" name=\"authenticity_token\"/>\n  <input name='username' type=\"text\"/>\n  <input name='password' type=\"password\"/>\n  <input type=\"submit\"/>\n</form>\n```\n\n现代前后端分离的架构下我们通常使用如`jwt`令牌等`token`来标记请求状态，因此在`API`开发的场景下我们可以酌情考虑关闭`CSRF`的验证机制（具体可参考如下代码）。 \n\n```ruby\nclass ApplicationController < ActionController::Base\n  skip_before_action :verify_authenticity_token, if: :json_request?\n\n  def json_request?\n    request.format.json?\n  end\nend\n```\n\n**但仍需要注意一点是，token的存储问题是值得考虑的，存储在cookie中则依然无法避免CSRF漏洞，反之如果存储在LocalStorage中，则需要留意XSS攻击的防御。**","source":"_posts/Rails和HTTP422那点事儿.md","raw":"# Rails和HTTP 422那点事儿\n\n**问题描述**\n用`Ruby on Rails`开发点接口的时候遇到了`HTTP 422`问题。回去看了眼公司的项目，发现在`environments`里写了一句这个：\n~~~ ruby\nconfig.action_controller.allow_forgery_protection = false\n~~~\n参考了一下`Ruby on Rails`文档中对于`CSRF`的描述：\n> 默认情况下，Rails 自带的非侵入式脚本适配器会在每个非 GET Ajax 调用中添加名为 X-CSRF-Token 的首部，其值为安全令牌。如果没有这个首部，Rails 不会接受非 GET Ajax 请求。使用其他库调用 Ajax 时，同样要在默认首部中添加 X-CSRF-Token。要想获取令牌，请查看应用视图中由 <%= csrf_meta_tags %> 这行代码生成的 <meta name='csrf-token' content='THE-TOKEN'> 标签。\n除了指定的接口外，都需要认证。\n> ——[Ruby on Rails 安全指南](https://ruby-china.github.io/rails-guides/security.html#csrf-countermeasures)\n\n上述配置是非常不推荐的。\n\n**解决方案**\n\n`CSRF`又称为跨站点请求伪造攻击，大意是通过一些手段骗取用户的`cookie`来向源站点发起请求，以达到在用户浑然不觉的情况下使用其账户进行操作的攻击，也是极为常见的一种`WEB`安全问题。 \n\n`Rails`对于`CSRF`的防御策略是在每个页面上生成一个只有服务器才知道的`token`用于验证发起请求的站点究竟是不是允许请求的站点，当服务器验证`token`失败时，会返回`HTTP 422`拒绝本次请求。 当我们在`Rails`里编写表单提交时，应该尽可能的避免编写原生表单，而是应该使用如下代码代替之：\n\n```erb\n<%= form_for @user do |f| %>\n  <%= f.text_field :username %>\n  <%= f.text_field :password %>\n<% end %>\n```\n\n这是`Rails`的`View Helper`方法，使用该段代码生成的表单将自动添加验证`token`，开发者不必额外关注即可解决安全隐患。 在部分手动提交表单（如`AJAX`）的场景里，我们可以使用`form_authenticity_token`方法获取到`token`:\n\n```erb\n<form action=\"/sessions\" method=\"post\">\n  <input type='hidden' value=\"<%= form_authenticity_token %>\" name=\"authenticity_token\"/>\n  <input name='username' type=\"text\"/>\n  <input name='password' type=\"password\"/>\n  <input type=\"submit\"/>\n</form>\n```\n\n现代前后端分离的架构下我们通常使用如`jwt`令牌等`token`来标记请求状态，因此在`API`开发的场景下我们可以酌情考虑关闭`CSRF`的验证机制（具体可参考如下代码）。 \n\n```ruby\nclass ApplicationController < ActionController::Base\n  skip_before_action :verify_authenticity_token, if: :json_request?\n\n  def json_request?\n    request.format.json?\n  end\nend\n```\n\n**但仍需要注意一点是，token的存储问题是值得考虑的，存储在cookie中则依然无法避免CSRF漏洞，反之如果存储在LocalStorage中，则需要留意XSS攻击的防御。**","slug":"Rails和HTTP422那点事儿","published":1,"date":"2022-05-03T08:46:25.152Z","updated":"2022-05-03T08:46:25.152Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdu7001ar2ve7wn62si1","content":"<h1 id=\"Rails和HTTP-422那点事儿\"><a href=\"#Rails和HTTP-422那点事儿\" class=\"headerlink\" title=\"Rails和HTTP 422那点事儿\"></a>Rails和HTTP 422那点事儿</h1><p><strong>问题描述</strong><br>用<code>Ruby on Rails</code>开发点接口的时候遇到了<code>HTTP 422</code>问题。回去看了眼公司的项目，发现在<code>environments</code>里写了一句这个：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.action_controller.allow_forgery_protection = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>参考了一下<code>Ruby on Rails</code>文档中对于<code>CSRF</code>的描述：</p>\n<blockquote>\n<p>默认情况下，Rails 自带的非侵入式脚本适配器会在每个非 GET Ajax 调用中添加名为 X-CSRF-Token 的首部，其值为安全令牌。如果没有这个首部，Rails 不会接受非 GET Ajax 请求。使用其他库调用 Ajax 时，同样要在默认首部中添加 X-CSRF-Token。要想获取令牌，请查看应用视图中由 &lt;%&#x3D; csrf_meta_tags %&gt; 这行代码生成的 <meta name='csrf-token' content='THE-TOKEN'> 标签。<br>除了指定的接口外，都需要认证。<br>——<a href=\"https://ruby-china.github.io/rails-guides/security.html#csrf-countermeasures\">Ruby on Rails 安全指南</a></p>\n</blockquote>\n<p>上述配置是非常不推荐的。</p>\n<p><strong>解决方案</strong></p>\n<p><code>CSRF</code>又称为跨站点请求伪造攻击，大意是通过一些手段骗取用户的<code>cookie</code>来向源站点发起请求，以达到在用户浑然不觉的情况下使用其账户进行操作的攻击，也是极为常见的一种<code>WEB</code>安全问题。 </p>\n<p><code>Rails</code>对于<code>CSRF</code>的防御策略是在每个页面上生成一个只有服务器才知道的<code>token</code>用于验证发起请求的站点究竟是不是允许请求的站点，当服务器验证<code>token</code>失败时，会返回<code>HTTP 422</code>拒绝本次请求。 当我们在<code>Rails</code>里编写表单提交时，应该尽可能的避免编写原生表单，而是应该使用如下代码代替之：</p>\n<figure class=\"highlight erb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"language-xml\">&lt;%=</span><span class=\"language-ruby\"> form_for <span class=\"variable\">@user</span> <span class=\"keyword\">do</span> |<span class=\"params\">f</span>| </span><span class=\"language-xml\">%&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">  &lt;%=</span><span class=\"language-ruby\"> f.text_field <span class=\"symbol\">:username</span> </span><span class=\"language-xml\">%&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">  &lt;%=</span><span class=\"language-ruby\"> f.text_field <span class=\"symbol\">:password</span> </span><span class=\"language-xml\">%&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">&lt;%</span><span class=\"language-ruby\"> <span class=\"keyword\">end</span> </span><span class=\"language-xml\">%&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是<code>Rails</code>的<code>View Helper</code>方法，使用该段代码生成的表单将自动添加验证<code>token</code>，开发者不必额外关注即可解决安全隐患。 在部分手动提交表单（如<code>AJAX</code>）的场景里，我们可以使用<code>form_authenticity_token</code>方法获取到<code>token</code>:</p>\n<figure class=\"highlight erb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;/sessions&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;post&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;hidden&#x27;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;&lt;%=</span></span></span><span class=\"language-ruby\"> form_authenticity_token </span><span class=\"language-xml\"><span class=\"tag\"><span class=\"string\">%&gt;&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;authenticity_token&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&#x27;username&#x27;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&#x27;password&#x27;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>现代前后端分离的架构下我们通常使用如<code>jwt</code>令牌等<code>token</code>来标记请求状态，因此在<code>API</code>开发的场景下我们可以酌情考虑关闭<code>CSRF</code>的验证机制（具体可参考如下代码）。 </p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ApplicationController</span> &lt; <span class=\"title class_ inherited__\">ActionController::Base</span></span><br><span class=\"line\">  skip_before_action <span class=\"symbol\">:verify_authenticity_token</span>, <span class=\"symbol\">if:</span> <span class=\"symbol\">:json_request?</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">json_request?</span></span><br><span class=\"line\">    request.format.json?</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>但仍需要注意一点是，token的存储问题是值得考虑的，存储在cookie中则依然无法避免CSRF漏洞，反之如果存储在LocalStorage中，则需要留意XSS攻击的防御。</strong></p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"Rails和HTTP-422那点事儿\"><a href=\"#Rails和HTTP-422那点事儿\" class=\"headerlink\" title=\"Rails和HTTP 422那点事儿\"></a>Rails和HTTP 422那点事儿</h1><p><strong>问题描述</strong><br>用<code>Ruby on Rails</code>开发点接口的时候遇到了<code>HTTP 422</code>问题。回去看了眼公司的项目，发现在<code>environments</code>里写了一句这个：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.action_controller.allow_forgery_protection = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>参考了一下<code>Ruby on Rails</code>文档中对于<code>CSRF</code>的描述：</p>\n<blockquote>\n<p>默认情况下，Rails 自带的非侵入式脚本适配器会在每个非 GET Ajax 调用中添加名为 X-CSRF-Token 的首部，其值为安全令牌。如果没有这个首部，Rails 不会接受非 GET Ajax 请求。使用其他库调用 Ajax 时，同样要在默认首部中添加 X-CSRF-Token。要想获取令牌，请查看应用视图中由 &lt;%&#x3D; csrf_meta_tags %&gt; 这行代码生成的 <meta name='csrf-token' content='THE-TOKEN'> 标签。<br>除了指定的接口外，都需要认证。<br>——<a href=\"https://ruby-china.github.io/rails-guides/security.html#csrf-countermeasures\">Ruby on Rails 安全指南</a></p>\n</blockquote>\n<p>上述配置是非常不推荐的。</p>\n<p><strong>解决方案</strong></p>\n<p><code>CSRF</code>又称为跨站点请求伪造攻击，大意是通过一些手段骗取用户的<code>cookie</code>来向源站点发起请求，以达到在用户浑然不觉的情况下使用其账户进行操作的攻击，也是极为常见的一种<code>WEB</code>安全问题。 </p>\n<p><code>Rails</code>对于<code>CSRF</code>的防御策略是在每个页面上生成一个只有服务器才知道的<code>token</code>用于验证发起请求的站点究竟是不是允许请求的站点，当服务器验证<code>token</code>失败时，会返回<code>HTTP 422</code>拒绝本次请求。 当我们在<code>Rails</code>里编写表单提交时，应该尽可能的避免编写原生表单，而是应该使用如下代码代替之：</p>\n<figure class=\"highlight erb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"language-xml\">&lt;%=</span><span class=\"language-ruby\"> form_for <span class=\"variable\">@user</span> <span class=\"keyword\">do</span> |<span class=\"params\">f</span>| </span><span class=\"language-xml\">%&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">  &lt;%=</span><span class=\"language-ruby\"> f.text_field <span class=\"symbol\">:username</span> </span><span class=\"language-xml\">%&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">  &lt;%=</span><span class=\"language-ruby\"> f.text_field <span class=\"symbol\">:password</span> </span><span class=\"language-xml\">%&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">&lt;%</span><span class=\"language-ruby\"> <span class=\"keyword\">end</span> </span><span class=\"language-xml\">%&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是<code>Rails</code>的<code>View Helper</code>方法，使用该段代码生成的表单将自动添加验证<code>token</code>，开发者不必额外关注即可解决安全隐患。 在部分手动提交表单（如<code>AJAX</code>）的场景里，我们可以使用<code>form_authenticity_token</code>方法获取到<code>token</code>:</p>\n<figure class=\"highlight erb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;/sessions&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;post&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&#x27;hidden&#x27;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;&lt;%=</span></span></span><span class=\"language-ruby\"> form_authenticity_token </span><span class=\"language-xml\"><span class=\"tag\"><span class=\"string\">%&gt;&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;authenticity_token&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&#x27;username&#x27;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">name</span>=<span class=\"string\">&#x27;password&#x27;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>现代前后端分离的架构下我们通常使用如<code>jwt</code>令牌等<code>token</code>来标记请求状态，因此在<code>API</code>开发的场景下我们可以酌情考虑关闭<code>CSRF</code>的验证机制（具体可参考如下代码）。 </p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ApplicationController</span> &lt; <span class=\"title class_ inherited__\">ActionController::Base</span></span><br><span class=\"line\">  skip_before_action <span class=\"symbol\">:verify_authenticity_token</span>, <span class=\"symbol\">if:</span> <span class=\"symbol\">:json_request?</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">json_request?</span></span><br><span class=\"line\">    request.format.json?</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>但仍需要注意一点是，token的存储问题是值得考虑的，存储在cookie中则依然无法避免CSRF漏洞，反之如果存储在LocalStorage中，则需要留意XSS攻击的防御。</strong></p>\n"},{"_content":"# RubyMine执行bin目录下指令无权限的解决方案\n\n**问题描述**\n\n- `RubyMine`点击测试时提示权限不够/\n- `RubyMine`终端执行`./bin/xxx`命令提示权限不够\n\n**解决方案**\n\n没啥好说的，没权限就给权限呗。\n~~~ shell\nchmod +x {bundle,rails,rake,setup,spring,update,yarn}\n~~~","source":"_posts/RubyMine执行bin目录下指令无权限的解决方案.md","raw":"# RubyMine执行bin目录下指令无权限的解决方案\n\n**问题描述**\n\n- `RubyMine`点击测试时提示权限不够/\n- `RubyMine`终端执行`./bin/xxx`命令提示权限不够\n\n**解决方案**\n\n没啥好说的，没权限就给权限呗。\n~~~ shell\nchmod +x {bundle,rails,rake,setup,spring,update,yarn}\n~~~","slug":"RubyMine执行bin目录下指令无权限的解决方案","published":1,"date":"2022-05-03T08:46:25.182Z","updated":"2022-05-03T08:46:25.182Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdu8001cr2vecm2u4xil","content":"<h1 id=\"RubyMine执行bin目录下指令无权限的解决方案\"><a href=\"#RubyMine执行bin目录下指令无权限的解决方案\" class=\"headerlink\" title=\"RubyMine执行bin目录下指令无权限的解决方案\"></a>RubyMine执行bin目录下指令无权限的解决方案</h1><p><strong>问题描述</strong></p>\n<ul>\n<li><code>RubyMine</code>点击测试时提示权限不够&#x2F;</li>\n<li><code>RubyMine</code>终端执行<code>./bin/xxx</code>命令提示权限不够</li>\n</ul>\n<p><strong>解决方案</strong></p>\n<p>没啥好说的，没权限就给权限呗。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x &#123;bundle,rails,rake,setup,spring,update,yarn&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"RubyMine执行bin目录下指令无权限的解决方案\"><a href=\"#RubyMine执行bin目录下指令无权限的解决方案\" class=\"headerlink\" title=\"RubyMine执行bin目录下指令无权限的解决方案\"></a>RubyMine执行bin目录下指令无权限的解决方案</h1><p><strong>问题描述</strong></p>\n<ul>\n<li><code>RubyMine</code>点击测试时提示权限不够&#x2F;</li>\n<li><code>RubyMine</code>终端执行<code>./bin/xxx</code>命令提示权限不够</li>\n</ul>\n<p><strong>解决方案</strong></p>\n<p>没啥好说的，没权限就给权限呗。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod +x &#123;bundle,rails,rake,setup,spring,update,yarn&#125;</span><br></pre></td></tr></table></figure>"},{"_content":"\n# 数据类型\n就和几乎所有语言一样，`Ruby`也定义了几种基础的数据类型，它们分别是\n- Numeric\n- String\n- ...\n\n## 1 Numeric\n`Numeric`类用来表示数字，其中又包含了`Integer`，`Float`，`Complex`，`BigDecimal`，`Rational`共5个子类。\n\n在日常开发中，`Integer`与`Float`类使用的较多。\n\n### 1.1 Integer\n一个`Integer`类的对象就是一串数字，当该值的范围超过`2^32`时，该值将被透明的转化为`Bignum`类对象，反之则被转化为`Fixnum`类对象。\n在开发过程中，我们可以使用 **千分符** 使数值更具有可读性，如：\n~~~ruby\n100_00\n~~~\n与其他语言相同，当一个数值以0开头且长度不小于2位时，它将不会被当做十进制处理。同样，我们可以使用0x开头来表示十六进制数，如：\n~~~ruby\n0xFF\n~~~\n### 1.2 Float\n在`Ruby`中使用浮点数其实与其他动态语言中并没有太大的区别，不过需要注意的是，`Ruby`并不支持缩写，如`.1`，我们必须完整的写作`0.1`。\n\n### 1.3 运算\n`Numeric`类的运算规则遵循数学中的规则，但相比其他语言，`Ruby`还提供了一个非常便捷的指数运算：\n~~~ruby\n2 ** 10    # => 1024\n~~~\n当然，`Ruby`中也存在着一些意外的规则。\n**不同数据类型的溢出规则**\n`Interger`在运算后会对大数进行转化（`Bignum`），因此`Integer`不会产生溢出。但这一点在`Float`上却并不适用，当数据超出范围后它会溢出为`Infinity/-Infinity/0`三种情况。\n~~~ruby\n2.6.5 :006 > (2 ** 1024)\n => 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216\n2.6.5 :007 > (2 ** 1024).to_f\n => Infinity\n~~~\n**不同数据类型的除法**\n在`Integer`的除法运算中，当除数为0时，会抛出`ZeroDivisionError`异常（我通常使用这种方式来刻意触发异常）、而在`Float`的除法运算中，除数为0时会返回`Infintiy/-Infintiy`。当然，这里也有一个例外，当发生`0.0/0.0`的运算时，会返回`NaN`（`not a number`）\n~~~ruby\n2.6.5 :011 > 1/0\nTraceback (most recent call last):\n        5: from /usr/local/rvm/rubies/ruby-2.6.5/bin/irb:23:in`<main>'\n        4: from /usr/local/rvm/rubies/ruby-2.6.5/bin/irb:23:in`load'\n        3: from /usr/local/rvm/rubies/ruby-2.6.5/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in`<top (required)>'\n        2: from (irb):11\n        1: from (irb):11:in`/'\nZeroDivisionError (divided by 0)\n2.6.5 :012 > 1.0/0\n => Infinity\n2.6.5 :013 > 0.0/0.0\n => NaN\n~~~\n**取余操作和除法**\n当有以下操作时，我们很容易得出结论为2\n~~~ruby\n7/3\n~~~\n当上述除数为负数时，在大部分语言里，我们都会得到-2的结论，然而当我们在`irb`中输入表达式的时候却发现得到的结果是-3。这是因为`Ruby`在对负数做除法时时是向负无穷大取整的。\n由此我们很容易推导得到一个结论：\n~~~ruby\n-(a/b) != a/(-b)\n~~~\n**指数操作的运算顺序**\n指数操作的计算顺序为从右向左，如：\n~~~ruby\n2 ** 2 ** 3 == 2 ** 8 == 256 != 4 ** 3\n~~~\n\n## 2 String\n`Ruby`中每次使用字符串字面量时，实则都会创建一个新的对象。\n~~~ruby\n2.6.5 :004 > 3.times{puts 'hello'.object_id}\n12676760\n12676700\n12676640\n => 3\n\n2.6.5 :006 > str = 'hello'\n => \"hello\"\n2.6.5 :007 > 3.times{puts str.object_id}\n12681240\n12681240\n12681240\n=> 3\n~~~\n需要注意的一点是，字符串的加法运算并不会将右侧操作数转化为字符串，因此在使用过程中需要手动转化，如\n~~~ruby\n2.6.5 :001 > '111' + 2\nTraceback (most recent call last):\n        5: from /usr/local/rvm/rubies/ruby-2.6.5/bin/irb:23:in`<main>'\n        4: from /usr/local/rvm/rubies/ruby-2.6.5/bin/irb:23:in`load'\n        3: from /usr/local/rvm/rubies/ruby-2.6.5/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in`<top (required)>'\n        2: from (irb):1\n        1: from (irb):1:in`+'\nTypeError (no implicit conversion of Integer into String)\n2.6.5 :002 > '111' + 2.to_s\n => \"1112\"\n~~~\n当然，在使用字符串内插操作时，转化是自动的\n~~~ruby\n2.6.5 :003 > \"1 + 1 = #{2}\"\n => \"1 + 1 = 2\"\n~~~\n另外一个非常有趣的细节是当使用`<<`操作符对字符串进行追加，且被追加的内容是一个数字时，该数值会被按照`ASCII`码转移为字符，如\n~~~ruby\nstr = \"a\"\n => \"a\"\n2.6.5 :005 > str << 97\n => \"aa\"\n~~~\n","source":"_posts/Ruby中的数据类型.md","raw":"\n# 数据类型\n就和几乎所有语言一样，`Ruby`也定义了几种基础的数据类型，它们分别是\n- Numeric\n- String\n- ...\n\n## 1 Numeric\n`Numeric`类用来表示数字，其中又包含了`Integer`，`Float`，`Complex`，`BigDecimal`，`Rational`共5个子类。\n\n在日常开发中，`Integer`与`Float`类使用的较多。\n\n### 1.1 Integer\n一个`Integer`类的对象就是一串数字，当该值的范围超过`2^32`时，该值将被透明的转化为`Bignum`类对象，反之则被转化为`Fixnum`类对象。\n在开发过程中，我们可以使用 **千分符** 使数值更具有可读性，如：\n~~~ruby\n100_00\n~~~\n与其他语言相同，当一个数值以0开头且长度不小于2位时，它将不会被当做十进制处理。同样，我们可以使用0x开头来表示十六进制数，如：\n~~~ruby\n0xFF\n~~~\n### 1.2 Float\n在`Ruby`中使用浮点数其实与其他动态语言中并没有太大的区别，不过需要注意的是，`Ruby`并不支持缩写，如`.1`，我们必须完整的写作`0.1`。\n\n### 1.3 运算\n`Numeric`类的运算规则遵循数学中的规则，但相比其他语言，`Ruby`还提供了一个非常便捷的指数运算：\n~~~ruby\n2 ** 10    # => 1024\n~~~\n当然，`Ruby`中也存在着一些意外的规则。\n**不同数据类型的溢出规则**\n`Interger`在运算后会对大数进行转化（`Bignum`），因此`Integer`不会产生溢出。但这一点在`Float`上却并不适用，当数据超出范围后它会溢出为`Infinity/-Infinity/0`三种情况。\n~~~ruby\n2.6.5 :006 > (2 ** 1024)\n => 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216\n2.6.5 :007 > (2 ** 1024).to_f\n => Infinity\n~~~\n**不同数据类型的除法**\n在`Integer`的除法运算中，当除数为0时，会抛出`ZeroDivisionError`异常（我通常使用这种方式来刻意触发异常）、而在`Float`的除法运算中，除数为0时会返回`Infintiy/-Infintiy`。当然，这里也有一个例外，当发生`0.0/0.0`的运算时，会返回`NaN`（`not a number`）\n~~~ruby\n2.6.5 :011 > 1/0\nTraceback (most recent call last):\n        5: from /usr/local/rvm/rubies/ruby-2.6.5/bin/irb:23:in`<main>'\n        4: from /usr/local/rvm/rubies/ruby-2.6.5/bin/irb:23:in`load'\n        3: from /usr/local/rvm/rubies/ruby-2.6.5/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in`<top (required)>'\n        2: from (irb):11\n        1: from (irb):11:in`/'\nZeroDivisionError (divided by 0)\n2.6.5 :012 > 1.0/0\n => Infinity\n2.6.5 :013 > 0.0/0.0\n => NaN\n~~~\n**取余操作和除法**\n当有以下操作时，我们很容易得出结论为2\n~~~ruby\n7/3\n~~~\n当上述除数为负数时，在大部分语言里，我们都会得到-2的结论，然而当我们在`irb`中输入表达式的时候却发现得到的结果是-3。这是因为`Ruby`在对负数做除法时时是向负无穷大取整的。\n由此我们很容易推导得到一个结论：\n~~~ruby\n-(a/b) != a/(-b)\n~~~\n**指数操作的运算顺序**\n指数操作的计算顺序为从右向左，如：\n~~~ruby\n2 ** 2 ** 3 == 2 ** 8 == 256 != 4 ** 3\n~~~\n\n## 2 String\n`Ruby`中每次使用字符串字面量时，实则都会创建一个新的对象。\n~~~ruby\n2.6.5 :004 > 3.times{puts 'hello'.object_id}\n12676760\n12676700\n12676640\n => 3\n\n2.6.5 :006 > str = 'hello'\n => \"hello\"\n2.6.5 :007 > 3.times{puts str.object_id}\n12681240\n12681240\n12681240\n=> 3\n~~~\n需要注意的一点是，字符串的加法运算并不会将右侧操作数转化为字符串，因此在使用过程中需要手动转化，如\n~~~ruby\n2.6.5 :001 > '111' + 2\nTraceback (most recent call last):\n        5: from /usr/local/rvm/rubies/ruby-2.6.5/bin/irb:23:in`<main>'\n        4: from /usr/local/rvm/rubies/ruby-2.6.5/bin/irb:23:in`load'\n        3: from /usr/local/rvm/rubies/ruby-2.6.5/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in`<top (required)>'\n        2: from (irb):1\n        1: from (irb):1:in`+'\nTypeError (no implicit conversion of Integer into String)\n2.6.5 :002 > '111' + 2.to_s\n => \"1112\"\n~~~\n当然，在使用字符串内插操作时，转化是自动的\n~~~ruby\n2.6.5 :003 > \"1 + 1 = #{2}\"\n => \"1 + 1 = 2\"\n~~~\n另外一个非常有趣的细节是当使用`<<`操作符对字符串进行追加，且被追加的内容是一个数字时，该数值会被按照`ASCII`码转移为字符，如\n~~~ruby\nstr = \"a\"\n => \"a\"\n2.6.5 :005 > str << 97\n => \"aa\"\n~~~\n","slug":"Ruby中的数据类型","published":1,"date":"2022-05-03T08:46:25.172Z","updated":"2022-05-03T08:46:25.172Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdua001fr2vehuvtg0ft","content":"<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><p>就和几乎所有语言一样，<code>Ruby</code>也定义了几种基础的数据类型，它们分别是</p>\n<ul>\n<li>Numeric</li>\n<li>String</li>\n<li>…</li>\n</ul>\n<h2 id=\"1-Numeric\"><a href=\"#1-Numeric\" class=\"headerlink\" title=\"1 Numeric\"></a>1 Numeric</h2><p><code>Numeric</code>类用来表示数字，其中又包含了<code>Integer</code>，<code>Float</code>，<code>Complex</code>，<code>BigDecimal</code>，<code>Rational</code>共5个子类。</p>\n<p>在日常开发中，<code>Integer</code>与<code>Float</code>类使用的较多。</p>\n<h3 id=\"1-1-Integer\"><a href=\"#1-1-Integer\" class=\"headerlink\" title=\"1.1 Integer\"></a>1.1 Integer</h3><p>一个<code>Integer</code>类的对象就是一串数字，当该值的范围超过<code>2^32</code>时，该值将被透明的转化为<code>Bignum</code>类对象，反之则被转化为<code>Fixnum</code>类对象。<br>在开发过程中，我们可以使用 <strong>千分符</strong> 使数值更具有可读性，如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">100_00</span></span><br></pre></td></tr></table></figure>\n<p>与其他语言相同，当一个数值以0开头且长度不小于2位时，它将不会被当做十进制处理。同样，我们可以使用0x开头来表示十六进制数，如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0xFF</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-Float\"><a href=\"#1-2-Float\" class=\"headerlink\" title=\"1.2 Float\"></a>1.2 Float</h3><p>在<code>Ruby</code>中使用浮点数其实与其他动态语言中并没有太大的区别，不过需要注意的是，<code>Ruby</code>并不支持缩写，如<code>.1</code>，我们必须完整的写作<code>0.1</code>。</p>\n<h3 id=\"1-3-运算\"><a href=\"#1-3-运算\" class=\"headerlink\" title=\"1.3 运算\"></a>1.3 运算</h3><p><code>Numeric</code>类的运算规则遵循数学中的规则，但相比其他语言，<code>Ruby</code>还提供了一个非常便捷的指数运算：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">10</span>    <span class=\"comment\"># =&gt; 1024</span></span><br></pre></td></tr></table></figure>\n<p>当然，<code>Ruby</code>中也存在着一些意外的规则。<br><strong>不同数据类型的溢出规则</strong><br><code>Interger</code>在运算后会对大数进行转化（<code>Bignum</code>），因此<code>Integer</code>不会产生溢出。但这一点在<code>Float</code>上却并不适用，当数据超出范围后它会溢出为<code>Infinity/-Infinity/0</code>三种情况。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :006 &gt;</span> (<span class=\"number\">2</span> ** <span class=\"number\">1024</span>)</span><br><span class=\"line\"> =&gt; <span class=\"number\">179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216</span></span><br><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :007 &gt;</span> (<span class=\"number\">2</span> ** <span class=\"number\">1024</span>).to_f</span><br><span class=\"line\"> =&gt; Infinity</span><br></pre></td></tr></table></figure>\n<p><strong>不同数据类型的除法</strong><br>在<code>Integer</code>的除法运算中，当除数为0时，会抛出<code>ZeroDivisionError</code>异常（我通常使用这种方式来刻意触发异常）、而在<code>Float</code>的除法运算中，除数为0时会返回<code>Infintiy/-Infintiy</code>。当然，这里也有一个例外，当发生<code>0.0/0.0</code>的运算时，会返回<code>NaN</code>（<code>not a number</code>）</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :011 &gt;</span> <span class=\"number\">1</span>/<span class=\"number\">0</span></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">        <span class=\"number\">5</span>: from /usr/local/rvm/rubies/ruby-<span class=\"number\">2.6</span>.<span class=\"number\">5</span>/bin/<span class=\"symbol\">irb:</span><span class=\"number\">23</span><span class=\"symbol\">:in<span class=\"string\">`&lt;main&gt;&#x27;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">        4: from /usr/local/rvm/rubies/ruby-2.6.5/bin/irb:23:in`</span>load<span class=\"string\">&#x27;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">        3: from /usr/local/rvm/rubies/ruby-2.6.5/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in`&lt;top (required)&gt;&#x27;</span></span></span><br><span class=\"line\">        <span class=\"number\">2</span>: from (irb)<span class=\"symbol\">:</span><span class=\"number\">11</span></span><br><span class=\"line\">        <span class=\"number\">1</span>: from (irb)<span class=\"symbol\">:</span><span class=\"number\">11</span><span class=\"symbol\">:in<span class=\"string\">`/&#x27;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">ZeroDivisionError (divided by 0)</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">2.6.5 :012 &gt; 1.0/0</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\"> =&gt; Infinity</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">2.6.5 :013 &gt; 0.0/0.0</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\"> =&gt; NaN</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>取余操作和除法</strong><br>当有以下操作时，我们很容易得出结论为2</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">7</span>/<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>当上述除数为负数时，在大部分语言里，我们都会得到-2的结论，然而当我们在<code>irb</code>中输入表达式的时候却发现得到的结果是-3。这是因为<code>Ruby</code>在对负数做除法时时是向负无穷大取整的。<br>由此我们很容易推导得到一个结论：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(a/b) != a/(-b)</span><br></pre></td></tr></table></figure>\n<p><strong>指数操作的运算顺序</strong><br>指数操作的计算顺序为从右向左，如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">2</span> ** <span class=\"number\">3</span> == <span class=\"number\">2</span> ** <span class=\"number\">8</span> == <span class=\"number\">256</span> != <span class=\"number\">4</span> ** <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-String\"><a href=\"#2-String\" class=\"headerlink\" title=\"2 String\"></a>2 String</h2><p><code>Ruby</code>中每次使用字符串字面量时，实则都会创建一个新的对象。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :004 &gt;</span> <span class=\"number\">3</span>.times&#123;puts <span class=\"string\">&#x27;hello&#x27;</span>.object_id&#125;</span><br><span class=\"line\"><span class=\"number\">12676760</span></span><br><span class=\"line\"><span class=\"number\">12676700</span></span><br><span class=\"line\"><span class=\"number\">12676640</span></span><br><span class=\"line\"> =&gt; <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :006 &gt;</span> str = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\"> =&gt; <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :007 &gt;</span> <span class=\"number\">3</span>.times&#123;puts str.object_id&#125;</span><br><span class=\"line\"><span class=\"number\">12681240</span></span><br><span class=\"line\"><span class=\"number\">12681240</span></span><br><span class=\"line\"><span class=\"number\">12681240</span></span><br><span class=\"line\">=&gt; <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>需要注意的一点是，字符串的加法运算并不会将右侧操作数转化为字符串，因此在使用过程中需要手动转化，如</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :001 &gt;</span> <span class=\"string\">&#x27;111&#x27;</span> + <span class=\"number\">2</span></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">        <span class=\"number\">5</span>: from /usr/local/rvm/rubies/ruby-<span class=\"number\">2.6</span>.<span class=\"number\">5</span>/bin/<span class=\"symbol\">irb:</span><span class=\"number\">23</span><span class=\"symbol\">:in<span class=\"string\">`&lt;main&gt;&#x27;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">        4: from /usr/local/rvm/rubies/ruby-2.6.5/bin/irb:23:in`</span>load<span class=\"string\">&#x27;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">        3: from /usr/local/rvm/rubies/ruby-2.6.5/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in`&lt;top (required)&gt;&#x27;</span></span></span><br><span class=\"line\">        <span class=\"number\">2</span>: from (irb)<span class=\"symbol\">:</span><span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"number\">1</span>: from (irb)<span class=\"symbol\">:</span><span class=\"number\">1</span><span class=\"symbol\">:in<span class=\"string\">`+&#x27;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">TypeError (no implicit conversion of Integer into String)</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">2.6.5 :002 &gt; &#x27;111&#x27; + 2.to_s</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\"> =&gt; &quot;1112&quot;</span></span></span><br></pre></td></tr></table></figure>\n<p>当然，在使用字符串内插操作时，转化是自动的</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :003 &gt;</span> <span class=\"string\">&quot;1 + 1 = <span class=\"subst\">#&#123;<span class=\"number\">2</span>&#125;</span>&quot;</span></span><br><span class=\"line\"> =&gt; <span class=\"string\">&quot;1 + 1 = 2&quot;</span></span><br></pre></td></tr></table></figure>\n<p>另外一个非常有趣的细节是当使用<code>&lt;&lt;</code>操作符对字符串进行追加，且被追加的内容是一个数字时，该数值会被按照<code>ASCII</code>码转移为字符，如</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\"> =&gt; <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :005 &gt;</span> str &lt;&lt; <span class=\"number\">97</span></span><br><span class=\"line\"> =&gt; <span class=\"string\">&quot;aa&quot;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><p>就和几乎所有语言一样，<code>Ruby</code>也定义了几种基础的数据类型，它们分别是</p>\n<ul>\n<li>Numeric</li>\n<li>String</li>\n<li>…</li>\n</ul>\n<h2 id=\"1-Numeric\"><a href=\"#1-Numeric\" class=\"headerlink\" title=\"1 Numeric\"></a>1 Numeric</h2><p><code>Numeric</code>类用来表示数字，其中又包含了<code>Integer</code>，<code>Float</code>，<code>Complex</code>，<code>BigDecimal</code>，<code>Rational</code>共5个子类。</p>\n<p>在日常开发中，<code>Integer</code>与<code>Float</code>类使用的较多。</p>\n<h3 id=\"1-1-Integer\"><a href=\"#1-1-Integer\" class=\"headerlink\" title=\"1.1 Integer\"></a>1.1 Integer</h3><p>一个<code>Integer</code>类的对象就是一串数字，当该值的范围超过<code>2^32</code>时，该值将被透明的转化为<code>Bignum</code>类对象，反之则被转化为<code>Fixnum</code>类对象。<br>在开发过程中，我们可以使用 <strong>千分符</strong> 使数值更具有可读性，如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">100_00</span></span><br></pre></td></tr></table></figure>\n<p>与其他语言相同，当一个数值以0开头且长度不小于2位时，它将不会被当做十进制处理。同样，我们可以使用0x开头来表示十六进制数，如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0xFF</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-Float\"><a href=\"#1-2-Float\" class=\"headerlink\" title=\"1.2 Float\"></a>1.2 Float</h3><p>在<code>Ruby</code>中使用浮点数其实与其他动态语言中并没有太大的区别，不过需要注意的是，<code>Ruby</code>并不支持缩写，如<code>.1</code>，我们必须完整的写作<code>0.1</code>。</p>\n<h3 id=\"1-3-运算\"><a href=\"#1-3-运算\" class=\"headerlink\" title=\"1.3 运算\"></a>1.3 运算</h3><p><code>Numeric</code>类的运算规则遵循数学中的规则，但相比其他语言，<code>Ruby</code>还提供了一个非常便捷的指数运算：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">10</span>    <span class=\"comment\"># =&gt; 1024</span></span><br></pre></td></tr></table></figure>\n<p>当然，<code>Ruby</code>中也存在着一些意外的规则。<br><strong>不同数据类型的溢出规则</strong><br><code>Interger</code>在运算后会对大数进行转化（<code>Bignum</code>），因此<code>Integer</code>不会产生溢出。但这一点在<code>Float</code>上却并不适用，当数据超出范围后它会溢出为<code>Infinity/-Infinity/0</code>三种情况。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :006 &gt;</span> (<span class=\"number\">2</span> ** <span class=\"number\">1024</span>)</span><br><span class=\"line\"> =&gt; <span class=\"number\">179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216</span></span><br><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :007 &gt;</span> (<span class=\"number\">2</span> ** <span class=\"number\">1024</span>).to_f</span><br><span class=\"line\"> =&gt; Infinity</span><br></pre></td></tr></table></figure>\n<p><strong>不同数据类型的除法</strong><br>在<code>Integer</code>的除法运算中，当除数为0时，会抛出<code>ZeroDivisionError</code>异常（我通常使用这种方式来刻意触发异常）、而在<code>Float</code>的除法运算中，除数为0时会返回<code>Infintiy/-Infintiy</code>。当然，这里也有一个例外，当发生<code>0.0/0.0</code>的运算时，会返回<code>NaN</code>（<code>not a number</code>）</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :011 &gt;</span> <span class=\"number\">1</span>/<span class=\"number\">0</span></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">        <span class=\"number\">5</span>: from /usr/local/rvm/rubies/ruby-<span class=\"number\">2.6</span>.<span class=\"number\">5</span>/bin/<span class=\"symbol\">irb:</span><span class=\"number\">23</span><span class=\"symbol\">:in<span class=\"string\">`&lt;main&gt;&#x27;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">        4: from /usr/local/rvm/rubies/ruby-2.6.5/bin/irb:23:in`</span>load<span class=\"string\">&#x27;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">        3: from /usr/local/rvm/rubies/ruby-2.6.5/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in`&lt;top (required)&gt;&#x27;</span></span></span><br><span class=\"line\">        <span class=\"number\">2</span>: from (irb)<span class=\"symbol\">:</span><span class=\"number\">11</span></span><br><span class=\"line\">        <span class=\"number\">1</span>: from (irb)<span class=\"symbol\">:</span><span class=\"number\">11</span><span class=\"symbol\">:in<span class=\"string\">`/&#x27;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">ZeroDivisionError (divided by 0)</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">2.6.5 :012 &gt; 1.0/0</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\"> =&gt; Infinity</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">2.6.5 :013 &gt; 0.0/0.0</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\"> =&gt; NaN</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>取余操作和除法</strong><br>当有以下操作时，我们很容易得出结论为2</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">7</span>/<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>当上述除数为负数时，在大部分语言里，我们都会得到-2的结论，然而当我们在<code>irb</code>中输入表达式的时候却发现得到的结果是-3。这是因为<code>Ruby</code>在对负数做除法时时是向负无穷大取整的。<br>由此我们很容易推导得到一个结论：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(a/b) != a/(-b)</span><br></pre></td></tr></table></figure>\n<p><strong>指数操作的运算顺序</strong><br>指数操作的计算顺序为从右向左，如：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">2</span> ** <span class=\"number\">3</span> == <span class=\"number\">2</span> ** <span class=\"number\">8</span> == <span class=\"number\">256</span> != <span class=\"number\">4</span> ** <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-String\"><a href=\"#2-String\" class=\"headerlink\" title=\"2 String\"></a>2 String</h2><p><code>Ruby</code>中每次使用字符串字面量时，实则都会创建一个新的对象。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :004 &gt;</span> <span class=\"number\">3</span>.times&#123;puts <span class=\"string\">&#x27;hello&#x27;</span>.object_id&#125;</span><br><span class=\"line\"><span class=\"number\">12676760</span></span><br><span class=\"line\"><span class=\"number\">12676700</span></span><br><span class=\"line\"><span class=\"number\">12676640</span></span><br><span class=\"line\"> =&gt; <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :006 &gt;</span> str = <span class=\"string\">&#x27;hello&#x27;</span></span><br><span class=\"line\"> =&gt; <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :007 &gt;</span> <span class=\"number\">3</span>.times&#123;puts str.object_id&#125;</span><br><span class=\"line\"><span class=\"number\">12681240</span></span><br><span class=\"line\"><span class=\"number\">12681240</span></span><br><span class=\"line\"><span class=\"number\">12681240</span></span><br><span class=\"line\">=&gt; <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<p>需要注意的一点是，字符串的加法运算并不会将右侧操作数转化为字符串，因此在使用过程中需要手动转化，如</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :001 &gt;</span> <span class=\"string\">&#x27;111&#x27;</span> + <span class=\"number\">2</span></span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">        <span class=\"number\">5</span>: from /usr/local/rvm/rubies/ruby-<span class=\"number\">2.6</span>.<span class=\"number\">5</span>/bin/<span class=\"symbol\">irb:</span><span class=\"number\">23</span><span class=\"symbol\">:in<span class=\"string\">`&lt;main&gt;&#x27;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">        4: from /usr/local/rvm/rubies/ruby-2.6.5/bin/irb:23:in`</span>load<span class=\"string\">&#x27;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">        3: from /usr/local/rvm/rubies/ruby-2.6.5/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in`&lt;top (required)&gt;&#x27;</span></span></span><br><span class=\"line\">        <span class=\"number\">2</span>: from (irb)<span class=\"symbol\">:</span><span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"number\">1</span>: from (irb)<span class=\"symbol\">:</span><span class=\"number\">1</span><span class=\"symbol\">:in<span class=\"string\">`+&#x27;</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">TypeError (no implicit conversion of Integer into String)</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\">2.6.5 :002 &gt; &#x27;111&#x27; + 2.to_s</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"symbol\"> =&gt; &quot;1112&quot;</span></span></span><br></pre></td></tr></table></figure>\n<p>当然，在使用字符串内插操作时，转化是自动的</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :003 &gt;</span> <span class=\"string\">&quot;1 + 1 = <span class=\"subst\">#&#123;<span class=\"number\">2</span>&#125;</span>&quot;</span></span><br><span class=\"line\"> =&gt; <span class=\"string\">&quot;1 + 1 = 2&quot;</span></span><br></pre></td></tr></table></figure>\n<p>另外一个非常有趣的细节是当使用<code>&lt;&lt;</code>操作符对字符串进行追加，且被追加的内容是一个数字时，该数值会被按照<code>ASCII</code>码转移为字符，如</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\"> =&gt; <span class=\"string\">&quot;a&quot;</span></span><br><span class=\"line\"><span class=\"meta prompt_\">2.6.5 :005 &gt;</span> str &lt;&lt; <span class=\"number\">97</span></span><br><span class=\"line\"> =&gt; <span class=\"string\">&quot;aa&quot;</span></span><br></pre></td></tr></table></figure>\n"},{"_content":"# git clone速度太慢的解决方案乱谈\n\n以下方案仅供参考，目测替换后速度由4-10k提升到60-200k，依然龟速……\n\n1. 带权限打开`/etc/hosts`\n    ~~~\n    sudo vim /etc/hosts\n    ~~~\n2. 添加如下内容\n    ~~~\n    151.101.72.249 github.global.ssl.fastly.net  \n    192.30.253.112 github.com\n    ~~~\n","source":"_posts/git-clone速度太慢.md","raw":"# git clone速度太慢的解决方案乱谈\n\n以下方案仅供参考，目测替换后速度由4-10k提升到60-200k，依然龟速……\n\n1. 带权限打开`/etc/hosts`\n    ~~~\n    sudo vim /etc/hosts\n    ~~~\n2. 添加如下内容\n    ~~~\n    151.101.72.249 github.global.ssl.fastly.net  \n    192.30.253.112 github.com\n    ~~~\n","slug":"git-clone速度太慢","published":1,"date":"2022-05-03T08:46:25.182Z","updated":"2022-05-03T08:46:25.182Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdua001hr2vefdpe1qz1","content":"<h1 id=\"git-clone速度太慢的解决方案乱谈\"><a href=\"#git-clone速度太慢的解决方案乱谈\" class=\"headerlink\" title=\"git clone速度太慢的解决方案乱谈\"></a>git clone速度太慢的解决方案乱谈</h1><p>以下方案仅供参考，目测替换后速度由4-10k提升到60-200k，依然龟速……</p>\n<ol>\n<li>带权限打开<code>/etc/hosts</code> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure></li>\n<li>添加如下内容 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">151.101.72.249 github.global.ssl.fastly.net  </span><br><span class=\"line\">192.30.253.112 github.com</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"git-clone速度太慢的解决方案乱谈\"><a href=\"#git-clone速度太慢的解决方案乱谈\" class=\"headerlink\" title=\"git clone速度太慢的解决方案乱谈\"></a>git clone速度太慢的解决方案乱谈</h1><p>以下方案仅供参考，目测替换后速度由4-10k提升到60-200k，依然龟速……</p>\n<ol>\n<li>带权限打开<code>/etc/hosts</code> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure></li>\n<li>添加如下内容 <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">151.101.72.249 github.global.ssl.fastly.net  </span><br><span class=\"line\">192.30.253.112 github.com</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-05-03T07:31:31.302Z","updated":"2022-05-03T07:31:31.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdub001jr2vefbwhgtc4","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"_content":"# JavaScript元编程——基于Proxy实现active_record动态查找\n\n## 1. 元编程\n\n在网络上无意间看到《JavaScript权威指南》第七版的目录，除了`NodeJS`外，很意外的看到有一个章节叫元编程。\n\n第一次听说元编程这一概念还是来自于`Ruby`，《Ruby元编程》这本书，很遗憾的是这本书我只看了一点点……对于元编程，我所掌握的也就只有`Open Class`和`method_missing`而已了，不过本文也就只是使用了这么点简单的内容。\n\n### 1.1 Open Class\n在很多面向对象的语言里是无法修改一个类的，但在`Ruby`中如下代码是合法的：\n\n~~~ruby\nclass Book\n  attr_accessor :name\n\n  def initialize(name)\n    @name = name\n  end\n\n  def to_s\n    \"书名：#{@name}\"\n  end\n\nend\n\nbook = Book.new(\"《Ruby 元编程》\")\n\nputs book.to_s\n\n# Open Class\nclass Book\n\n  def pure_name\n    @name[0] == \"《\" && @name[-1] == \"》\" ? @name[1..-2] : @name\n  end\n\nend\n\nputs book.pure_name\n~~~\n\n虽然重复定义了`Book`类，但后定义的`pure_name`方法被“加入”到了原有的类定义中。通过这种方式我们可以在任意位置对我们的代码进行扩展，这一技巧被称为`Monkey Patch`，以下是一个更实用一点的例子，我们打开了`Array`类。\n\n```ruby\n# 通过 Open Class 为数组添加一个用于求平均值的方法\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nclass Array\n\n  def average\n    sum / size\n  end\n\nend\n\nputs arr.average # 输出 5\n```\n\n除了扩展方法外，我们还可以通过这种手段使程序更具有表现力：\n\n```ruby\narr = [...]\n\narr.first # 等同于 arr[0]\narr.second # 等同于 arr[1]\narr.last # 等同于 arr[-1]\n```\n\n不过这种手段也容易带来问题，例如打开类以后覆盖了一个已有的方法，那么极容易导致其它位置的方法调用出现问题。\n\n### 1.2. method_missing\n\n`Ruby`对象在调用方法时，如果不能找到目标方法，则会尝试执行`method_missing`方法，我们可以将`method_missing`方法看作一层代理：\n\n```ruby\nclass Array\n\n  def method_missing(method)\n    case method\n    when :average\n      sum / size\n    when :to_binary\n      map{ |num| num.to_s(2) }\n    end\n  end\n\nend\n\narr = (1..10).to_a\n\n# 如下两个方法都没有直接在 Array 类中定义，而是在查询方法失败以后通过 method_missing 方法进行了处理\nputs arr.average # 返回 5\nputs arr.to_binary # 返回数组元素转为二进制之后组成的数组\n```\n\n## 2. 基于prototype和proxy尝试JavaScript元编程\n\n我们知道`JavaScript`的类实际上是借由`prototype`实现的语法糖，利用`prototype`一样可以实现类似于上述的`Open Class`。\n\n```javascript\nconst indexAlias = {\n    first: 0,\n    second: 1,\n    third: 2,\n    fourth: 3,\n    fifth: 4,\n    sixth: 5,\n    seventh: 6,\n    eighth: 7,\n    ninth: 8,\n    tenth: 9,\n    twentieth: 19,\n    thirtieth: 29,\n    last: -1,\n}\n\nObject.keys(indexAlias).map(alias => {\n    Array.prototype[alias] = function () {\n        const index = indexAlias[alias] === -1 ? this.length - 1 : indexAlias[alias];\n        return this[index];\n    }\n});\n\nconst testArr = Object.keys(Array.from(new Array(100)));\n\nconsole.log(testArr.first()); // 等同于 testArr[0]\nconsole.log(testArr.second()); // 等同于 testArr[1]\nconsole.log(testArr.third()); // 等同于 testArr[2]\nconsole.log(testArr.last()); // 等同于 testArr[3]\n```\n\n上述例子动态的为数组类扩展了多个**类似的**方法。\n\n不过这里有一个小细节，其实我并不一定需要所有的方法，有时候可能到头来只调用了`first`和`last`方法，但这些方法却实实在在的都挂到了`prototype`上。\n\n基于代理来实现的方法动态定义其实可以解决这个问题。\n\n```javascript\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nconst customArr = new Proxy(arr, {\n    get: function (target, prop, receiver) {\n        if (Reflect.has(target, prop)) return Reflect.get(...arguments);\n        switch (prop) {\n            case 'average':\n                return function () {\n                    return this.reduce((sum, item) => sum + item, 0) / this.length;\n                }\n        }\n    }\n});\n\nconsole.log(customArr.average());\n```\n\n需要注意几点细节：\n\n1. 此处通过代理扩展的是**实例方法而非类方法**。\n2. 考虑到数组和对象都可以用字面量的方式完成初始化，打开`Array/Object`类的时候，或许`prototype`会更管用一些，因为**prototype修改的是原有的类而代理是创建新的类**。\n\n当然，完全可以将`average`方法直接放到`prototype`上，但如果我们要定义的是多个存在联系的方法，使用这种代理会灵活的多，关于这一点，接下来要尝试实现的`active_record`动态查找可能是一个不错的案例。\n\n## 3. 基于Proxy实现active_record动态查找\n\n`active_record`是`Ruby On Rails`中的`ORM`库，它有一个非常有用的魔法：假设存在一张数据表`users`，它有三个字段：\n\n- `username`\n- `nickname`\n- `email`\n\n根据以往我们对`ORM`的理解，此时需要创建一个实体类，且这个实体类一眼两个需要声明上述的三个属性。不过，在`ActiveRecord`里，创建实体类你只需要继承`ActiveRecord`即可，它会自动的添加类属性，同时还有包括如下三个方法在内的大量数据读写方法：\n\n- `find_by_username`\n- `find_by_nickname`\n- `find_by_email`\n\n其原理是根据数据表的字段名列表动态定义了各字段的查询方法。\n\n`JavaScript`基于代理也可以实现类似的效果，下面的示例代码没有真正的链接数据库，而是使用了一个对象结构来进行模拟，同时为了让示例看起来像那么回事儿，还实现了`active_record`持久化数据的两个方法`save/create`。\n\n先来看看最终的效果：\n\n```javascript\nconst ActiveRecord = require('./ActiveRecord');\n\n// 1. 初始化一个数据源（模拟数据库）\nconst DB = {};\n\nActiveRecord.init({\n    db: DB,\n});\n\nclass User extends ActiveRecord { // 2. 定义一个实体类\n}\n\n// 3.1 创建一条数据的方式1： 实例化一个对象然后调用 save 方法\nconst yuchi = new User({\n    userName: 'yuchi',\n    password: '123456',\n    nickName: '鱼翅'\n});\n\nyuchi.save();\n\n// 3.2 创建一条数据的方式2： 直接使用 create 类方法\nUser.create({\n    userName: 'xiaoming',\n    password: '11111',\n    nickName: '小明'\n});\n\n// 4. 查看虚拟的数据库数据 \nconsole.log(DB);\n\n// 5. 通过属性生成的动态查询方法进行查询\nconsole.log(User.findByUserName('yuchi'));\nconsole.log(User.findByNickName('小明'));\nconsole.log(User.findByPassword('11111'));\n\n// 再创建一个\nclass Book extends ActiveRecord { }\n\nBook.create({ name: '《我们的土地》', author: '[墨西哥] 卡洛斯·富恩特斯', pageTotal: '1036', price: '168', ISBN: '9787521211542' });\nBook.create({ name: '《戛纳往事》', author: '[法]吉尔·雅各布', pageTotal: '712', price: '148', ISBN: '9787308211208' });\n\n\nconsole.log('查询结果：', Book.findByName('《戛纳往事》'));\nconsole.log('查询结果：', Book.findByAuthor('[法]吉尔·雅各布'));\nconsole.log('查询结果：', Book.findByPageTotal('712'));\nconsole.log('查询结果：', Book.findByPrice('168'));\nconsole.log('查询结果：', Book.findByISBN('9787308211208'));\n```\n\n以下是`ActiveRecord`类的实现，它有如下细节：\n\n1. `ActiveRecord`是一个经过代理的类。\n2. 创建一个`ActiveRecord`类的子类，然后初始化，实际调用的是父类的构造函数，同时也会触发代理（注意`Proxy`里的代码，为了保证返回的对象依然是子类对象，手动修改了构造函数指向）。\n3. `ActiveRecord`类经过代理后，增加了动态查询类方法。\n4. `ActiveRecord`类的子类实例化后得到的也是一个经过代理的对象，代理中实现了一些实例方法。\n\n```javascript\n// 定义基础的 ActiveRecord 抽象类，并支持动态的初始化实例属性\nclass BaseActiveRecord {\n    constructor(record) {\n        Object.keys(record).map(item => this[item] = record[item])\n    }\n\n    // 一个用于验证代理后的类依然可以被继承的基础方法，也顺便用于数据序列化以便于存到 DB 中\n    toJSON() {\n        const res = {};\n        Object.keys(this).map(item => res[item] = this[item]);\n        return res;\n    }\n}\n\n// 代理基础 ActiveRecord 类\nconst ActiveRecord = new Proxy(BaseActiveRecord, {\n    // 代理构造方法，主要意图在希望实例化以后返回的 AR 对象一样是被代理过的\n    construct: function (target, args, newTarget) {\n        const nativeObj = new target(args[0]);\n        nativeObj.__proto__ = newTarget.prototype;\n\n        return new Proxy(nativeObj, {\n            get: function (obj, prop) {\n                if (Reflect.has(obj, prop)) return Reflect.get(...arguments);\n                if (prop !== 'save') throw new Error(`${prop} is not a function!`)\n                \n                // 定义了一个 save 方法，自动根据实体类的名字将数据存到对应的表里\n                return function () {\n                    const tableName = obj.__proto__.constructor.name.toLowerCase() + 's';\n                    ActiveRecord.db[tableName] = (ActiveRecord.db[tableName] || []);\n                    ActiveRecord.db[tableName].push(this.toJSON());\n                }\n            },\n        });\n    },\n    // 代理类属性和方法\n    get: function (obj, prop, receiver) {\n        if (Reflect.has(obj, prop)) return Reflect.get(...arguments);\n\n        const tableName = receiver.prototype.constructor.name.toLowerCase() + 's';\n        switch (prop) {\n            // 定义一个 create 方法，基本与 save 方法相同\n            case 'create':\n                return function () {\n                    ActiveRecord.db[tableName] = (ActiveRecord.db[tableName] || []);\n                    ActiveRecord.db[tableName].push(arguments[0]);\n                }\n            default:\n                // 根据属性动态定义 findByAttr 方法\n                if (prop.startsWith('findBy')) {\n                    const attr = prop.slice(prop.indexOf('findBy') + 6, prop.length).toLowerCase();\n\n                    return function () {\n                        return ActiveRecord.db[tableName].filter(item => item[Object.keys(item).filter(item => item.toLowerCase() === attr)[0]] === arguments[0]);\n                    }\n                }\n        }\n    }\n});\n\n// 用来初始化 DB 数据源的配置\nActiveRecord.init = function (option) {\n    ActiveRecord.db = option.db;\n}\n\nmodule.exports = ActiveRecord;\n```\n\n代码：\n[yuchiXiong/activeRecordByProxy](https://github.com/yuchiXiong/activeRecordByProxy)","source":"_posts/javascript元编程——基于Proxy实现active_record动态查找.md","raw":"# JavaScript元编程——基于Proxy实现active_record动态查找\n\n## 1. 元编程\n\n在网络上无意间看到《JavaScript权威指南》第七版的目录，除了`NodeJS`外，很意外的看到有一个章节叫元编程。\n\n第一次听说元编程这一概念还是来自于`Ruby`，《Ruby元编程》这本书，很遗憾的是这本书我只看了一点点……对于元编程，我所掌握的也就只有`Open Class`和`method_missing`而已了，不过本文也就只是使用了这么点简单的内容。\n\n### 1.1 Open Class\n在很多面向对象的语言里是无法修改一个类的，但在`Ruby`中如下代码是合法的：\n\n~~~ruby\nclass Book\n  attr_accessor :name\n\n  def initialize(name)\n    @name = name\n  end\n\n  def to_s\n    \"书名：#{@name}\"\n  end\n\nend\n\nbook = Book.new(\"《Ruby 元编程》\")\n\nputs book.to_s\n\n# Open Class\nclass Book\n\n  def pure_name\n    @name[0] == \"《\" && @name[-1] == \"》\" ? @name[1..-2] : @name\n  end\n\nend\n\nputs book.pure_name\n~~~\n\n虽然重复定义了`Book`类，但后定义的`pure_name`方法被“加入”到了原有的类定义中。通过这种方式我们可以在任意位置对我们的代码进行扩展，这一技巧被称为`Monkey Patch`，以下是一个更实用一点的例子，我们打开了`Array`类。\n\n```ruby\n# 通过 Open Class 为数组添加一个用于求平均值的方法\narr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nclass Array\n\n  def average\n    sum / size\n  end\n\nend\n\nputs arr.average # 输出 5\n```\n\n除了扩展方法外，我们还可以通过这种手段使程序更具有表现力：\n\n```ruby\narr = [...]\n\narr.first # 等同于 arr[0]\narr.second # 等同于 arr[1]\narr.last # 等同于 arr[-1]\n```\n\n不过这种手段也容易带来问题，例如打开类以后覆盖了一个已有的方法，那么极容易导致其它位置的方法调用出现问题。\n\n### 1.2. method_missing\n\n`Ruby`对象在调用方法时，如果不能找到目标方法，则会尝试执行`method_missing`方法，我们可以将`method_missing`方法看作一层代理：\n\n```ruby\nclass Array\n\n  def method_missing(method)\n    case method\n    when :average\n      sum / size\n    when :to_binary\n      map{ |num| num.to_s(2) }\n    end\n  end\n\nend\n\narr = (1..10).to_a\n\n# 如下两个方法都没有直接在 Array 类中定义，而是在查询方法失败以后通过 method_missing 方法进行了处理\nputs arr.average # 返回 5\nputs arr.to_binary # 返回数组元素转为二进制之后组成的数组\n```\n\n## 2. 基于prototype和proxy尝试JavaScript元编程\n\n我们知道`JavaScript`的类实际上是借由`prototype`实现的语法糖，利用`prototype`一样可以实现类似于上述的`Open Class`。\n\n```javascript\nconst indexAlias = {\n    first: 0,\n    second: 1,\n    third: 2,\n    fourth: 3,\n    fifth: 4,\n    sixth: 5,\n    seventh: 6,\n    eighth: 7,\n    ninth: 8,\n    tenth: 9,\n    twentieth: 19,\n    thirtieth: 29,\n    last: -1,\n}\n\nObject.keys(indexAlias).map(alias => {\n    Array.prototype[alias] = function () {\n        const index = indexAlias[alias] === -1 ? this.length - 1 : indexAlias[alias];\n        return this[index];\n    }\n});\n\nconst testArr = Object.keys(Array.from(new Array(100)));\n\nconsole.log(testArr.first()); // 等同于 testArr[0]\nconsole.log(testArr.second()); // 等同于 testArr[1]\nconsole.log(testArr.third()); // 等同于 testArr[2]\nconsole.log(testArr.last()); // 等同于 testArr[3]\n```\n\n上述例子动态的为数组类扩展了多个**类似的**方法。\n\n不过这里有一个小细节，其实我并不一定需要所有的方法，有时候可能到头来只调用了`first`和`last`方法，但这些方法却实实在在的都挂到了`prototype`上。\n\n基于代理来实现的方法动态定义其实可以解决这个问题。\n\n```javascript\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\nconst customArr = new Proxy(arr, {\n    get: function (target, prop, receiver) {\n        if (Reflect.has(target, prop)) return Reflect.get(...arguments);\n        switch (prop) {\n            case 'average':\n                return function () {\n                    return this.reduce((sum, item) => sum + item, 0) / this.length;\n                }\n        }\n    }\n});\n\nconsole.log(customArr.average());\n```\n\n需要注意几点细节：\n\n1. 此处通过代理扩展的是**实例方法而非类方法**。\n2. 考虑到数组和对象都可以用字面量的方式完成初始化，打开`Array/Object`类的时候，或许`prototype`会更管用一些，因为**prototype修改的是原有的类而代理是创建新的类**。\n\n当然，完全可以将`average`方法直接放到`prototype`上，但如果我们要定义的是多个存在联系的方法，使用这种代理会灵活的多，关于这一点，接下来要尝试实现的`active_record`动态查找可能是一个不错的案例。\n\n## 3. 基于Proxy实现active_record动态查找\n\n`active_record`是`Ruby On Rails`中的`ORM`库，它有一个非常有用的魔法：假设存在一张数据表`users`，它有三个字段：\n\n- `username`\n- `nickname`\n- `email`\n\n根据以往我们对`ORM`的理解，此时需要创建一个实体类，且这个实体类一眼两个需要声明上述的三个属性。不过，在`ActiveRecord`里，创建实体类你只需要继承`ActiveRecord`即可，它会自动的添加类属性，同时还有包括如下三个方法在内的大量数据读写方法：\n\n- `find_by_username`\n- `find_by_nickname`\n- `find_by_email`\n\n其原理是根据数据表的字段名列表动态定义了各字段的查询方法。\n\n`JavaScript`基于代理也可以实现类似的效果，下面的示例代码没有真正的链接数据库，而是使用了一个对象结构来进行模拟，同时为了让示例看起来像那么回事儿，还实现了`active_record`持久化数据的两个方法`save/create`。\n\n先来看看最终的效果：\n\n```javascript\nconst ActiveRecord = require('./ActiveRecord');\n\n// 1. 初始化一个数据源（模拟数据库）\nconst DB = {};\n\nActiveRecord.init({\n    db: DB,\n});\n\nclass User extends ActiveRecord { // 2. 定义一个实体类\n}\n\n// 3.1 创建一条数据的方式1： 实例化一个对象然后调用 save 方法\nconst yuchi = new User({\n    userName: 'yuchi',\n    password: '123456',\n    nickName: '鱼翅'\n});\n\nyuchi.save();\n\n// 3.2 创建一条数据的方式2： 直接使用 create 类方法\nUser.create({\n    userName: 'xiaoming',\n    password: '11111',\n    nickName: '小明'\n});\n\n// 4. 查看虚拟的数据库数据 \nconsole.log(DB);\n\n// 5. 通过属性生成的动态查询方法进行查询\nconsole.log(User.findByUserName('yuchi'));\nconsole.log(User.findByNickName('小明'));\nconsole.log(User.findByPassword('11111'));\n\n// 再创建一个\nclass Book extends ActiveRecord { }\n\nBook.create({ name: '《我们的土地》', author: '[墨西哥] 卡洛斯·富恩特斯', pageTotal: '1036', price: '168', ISBN: '9787521211542' });\nBook.create({ name: '《戛纳往事》', author: '[法]吉尔·雅各布', pageTotal: '712', price: '148', ISBN: '9787308211208' });\n\n\nconsole.log('查询结果：', Book.findByName('《戛纳往事》'));\nconsole.log('查询结果：', Book.findByAuthor('[法]吉尔·雅各布'));\nconsole.log('查询结果：', Book.findByPageTotal('712'));\nconsole.log('查询结果：', Book.findByPrice('168'));\nconsole.log('查询结果：', Book.findByISBN('9787308211208'));\n```\n\n以下是`ActiveRecord`类的实现，它有如下细节：\n\n1. `ActiveRecord`是一个经过代理的类。\n2. 创建一个`ActiveRecord`类的子类，然后初始化，实际调用的是父类的构造函数，同时也会触发代理（注意`Proxy`里的代码，为了保证返回的对象依然是子类对象，手动修改了构造函数指向）。\n3. `ActiveRecord`类经过代理后，增加了动态查询类方法。\n4. `ActiveRecord`类的子类实例化后得到的也是一个经过代理的对象，代理中实现了一些实例方法。\n\n```javascript\n// 定义基础的 ActiveRecord 抽象类，并支持动态的初始化实例属性\nclass BaseActiveRecord {\n    constructor(record) {\n        Object.keys(record).map(item => this[item] = record[item])\n    }\n\n    // 一个用于验证代理后的类依然可以被继承的基础方法，也顺便用于数据序列化以便于存到 DB 中\n    toJSON() {\n        const res = {};\n        Object.keys(this).map(item => res[item] = this[item]);\n        return res;\n    }\n}\n\n// 代理基础 ActiveRecord 类\nconst ActiveRecord = new Proxy(BaseActiveRecord, {\n    // 代理构造方法，主要意图在希望实例化以后返回的 AR 对象一样是被代理过的\n    construct: function (target, args, newTarget) {\n        const nativeObj = new target(args[0]);\n        nativeObj.__proto__ = newTarget.prototype;\n\n        return new Proxy(nativeObj, {\n            get: function (obj, prop) {\n                if (Reflect.has(obj, prop)) return Reflect.get(...arguments);\n                if (prop !== 'save') throw new Error(`${prop} is not a function!`)\n                \n                // 定义了一个 save 方法，自动根据实体类的名字将数据存到对应的表里\n                return function () {\n                    const tableName = obj.__proto__.constructor.name.toLowerCase() + 's';\n                    ActiveRecord.db[tableName] = (ActiveRecord.db[tableName] || []);\n                    ActiveRecord.db[tableName].push(this.toJSON());\n                }\n            },\n        });\n    },\n    // 代理类属性和方法\n    get: function (obj, prop, receiver) {\n        if (Reflect.has(obj, prop)) return Reflect.get(...arguments);\n\n        const tableName = receiver.prototype.constructor.name.toLowerCase() + 's';\n        switch (prop) {\n            // 定义一个 create 方法，基本与 save 方法相同\n            case 'create':\n                return function () {\n                    ActiveRecord.db[tableName] = (ActiveRecord.db[tableName] || []);\n                    ActiveRecord.db[tableName].push(arguments[0]);\n                }\n            default:\n                // 根据属性动态定义 findByAttr 方法\n                if (prop.startsWith('findBy')) {\n                    const attr = prop.slice(prop.indexOf('findBy') + 6, prop.length).toLowerCase();\n\n                    return function () {\n                        return ActiveRecord.db[tableName].filter(item => item[Object.keys(item).filter(item => item.toLowerCase() === attr)[0]] === arguments[0]);\n                    }\n                }\n        }\n    }\n});\n\n// 用来初始化 DB 数据源的配置\nActiveRecord.init = function (option) {\n    ActiveRecord.db = option.db;\n}\n\nmodule.exports = ActiveRecord;\n```\n\n代码：\n[yuchiXiong/activeRecordByProxy](https://github.com/yuchiXiong/activeRecordByProxy)","slug":"javascript元编程——基于Proxy实现active_record动态查找","published":1,"date":"2022-05-03T08:46:25.172Z","updated":"2022-05-03T08:46:25.172Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mduc001lr2vegk137xr1","content":"<h1 id=\"JavaScript元编程——基于Proxy实现active-record动态查找\"><a href=\"#JavaScript元编程——基于Proxy实现active-record动态查找\" class=\"headerlink\" title=\"JavaScript元编程——基于Proxy实现active_record动态查找\"></a>JavaScript元编程——基于Proxy实现active_record动态查找</h1><h2 id=\"1-元编程\"><a href=\"#1-元编程\" class=\"headerlink\" title=\"1. 元编程\"></a>1. 元编程</h2><p>在网络上无意间看到《JavaScript权威指南》第七版的目录，除了<code>NodeJS</code>外，很意外的看到有一个章节叫元编程。</p>\n<p>第一次听说元编程这一概念还是来自于<code>Ruby</code>，《Ruby元编程》这本书，很遗憾的是这本书我只看了一点点……对于元编程，我所掌握的也就只有<code>Open Class</code>和<code>method_missing</code>而已了，不过本文也就只是使用了这么点简单的内容。</p>\n<h3 id=\"1-1-Open-Class\"><a href=\"#1-1-Open-Class\" class=\"headerlink\" title=\"1.1 Open Class\"></a>1.1 Open Class</h3><p>在很多面向对象的语言里是无法修改一个类的，但在<code>Ruby</code>中如下代码是合法的：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Book</span></span><br><span class=\"line\">  <span class=\"keyword\">attr_accessor</span> <span class=\"symbol\">:name</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">initialize</span>(<span class=\"params\">name</span>)</span><br><span class=\"line\">    <span class=\"variable\">@name</span> = name</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">to_s</span></span><br><span class=\"line\">    <span class=\"string\">&quot;书名：<span class=\"subst\">#&#123;<span class=\"variable\">@name</span>&#125;</span>&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">book = <span class=\"title class_\">Book</span>.new(<span class=\"string\">&quot;《Ruby 元编程》&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">puts book.to_s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Open Class</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Book</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">pure_name</span></span><br><span class=\"line\">    <span class=\"variable\">@name</span>[<span class=\"number\">0</span>] == <span class=\"string\">&quot;《&quot;</span> &amp;&amp; <span class=\"variable\">@name</span>[-<span class=\"number\">1</span>] == <span class=\"string\">&quot;》&quot;</span> ? <span class=\"variable\">@name</span>[<span class=\"number\">1</span>..-<span class=\"number\">2</span>] : <span class=\"variable\">@name</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">puts book.pure_name</span><br></pre></td></tr></table></figure>\n\n<p>虽然重复定义了<code>Book</code>类，但后定义的<code>pure_name</code>方法被“加入”到了原有的类定义中。通过这种方式我们可以在任意位置对我们的代码进行扩展，这一技巧被称为<code>Monkey Patch</code>，以下是一个更实用一点的例子，我们打开了<code>Array</code>类。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过 Open Class 为数组添加一个用于求平均值的方法</span></span><br><span class=\"line\">arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Array</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">average</span></span><br><span class=\"line\">    sum / size</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">puts arr.average <span class=\"comment\"># 输出 5</span></span><br></pre></td></tr></table></figure>\n\n<p>除了扩展方法外，我们还可以通过这种手段使程序更具有表现力：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [...]</span><br><span class=\"line\"></span><br><span class=\"line\">arr.first <span class=\"comment\"># 等同于 arr[0]</span></span><br><span class=\"line\">arr.second <span class=\"comment\"># 等同于 arr[1]</span></span><br><span class=\"line\">arr.last <span class=\"comment\"># 等同于 arr[-1]</span></span><br></pre></td></tr></table></figure>\n\n<p>不过这种手段也容易带来问题，例如打开类以后覆盖了一个已有的方法，那么极容易导致其它位置的方法调用出现问题。</p>\n<h3 id=\"1-2-method-missing\"><a href=\"#1-2-method-missing\" class=\"headerlink\" title=\"1.2. method_missing\"></a>1.2. method_missing</h3><p><code>Ruby</code>对象在调用方法时，如果不能找到目标方法，则会尝试执行<code>method_missing</code>方法，我们可以将<code>method_missing</code>方法看作一层代理：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Array</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">method_missing</span>(<span class=\"params\">method</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> method</span><br><span class=\"line\">    <span class=\"keyword\">when</span> <span class=\"symbol\">:average</span></span><br><span class=\"line\">      sum / size</span><br><span class=\"line\">    <span class=\"keyword\">when</span> <span class=\"symbol\">:to_binary</span></span><br><span class=\"line\">      map&#123; |<span class=\"params\">num</span>| num.to_s(<span class=\"number\">2</span>) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr = (<span class=\"number\">1</span>..<span class=\"number\">10</span>).to_a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如下两个方法都没有直接在 Array 类中定义，而是在查询方法失败以后通过 method_missing 方法进行了处理</span></span><br><span class=\"line\">puts arr.average <span class=\"comment\"># 返回 5</span></span><br><span class=\"line\">puts arr.to_binary <span class=\"comment\"># 返回数组元素转为二进制之后组成的数组</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-基于prototype和proxy尝试JavaScript元编程\"><a href=\"#2-基于prototype和proxy尝试JavaScript元编程\" class=\"headerlink\" title=\"2. 基于prototype和proxy尝试JavaScript元编程\"></a>2. 基于prototype和proxy尝试JavaScript元编程</h2><p>我们知道<code>JavaScript</code>的类实际上是借由<code>prototype</code>实现的语法糖，利用<code>prototype</code>一样可以实现类似于上述的<code>Open Class</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> indexAlias = &#123;</span><br><span class=\"line\">    <span class=\"attr\">first</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">second</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">third</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">fourth</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"attr\">fifth</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"attr\">sixth</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">    <span class=\"attr\">seventh</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"attr\">eighth</span>: <span class=\"number\">7</span>,</span><br><span class=\"line\">    <span class=\"attr\">ninth</span>: <span class=\"number\">8</span>,</span><br><span class=\"line\">    <span class=\"attr\">tenth</span>: <span class=\"number\">9</span>,</span><br><span class=\"line\">    <span class=\"attr\">twentieth</span>: <span class=\"number\">19</span>,</span><br><span class=\"line\">    <span class=\"attr\">thirtieth</span>: <span class=\"number\">29</span>,</span><br><span class=\"line\">    <span class=\"attr\">last</span>: -<span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(indexAlias).<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">alias</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>[alias] = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> index = indexAlias[alias] === -<span class=\"number\">1</span> ? <span class=\"variable language_\">this</span>.<span class=\"property\">length</span> - <span class=\"number\">1</span> : indexAlias[alias];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> testArr = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(<span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"number\">100</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testArr.<span class=\"title function_\">first</span>()); <span class=\"comment\">// 等同于 testArr[0]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testArr.<span class=\"title function_\">second</span>()); <span class=\"comment\">// 等同于 testArr[1]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testArr.<span class=\"title function_\">third</span>()); <span class=\"comment\">// 等同于 testArr[2]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testArr.<span class=\"title function_\">last</span>()); <span class=\"comment\">// 等同于 testArr[3]</span></span><br></pre></td></tr></table></figure>\n\n<p>上述例子动态的为数组类扩展了多个<strong>类似的</strong>方法。</p>\n<p>不过这里有一个小细节，其实我并不一定需要所有的方法，有时候可能到头来只调用了<code>first</code>和<code>last</code>方法，但这些方法却实实在在的都挂到了<code>prototype</code>上。</p>\n<p>基于代理来实现的方法动态定义其实可以解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> customArr = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(arr, &#123;</span><br><span class=\"line\">    <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\">target, prop, receiver</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title class_\">Reflect</span>.<span class=\"title function_\">has</span>(target, prop)) <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(...<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (prop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;average&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">sum, item</span>) =&gt;</span> sum + item, <span class=\"number\">0</span>) / <span class=\"variable language_\">this</span>.<span class=\"property\">length</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(customArr.<span class=\"title function_\">average</span>());</span><br></pre></td></tr></table></figure>\n\n<p>需要注意几点细节：</p>\n<ol>\n<li>此处通过代理扩展的是<strong>实例方法而非类方法</strong>。</li>\n<li>考虑到数组和对象都可以用字面量的方式完成初始化，打开<code>Array/Object</code>类的时候，或许<code>prototype</code>会更管用一些，因为<strong>prototype修改的是原有的类而代理是创建新的类</strong>。</li>\n</ol>\n<p>当然，完全可以将<code>average</code>方法直接放到<code>prototype</code>上，但如果我们要定义的是多个存在联系的方法，使用这种代理会灵活的多，关于这一点，接下来要尝试实现的<code>active_record</code>动态查找可能是一个不错的案例。</p>\n<h2 id=\"3-基于Proxy实现active-record动态查找\"><a href=\"#3-基于Proxy实现active-record动态查找\" class=\"headerlink\" title=\"3. 基于Proxy实现active_record动态查找\"></a>3. 基于Proxy实现active_record动态查找</h2><p><code>active_record</code>是<code>Ruby On Rails</code>中的<code>ORM</code>库，它有一个非常有用的魔法：假设存在一张数据表<code>users</code>，它有三个字段：</p>\n<ul>\n<li><code>username</code></li>\n<li><code>nickname</code></li>\n<li><code>email</code></li>\n</ul>\n<p>根据以往我们对<code>ORM</code>的理解，此时需要创建一个实体类，且这个实体类一眼两个需要声明上述的三个属性。不过，在<code>ActiveRecord</code>里，创建实体类你只需要继承<code>ActiveRecord</code>即可，它会自动的添加类属性，同时还有包括如下三个方法在内的大量数据读写方法：</p>\n<ul>\n<li><code>find_by_username</code></li>\n<li><code>find_by_nickname</code></li>\n<li><code>find_by_email</code></li>\n</ul>\n<p>其原理是根据数据表的字段名列表动态定义了各字段的查询方法。</p>\n<p><code>JavaScript</code>基于代理也可以实现类似的效果，下面的示例代码没有真正的链接数据库，而是使用了一个对象结构来进行模拟，同时为了让示例看起来像那么回事儿，还实现了<code>active_record</code>持久化数据的两个方法<code>save/create</code>。</p>\n<p>先来看看最终的效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ActiveRecord</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./ActiveRecord&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 初始化一个数据源（模拟数据库）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">DB</span> = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">ActiveRecord</span>.<span class=\"title function_\">init</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">db</span>: <span class=\"variable constant_\">DB</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">ActiveRecord</span> &#123; <span class=\"comment\">// 2. 定义一个实体类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3.1 创建一条数据的方式1： 实例化一个对象然后调用 save 方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> yuchi = <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">userName</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">password</span>: <span class=\"string\">&#x27;123456&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">nickName</span>: <span class=\"string\">&#x27;鱼翅&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">yuchi.<span class=\"title function_\">save</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3.2 创建一条数据的方式2： 直接使用 create 类方法</span></span><br><span class=\"line\"><span class=\"title class_\">User</span>.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">userName</span>: <span class=\"string\">&#x27;xiaoming&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">password</span>: <span class=\"string\">&#x27;11111&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">nickName</span>: <span class=\"string\">&#x27;小明&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 查看虚拟的数据库数据 </span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable constant_\">DB</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 通过属性生成的动态查询方法进行查询</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">User</span>.<span class=\"title function_\">findByUserName</span>(<span class=\"string\">&#x27;yuchi&#x27;</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">User</span>.<span class=\"title function_\">findByNickName</span>(<span class=\"string\">&#x27;小明&#x27;</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">User</span>.<span class=\"title function_\">findByPassword</span>(<span class=\"string\">&#x27;11111&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再创建一个</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Book</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">ActiveRecord</span> &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Book</span>.<span class=\"title function_\">create</span>(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;《我们的土地》&#x27;</span>, <span class=\"attr\">author</span>: <span class=\"string\">&#x27;[墨西哥] 卡洛斯·富恩特斯&#x27;</span>, <span class=\"attr\">pageTotal</span>: <span class=\"string\">&#x27;1036&#x27;</span>, <span class=\"attr\">price</span>: <span class=\"string\">&#x27;168&#x27;</span>, <span class=\"attr\">ISBN</span>: <span class=\"string\">&#x27;9787521211542&#x27;</span> &#125;);</span><br><span class=\"line\"><span class=\"title class_\">Book</span>.<span class=\"title function_\">create</span>(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;《戛纳往事》&#x27;</span>, <span class=\"attr\">author</span>: <span class=\"string\">&#x27;[法]吉尔·雅各布&#x27;</span>, <span class=\"attr\">pageTotal</span>: <span class=\"string\">&#x27;712&#x27;</span>, <span class=\"attr\">price</span>: <span class=\"string\">&#x27;148&#x27;</span>, <span class=\"attr\">ISBN</span>: <span class=\"string\">&#x27;9787308211208&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;查询结果：&#x27;</span>, <span class=\"title class_\">Book</span>.<span class=\"title function_\">findByName</span>(<span class=\"string\">&#x27;《戛纳往事》&#x27;</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;查询结果：&#x27;</span>, <span class=\"title class_\">Book</span>.<span class=\"title function_\">findByAuthor</span>(<span class=\"string\">&#x27;[法]吉尔·雅各布&#x27;</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;查询结果：&#x27;</span>, <span class=\"title class_\">Book</span>.<span class=\"title function_\">findByPageTotal</span>(<span class=\"string\">&#x27;712&#x27;</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;查询结果：&#x27;</span>, <span class=\"title class_\">Book</span>.<span class=\"title function_\">findByPrice</span>(<span class=\"string\">&#x27;168&#x27;</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;查询结果：&#x27;</span>, <span class=\"title class_\">Book</span>.<span class=\"title function_\">findByISBN</span>(<span class=\"string\">&#x27;9787308211208&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>以下是<code>ActiveRecord</code>类的实现，它有如下细节：</p>\n<ol>\n<li><code>ActiveRecord</code>是一个经过代理的类。</li>\n<li>创建一个<code>ActiveRecord</code>类的子类，然后初始化，实际调用的是父类的构造函数，同时也会触发代理（注意<code>Proxy</code>里的代码，为了保证返回的对象依然是子类对象，手动修改了构造函数指向）。</li>\n<li><code>ActiveRecord</code>类经过代理后，增加了动态查询类方法。</li>\n<li><code>ActiveRecord</code>类的子类实例化后得到的也是一个经过代理的对象，代理中实现了一些实例方法。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义基础的 ActiveRecord 抽象类，并支持动态的初始化实例属性</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BaseActiveRecord</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">record</span>) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(record).<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"variable language_\">this</span>[item] = record[item])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 一个用于验证代理后的类依然可以被继承的基础方法，也顺便用于数据序列化以便于存到 DB 中</span></span><br><span class=\"line\">    <span class=\"title function_\">toJSON</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> res = &#123;&#125;;</span><br><span class=\"line\">        <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(<span class=\"variable language_\">this</span>).<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> res[item] = <span class=\"variable language_\">this</span>[item]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理基础 ActiveRecord 类</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ActiveRecord</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(<span class=\"title class_\">BaseActiveRecord</span>, &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 代理构造方法，主要意图在希望实例化以后返回的 AR 对象一样是被代理过的</span></span><br><span class=\"line\">    <span class=\"attr\">construct</span>: <span class=\"keyword\">function</span> (<span class=\"params\">target, args, newTarget</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> nativeObj = <span class=\"keyword\">new</span> <span class=\"title function_\">target</span>(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        nativeObj.<span class=\"property\">__proto__</span> = newTarget.<span class=\"property\"><span class=\"keyword\">prototype</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(nativeObj, &#123;</span><br><span class=\"line\">            <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\">obj, prop</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"title class_\">Reflect</span>.<span class=\"title function_\">has</span>(obj, prop)) <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(...<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (prop !== <span class=\"string\">&#x27;save&#x27;</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">`<span class=\"subst\">$&#123;prop&#125;</span> is not a function!`</span>)</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 定义了一个 save 方法，自动根据实体类的名字将数据存到对应的表里</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">const</span> tableName = obj.<span class=\"property\">__proto__</span>.<span class=\"property\">constructor</span>.<span class=\"property\">name</span>.<span class=\"title function_\">toLowerCase</span>() + <span class=\"string\">&#x27;s&#x27;</span>;</span><br><span class=\"line\">                    <span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName] = (<span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName] || []);</span><br><span class=\"line\">                    <span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName].<span class=\"title function_\">push</span>(<span class=\"variable language_\">this</span>.<span class=\"title function_\">toJSON</span>());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 代理类属性和方法</span></span><br><span class=\"line\">    <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\">obj, prop, receiver</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title class_\">Reflect</span>.<span class=\"title function_\">has</span>(obj, prop)) <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(...<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> tableName = receiver.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span>.<span class=\"property\">name</span>.<span class=\"title function_\">toLowerCase</span>() + <span class=\"string\">&#x27;s&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (prop) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 定义一个 create 方法，基本与 save 方法相同</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;create&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                    <span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName] = (<span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName] || []);</span><br><span class=\"line\">                    <span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName].<span class=\"title function_\">push</span>(<span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            <span class=\"attr\">default</span>:</span><br><span class=\"line\">                <span class=\"comment\">// 根据属性动态定义 findByAttr 方法</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (prop.<span class=\"title function_\">startsWith</span>(<span class=\"string\">&#x27;findBy&#x27;</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">const</span> attr = prop.<span class=\"title function_\">slice</span>(prop.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;findBy&#x27;</span>) + <span class=\"number\">6</span>, prop.<span class=\"property\">length</span>).<span class=\"title function_\">toLowerCase</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName].<span class=\"title function_\">filter</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item[<span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(item).<span class=\"title function_\">filter</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.<span class=\"title function_\">toLowerCase</span>() === attr)[<span class=\"number\">0</span>]] === <span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用来初始化 DB 数据源的配置</span></span><br><span class=\"line\"><span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">init</span> = <span class=\"keyword\">function</span> (<span class=\"params\">option</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span> = option.<span class=\"property\">db</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title class_\">ActiveRecord</span>;</span><br></pre></td></tr></table></figure>\n\n<p>代码：<br><a href=\"https://github.com/yuchiXiong/activeRecordByProxy\">yuchiXiong&#x2F;activeRecordByProxy</a></p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"JavaScript元编程——基于Proxy实现active-record动态查找\"><a href=\"#JavaScript元编程——基于Proxy实现active-record动态查找\" class=\"headerlink\" title=\"JavaScript元编程——基于Proxy实现active_record动态查找\"></a>JavaScript元编程——基于Proxy实现active_record动态查找</h1><h2 id=\"1-元编程\"><a href=\"#1-元编程\" class=\"headerlink\" title=\"1. 元编程\"></a>1. 元编程</h2><p>在网络上无意间看到《JavaScript权威指南》第七版的目录，除了<code>NodeJS</code>外，很意外的看到有一个章节叫元编程。</p>\n<p>第一次听说元编程这一概念还是来自于<code>Ruby</code>，《Ruby元编程》这本书，很遗憾的是这本书我只看了一点点……对于元编程，我所掌握的也就只有<code>Open Class</code>和<code>method_missing</code>而已了，不过本文也就只是使用了这么点简单的内容。</p>\n<h3 id=\"1-1-Open-Class\"><a href=\"#1-1-Open-Class\" class=\"headerlink\" title=\"1.1 Open Class\"></a>1.1 Open Class</h3><p>在很多面向对象的语言里是无法修改一个类的，但在<code>Ruby</code>中如下代码是合法的：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Book</span></span><br><span class=\"line\">  <span class=\"keyword\">attr_accessor</span> <span class=\"symbol\">:name</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">initialize</span>(<span class=\"params\">name</span>)</span><br><span class=\"line\">    <span class=\"variable\">@name</span> = name</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">to_s</span></span><br><span class=\"line\">    <span class=\"string\">&quot;书名：<span class=\"subst\">#&#123;<span class=\"variable\">@name</span>&#125;</span>&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">book = <span class=\"title class_\">Book</span>.new(<span class=\"string\">&quot;《Ruby 元编程》&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">puts book.to_s</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Open Class</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Book</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">pure_name</span></span><br><span class=\"line\">    <span class=\"variable\">@name</span>[<span class=\"number\">0</span>] == <span class=\"string\">&quot;《&quot;</span> &amp;&amp; <span class=\"variable\">@name</span>[-<span class=\"number\">1</span>] == <span class=\"string\">&quot;》&quot;</span> ? <span class=\"variable\">@name</span>[<span class=\"number\">1</span>..-<span class=\"number\">2</span>] : <span class=\"variable\">@name</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">puts book.pure_name</span><br></pre></td></tr></table></figure>\n\n<p>虽然重复定义了<code>Book</code>类，但后定义的<code>pure_name</code>方法被“加入”到了原有的类定义中。通过这种方式我们可以在任意位置对我们的代码进行扩展，这一技巧被称为<code>Monkey Patch</code>，以下是一个更实用一点的例子，我们打开了<code>Array</code>类。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通过 Open Class 为数组添加一个用于求平均值的方法</span></span><br><span class=\"line\">arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Array</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">average</span></span><br><span class=\"line\">    sum / size</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">puts arr.average <span class=\"comment\"># 输出 5</span></span><br></pre></td></tr></table></figure>\n\n<p>除了扩展方法外，我们还可以通过这种手段使程序更具有表现力：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [...]</span><br><span class=\"line\"></span><br><span class=\"line\">arr.first <span class=\"comment\"># 等同于 arr[0]</span></span><br><span class=\"line\">arr.second <span class=\"comment\"># 等同于 arr[1]</span></span><br><span class=\"line\">arr.last <span class=\"comment\"># 等同于 arr[-1]</span></span><br></pre></td></tr></table></figure>\n\n<p>不过这种手段也容易带来问题，例如打开类以后覆盖了一个已有的方法，那么极容易导致其它位置的方法调用出现问题。</p>\n<h3 id=\"1-2-method-missing\"><a href=\"#1-2-method-missing\" class=\"headerlink\" title=\"1.2. method_missing\"></a>1.2. method_missing</h3><p><code>Ruby</code>对象在调用方法时，如果不能找到目标方法，则会尝试执行<code>method_missing</code>方法，我们可以将<code>method_missing</code>方法看作一层代理：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Array</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">method_missing</span>(<span class=\"params\">method</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> method</span><br><span class=\"line\">    <span class=\"keyword\">when</span> <span class=\"symbol\">:average</span></span><br><span class=\"line\">      sum / size</span><br><span class=\"line\">    <span class=\"keyword\">when</span> <span class=\"symbol\">:to_binary</span></span><br><span class=\"line\">      map&#123; |<span class=\"params\">num</span>| num.to_s(<span class=\"number\">2</span>) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr = (<span class=\"number\">1</span>..<span class=\"number\">10</span>).to_a</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如下两个方法都没有直接在 Array 类中定义，而是在查询方法失败以后通过 method_missing 方法进行了处理</span></span><br><span class=\"line\">puts arr.average <span class=\"comment\"># 返回 5</span></span><br><span class=\"line\">puts arr.to_binary <span class=\"comment\"># 返回数组元素转为二进制之后组成的数组</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-基于prototype和proxy尝试JavaScript元编程\"><a href=\"#2-基于prototype和proxy尝试JavaScript元编程\" class=\"headerlink\" title=\"2. 基于prototype和proxy尝试JavaScript元编程\"></a>2. 基于prototype和proxy尝试JavaScript元编程</h2><p>我们知道<code>JavaScript</code>的类实际上是借由<code>prototype</code>实现的语法糖，利用<code>prototype</code>一样可以实现类似于上述的<code>Open Class</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> indexAlias = &#123;</span><br><span class=\"line\">    <span class=\"attr\">first</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">second</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">third</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">fourth</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"attr\">fifth</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"attr\">sixth</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">    <span class=\"attr\">seventh</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"attr\">eighth</span>: <span class=\"number\">7</span>,</span><br><span class=\"line\">    <span class=\"attr\">ninth</span>: <span class=\"number\">8</span>,</span><br><span class=\"line\">    <span class=\"attr\">tenth</span>: <span class=\"number\">9</span>,</span><br><span class=\"line\">    <span class=\"attr\">twentieth</span>: <span class=\"number\">19</span>,</span><br><span class=\"line\">    <span class=\"attr\">thirtieth</span>: <span class=\"number\">29</span>,</span><br><span class=\"line\">    <span class=\"attr\">last</span>: -<span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(indexAlias).<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">alias</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>[alias] = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> index = indexAlias[alias] === -<span class=\"number\">1</span> ? <span class=\"variable language_\">this</span>.<span class=\"property\">length</span> - <span class=\"number\">1</span> : indexAlias[alias];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> testArr = <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(<span class=\"title class_\">Array</span>.<span class=\"title function_\">from</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Array</span>(<span class=\"number\">100</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testArr.<span class=\"title function_\">first</span>()); <span class=\"comment\">// 等同于 testArr[0]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testArr.<span class=\"title function_\">second</span>()); <span class=\"comment\">// 等同于 testArr[1]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testArr.<span class=\"title function_\">third</span>()); <span class=\"comment\">// 等同于 testArr[2]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(testArr.<span class=\"title function_\">last</span>()); <span class=\"comment\">// 等同于 testArr[3]</span></span><br></pre></td></tr></table></figure>\n\n<p>上述例子动态的为数组类扩展了多个<strong>类似的</strong>方法。</p>\n<p>不过这里有一个小细节，其实我并不一定需要所有的方法，有时候可能到头来只调用了<code>first</code>和<code>last</code>方法，但这些方法却实实在在的都挂到了<code>prototype</code>上。</p>\n<p>基于代理来实现的方法动态定义其实可以解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> customArr = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(arr, &#123;</span><br><span class=\"line\">    <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\">target, prop, receiver</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title class_\">Reflect</span>.<span class=\"title function_\">has</span>(target, prop)) <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(...<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (prop) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;average&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">sum, item</span>) =&gt;</span> sum + item, <span class=\"number\">0</span>) / <span class=\"variable language_\">this</span>.<span class=\"property\">length</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(customArr.<span class=\"title function_\">average</span>());</span><br></pre></td></tr></table></figure>\n\n<p>需要注意几点细节：</p>\n<ol>\n<li>此处通过代理扩展的是<strong>实例方法而非类方法</strong>。</li>\n<li>考虑到数组和对象都可以用字面量的方式完成初始化，打开<code>Array/Object</code>类的时候，或许<code>prototype</code>会更管用一些，因为<strong>prototype修改的是原有的类而代理是创建新的类</strong>。</li>\n</ol>\n<p>当然，完全可以将<code>average</code>方法直接放到<code>prototype</code>上，但如果我们要定义的是多个存在联系的方法，使用这种代理会灵活的多，关于这一点，接下来要尝试实现的<code>active_record</code>动态查找可能是一个不错的案例。</p>\n<h2 id=\"3-基于Proxy实现active-record动态查找\"><a href=\"#3-基于Proxy实现active-record动态查找\" class=\"headerlink\" title=\"3. 基于Proxy实现active_record动态查找\"></a>3. 基于Proxy实现active_record动态查找</h2><p><code>active_record</code>是<code>Ruby On Rails</code>中的<code>ORM</code>库，它有一个非常有用的魔法：假设存在一张数据表<code>users</code>，它有三个字段：</p>\n<ul>\n<li><code>username</code></li>\n<li><code>nickname</code></li>\n<li><code>email</code></li>\n</ul>\n<p>根据以往我们对<code>ORM</code>的理解，此时需要创建一个实体类，且这个实体类一眼两个需要声明上述的三个属性。不过，在<code>ActiveRecord</code>里，创建实体类你只需要继承<code>ActiveRecord</code>即可，它会自动的添加类属性，同时还有包括如下三个方法在内的大量数据读写方法：</p>\n<ul>\n<li><code>find_by_username</code></li>\n<li><code>find_by_nickname</code></li>\n<li><code>find_by_email</code></li>\n</ul>\n<p>其原理是根据数据表的字段名列表动态定义了各字段的查询方法。</p>\n<p><code>JavaScript</code>基于代理也可以实现类似的效果，下面的示例代码没有真正的链接数据库，而是使用了一个对象结构来进行模拟，同时为了让示例看起来像那么回事儿，还实现了<code>active_record</code>持久化数据的两个方法<code>save/create</code>。</p>\n<p>先来看看最终的效果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ActiveRecord</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./ActiveRecord&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 初始化一个数据源（模拟数据库）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">DB</span> = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">ActiveRecord</span>.<span class=\"title function_\">init</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">db</span>: <span class=\"variable constant_\">DB</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">ActiveRecord</span> &#123; <span class=\"comment\">// 2. 定义一个实体类</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3.1 创建一条数据的方式1： 实例化一个对象然后调用 save 方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> yuchi = <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">userName</span>: <span class=\"string\">&#x27;yuchi&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">password</span>: <span class=\"string\">&#x27;123456&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">nickName</span>: <span class=\"string\">&#x27;鱼翅&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">yuchi.<span class=\"title function_\">save</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3.2 创建一条数据的方式2： 直接使用 create 类方法</span></span><br><span class=\"line\"><span class=\"title class_\">User</span>.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">userName</span>: <span class=\"string\">&#x27;xiaoming&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">password</span>: <span class=\"string\">&#x27;11111&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">nickName</span>: <span class=\"string\">&#x27;小明&#x27;</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 查看虚拟的数据库数据 </span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable constant_\">DB</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 通过属性生成的动态查询方法进行查询</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">User</span>.<span class=\"title function_\">findByUserName</span>(<span class=\"string\">&#x27;yuchi&#x27;</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">User</span>.<span class=\"title function_\">findByNickName</span>(<span class=\"string\">&#x27;小明&#x27;</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">User</span>.<span class=\"title function_\">findByPassword</span>(<span class=\"string\">&#x27;11111&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 再创建一个</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Book</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">ActiveRecord</span> &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Book</span>.<span class=\"title function_\">create</span>(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;《我们的土地》&#x27;</span>, <span class=\"attr\">author</span>: <span class=\"string\">&#x27;[墨西哥] 卡洛斯·富恩特斯&#x27;</span>, <span class=\"attr\">pageTotal</span>: <span class=\"string\">&#x27;1036&#x27;</span>, <span class=\"attr\">price</span>: <span class=\"string\">&#x27;168&#x27;</span>, <span class=\"attr\">ISBN</span>: <span class=\"string\">&#x27;9787521211542&#x27;</span> &#125;);</span><br><span class=\"line\"><span class=\"title class_\">Book</span>.<span class=\"title function_\">create</span>(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;《戛纳往事》&#x27;</span>, <span class=\"attr\">author</span>: <span class=\"string\">&#x27;[法]吉尔·雅各布&#x27;</span>, <span class=\"attr\">pageTotal</span>: <span class=\"string\">&#x27;712&#x27;</span>, <span class=\"attr\">price</span>: <span class=\"string\">&#x27;148&#x27;</span>, <span class=\"attr\">ISBN</span>: <span class=\"string\">&#x27;9787308211208&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;查询结果：&#x27;</span>, <span class=\"title class_\">Book</span>.<span class=\"title function_\">findByName</span>(<span class=\"string\">&#x27;《戛纳往事》&#x27;</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;查询结果：&#x27;</span>, <span class=\"title class_\">Book</span>.<span class=\"title function_\">findByAuthor</span>(<span class=\"string\">&#x27;[法]吉尔·雅各布&#x27;</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;查询结果：&#x27;</span>, <span class=\"title class_\">Book</span>.<span class=\"title function_\">findByPageTotal</span>(<span class=\"string\">&#x27;712&#x27;</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;查询结果：&#x27;</span>, <span class=\"title class_\">Book</span>.<span class=\"title function_\">findByPrice</span>(<span class=\"string\">&#x27;168&#x27;</span>));</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;查询结果：&#x27;</span>, <span class=\"title class_\">Book</span>.<span class=\"title function_\">findByISBN</span>(<span class=\"string\">&#x27;9787308211208&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>以下是<code>ActiveRecord</code>类的实现，它有如下细节：</p>\n<ol>\n<li><code>ActiveRecord</code>是一个经过代理的类。</li>\n<li>创建一个<code>ActiveRecord</code>类的子类，然后初始化，实际调用的是父类的构造函数，同时也会触发代理（注意<code>Proxy</code>里的代码，为了保证返回的对象依然是子类对象，手动修改了构造函数指向）。</li>\n<li><code>ActiveRecord</code>类经过代理后，增加了动态查询类方法。</li>\n<li><code>ActiveRecord</code>类的子类实例化后得到的也是一个经过代理的对象，代理中实现了一些实例方法。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义基础的 ActiveRecord 抽象类，并支持动态的初始化实例属性</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BaseActiveRecord</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">record</span>) &#123;</span><br><span class=\"line\">        <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(record).<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"variable language_\">this</span>[item] = record[item])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 一个用于验证代理后的类依然可以被继承的基础方法，也顺便用于数据序列化以便于存到 DB 中</span></span><br><span class=\"line\">    <span class=\"title function_\">toJSON</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> res = &#123;&#125;;</span><br><span class=\"line\">        <span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(<span class=\"variable language_\">this</span>).<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> res[item] = <span class=\"variable language_\">this</span>[item]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代理基础 ActiveRecord 类</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ActiveRecord</span> = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(<span class=\"title class_\">BaseActiveRecord</span>, &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 代理构造方法，主要意图在希望实例化以后返回的 AR 对象一样是被代理过的</span></span><br><span class=\"line\">    <span class=\"attr\">construct</span>: <span class=\"keyword\">function</span> (<span class=\"params\">target, args, newTarget</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> nativeObj = <span class=\"keyword\">new</span> <span class=\"title function_\">target</span>(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        nativeObj.<span class=\"property\">__proto__</span> = newTarget.<span class=\"property\"><span class=\"keyword\">prototype</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(nativeObj, &#123;</span><br><span class=\"line\">            <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\">obj, prop</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"title class_\">Reflect</span>.<span class=\"title function_\">has</span>(obj, prop)) <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(...<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (prop !== <span class=\"string\">&#x27;save&#x27;</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">`<span class=\"subst\">$&#123;prop&#125;</span> is not a function!`</span>)</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 定义了一个 save 方法，自动根据实体类的名字将数据存到对应的表里</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">const</span> tableName = obj.<span class=\"property\">__proto__</span>.<span class=\"property\">constructor</span>.<span class=\"property\">name</span>.<span class=\"title function_\">toLowerCase</span>() + <span class=\"string\">&#x27;s&#x27;</span>;</span><br><span class=\"line\">                    <span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName] = (<span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName] || []);</span><br><span class=\"line\">                    <span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName].<span class=\"title function_\">push</span>(<span class=\"variable language_\">this</span>.<span class=\"title function_\">toJSON</span>());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 代理类属性和方法</span></span><br><span class=\"line\">    <span class=\"attr\">get</span>: <span class=\"keyword\">function</span> (<span class=\"params\">obj, prop, receiver</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"title class_\">Reflect</span>.<span class=\"title function_\">has</span>(obj, prop)) <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(...<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">const</span> tableName = receiver.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span>.<span class=\"property\">name</span>.<span class=\"title function_\">toLowerCase</span>() + <span class=\"string\">&#x27;s&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (prop) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 定义一个 create 方法，基本与 save 方法相同</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;create&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                    <span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName] = (<span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName] || []);</span><br><span class=\"line\">                    <span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName].<span class=\"title function_\">push</span>(<span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            <span class=\"attr\">default</span>:</span><br><span class=\"line\">                <span class=\"comment\">// 根据属性动态定义 findByAttr 方法</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (prop.<span class=\"title function_\">startsWith</span>(<span class=\"string\">&#x27;findBy&#x27;</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">const</span> attr = prop.<span class=\"title function_\">slice</span>(prop.<span class=\"title function_\">indexOf</span>(<span class=\"string\">&#x27;findBy&#x27;</span>) + <span class=\"number\">6</span>, prop.<span class=\"property\">length</span>).<span class=\"title function_\">toLowerCase</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span>[tableName].<span class=\"title function_\">filter</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item[<span class=\"title class_\">Object</span>.<span class=\"title function_\">keys</span>(item).<span class=\"title function_\">filter</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.<span class=\"title function_\">toLowerCase</span>() === attr)[<span class=\"number\">0</span>]] === <span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用来初始化 DB 数据源的配置</span></span><br><span class=\"line\"><span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">init</span> = <span class=\"keyword\">function</span> (<span class=\"params\">option</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">ActiveRecord</span>.<span class=\"property\">db</span> = option.<span class=\"property\">db</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"title class_\">ActiveRecord</span>;</span><br></pre></td></tr></table></figure>\n\n<p>代码：<br><a href=\"https://github.com/yuchiXiong/activeRecordByProxy\">yuchiXiong&#x2F;activeRecordByProxy</a></p>\n"},{"_content":"# node-rsa与ruby openSSL的一点问题\n\n## 1. 问题描述\n最近和朋友做一个个人项目，期间希望使用非对称加密来实现前端加密用户名和密码，后端解密验证的功能。\n\n在第一版设计的时候前后端技术栈是`React + Express`，我们很快找到了[node-rsa](https://www.npmjs.com/package/node-rsa)这个包，由于前后端都是 `JavaScript`，使用同一个包之后这个问题很快解决了。\n\n但是后来因为一些事情导致了项目停滞了很久，之后再启动时我提出使用`Ruby on Rails`来快速完成后端，迁移的过程在其他方面都还算比较顺利，唯独在重写非对称加密的时候卡壳了，使用统一签发的证书，前端加密后后端怎么都解不开。\n\n前端参考代码：\n~~~ JavaScript\nconst NodeRSA = require('node-rsa');\nconst obj = {\n  public_key: \"-----BEGIN PUBLIC KEY-----太长省略-----END PUBLIC KEY-----\"\n};\n\nlet key = new NodeRSA(obj.public_key);\n\nconst encode = key.encrypt({\n  account: '...',\n  password: '...'\n}, 'base64');\n~~~\n后端参考代码：\n~~~ruby\nkey = params[:key]\n\nrsa_client = OpenSSL::PKey::RSA.new Rails.application.credentials[:private_key]\n\naccount_obj = JSON.parse(rsa_client.private_decrypt(key))\naccount = account_obj['account']\npassword = account_obj['password']\n~~~\n\n使用上述代码无法完成解密。\n\n## 2. 解决方案\n无法完成解密主要原因有2个：\n1. 前端 `node-rsa` 库与后端 `OpenSSL::PKey::RSA` 库默认填充方式不一致。\n2. 前端加密后对密文进行了 `Base64` 再加密（可能是考虑到字节编码对传输的影响）。\n\n修改代码为如下，**前端指定了填充方式而后端对密文先进行了Base64解密**。\n\n前端参考代码：\n~~~ JavaScript\nconst NodeRSA = require('node-rsa');\nconst obj = {\n  public_key: \"-----BEGIN PUBLIC KEY-----太长省略-----END PUBLIC KEY-----\"\n};\n\nlet key = new NodeRSA(obj.public_key);\n\nkey.setOptions({ encryptionScheme: 'pkcs1' });\n\nconst encode = key.encrypt({\n  account: '...',\n  password: '...'\n}, 'base64');\n~~~\n后端参考代码：\n~~~ ruby\nkey = params[:key]\n\nrsa_client = OpenSSL::PKey::RSA.new Rails.application.credentials[:private_key]\n\naccount_obj = JSON.parse(rsa_client.private_decrypt(Base64.decode64(key)))\naccount = account_obj['account']\npassword = account_obj['password']\n~~~\n","source":"_posts/node-rsa与ruby-openSSL的一点问题.md","raw":"# node-rsa与ruby openSSL的一点问题\n\n## 1. 问题描述\n最近和朋友做一个个人项目，期间希望使用非对称加密来实现前端加密用户名和密码，后端解密验证的功能。\n\n在第一版设计的时候前后端技术栈是`React + Express`，我们很快找到了[node-rsa](https://www.npmjs.com/package/node-rsa)这个包，由于前后端都是 `JavaScript`，使用同一个包之后这个问题很快解决了。\n\n但是后来因为一些事情导致了项目停滞了很久，之后再启动时我提出使用`Ruby on Rails`来快速完成后端，迁移的过程在其他方面都还算比较顺利，唯独在重写非对称加密的时候卡壳了，使用统一签发的证书，前端加密后后端怎么都解不开。\n\n前端参考代码：\n~~~ JavaScript\nconst NodeRSA = require('node-rsa');\nconst obj = {\n  public_key: \"-----BEGIN PUBLIC KEY-----太长省略-----END PUBLIC KEY-----\"\n};\n\nlet key = new NodeRSA(obj.public_key);\n\nconst encode = key.encrypt({\n  account: '...',\n  password: '...'\n}, 'base64');\n~~~\n后端参考代码：\n~~~ruby\nkey = params[:key]\n\nrsa_client = OpenSSL::PKey::RSA.new Rails.application.credentials[:private_key]\n\naccount_obj = JSON.parse(rsa_client.private_decrypt(key))\naccount = account_obj['account']\npassword = account_obj['password']\n~~~\n\n使用上述代码无法完成解密。\n\n## 2. 解决方案\n无法完成解密主要原因有2个：\n1. 前端 `node-rsa` 库与后端 `OpenSSL::PKey::RSA` 库默认填充方式不一致。\n2. 前端加密后对密文进行了 `Base64` 再加密（可能是考虑到字节编码对传输的影响）。\n\n修改代码为如下，**前端指定了填充方式而后端对密文先进行了Base64解密**。\n\n前端参考代码：\n~~~ JavaScript\nconst NodeRSA = require('node-rsa');\nconst obj = {\n  public_key: \"-----BEGIN PUBLIC KEY-----太长省略-----END PUBLIC KEY-----\"\n};\n\nlet key = new NodeRSA(obj.public_key);\n\nkey.setOptions({ encryptionScheme: 'pkcs1' });\n\nconst encode = key.encrypt({\n  account: '...',\n  password: '...'\n}, 'base64');\n~~~\n后端参考代码：\n~~~ ruby\nkey = params[:key]\n\nrsa_client = OpenSSL::PKey::RSA.new Rails.application.credentials[:private_key]\n\naccount_obj = JSON.parse(rsa_client.private_decrypt(Base64.decode64(key)))\naccount = account_obj['account']\npassword = account_obj['password']\n~~~\n","slug":"node-rsa与ruby-openSSL的一点问题","published":1,"date":"2022-05-03T08:46:25.172Z","updated":"2022-05-03T08:46:25.172Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mduc001nr2ve5zomf03g","content":"<h1 id=\"node-rsa与ruby-openSSL的一点问题\"><a href=\"#node-rsa与ruby-openSSL的一点问题\" class=\"headerlink\" title=\"node-rsa与ruby openSSL的一点问题\"></a>node-rsa与ruby openSSL的一点问题</h1><h2 id=\"1-问题描述\"><a href=\"#1-问题描述\" class=\"headerlink\" title=\"1. 问题描述\"></a>1. 问题描述</h2><p>最近和朋友做一个个人项目，期间希望使用非对称加密来实现前端加密用户名和密码，后端解密验证的功能。</p>\n<p>在第一版设计的时候前后端技术栈是<code>React + Express</code>，我们很快找到了<a href=\"https://www.npmjs.com/package/node-rsa\">node-rsa</a>这个包，由于前后端都是 <code>JavaScript</code>，使用同一个包之后这个问题很快解决了。</p>\n<p>但是后来因为一些事情导致了项目停滞了很久，之后再启动时我提出使用<code>Ruby on Rails</code>来快速完成后端，迁移的过程在其他方面都还算比较顺利，唯独在重写非对称加密的时候卡壳了，使用统一签发的证书，前端加密后后端怎么都解不开。</p>\n<p>前端参考代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">NodeRSA</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;node-rsa&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">public_key</span>: <span class=\"string\">&quot;-----BEGIN PUBLIC KEY-----太长省略-----END PUBLIC KEY-----&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> key = <span class=\"keyword\">new</span> <span class=\"title class_\">NodeRSA</span>(obj.<span class=\"property\">public_key</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> encode = key.<span class=\"title function_\">encrypt</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">account</span>: <span class=\"string\">&#x27;...&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">password</span>: <span class=\"string\">&#x27;...&#x27;</span></span><br><span class=\"line\">&#125;, <span class=\"string\">&#x27;base64&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>后端参考代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key = params[<span class=\"symbol\">:key</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">rsa_client = <span class=\"title class_\">OpenSSL::PKey::RSA</span>.new Rails.application.credentials[<span class=\"symbol\">:private_key</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">account_obj = <span class=\"variable constant_\">JSON</span>.parse(rsa_client.private_decrypt(key))</span><br><span class=\"line\">account = account_obj[<span class=\"string\">&#x27;account&#x27;</span>]</span><br><span class=\"line\">password = account_obj[<span class=\"string\">&#x27;password&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>使用上述代码无法完成解密。</p>\n<h2 id=\"2-解决方案\"><a href=\"#2-解决方案\" class=\"headerlink\" title=\"2. 解决方案\"></a>2. 解决方案</h2><p>无法完成解密主要原因有2个：</p>\n<ol>\n<li>前端 <code>node-rsa</code> 库与后端 <code>OpenSSL::PKey::RSA</code> 库默认填充方式不一致。</li>\n<li>前端加密后对密文进行了 <code>Base64</code> 再加密（可能是考虑到字节编码对传输的影响）。</li>\n</ol>\n<p>修改代码为如下，<strong>前端指定了填充方式而后端对密文先进行了Base64解密</strong>。</p>\n<p>前端参考代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">NodeRSA</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;node-rsa&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">public_key</span>: <span class=\"string\">&quot;-----BEGIN PUBLIC KEY-----太长省略-----END PUBLIC KEY-----&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> key = <span class=\"keyword\">new</span> <span class=\"title class_\">NodeRSA</span>(obj.<span class=\"property\">public_key</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">key.<span class=\"title function_\">setOptions</span>(&#123; <span class=\"attr\">encryptionScheme</span>: <span class=\"string\">&#x27;pkcs1&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> encode = key.<span class=\"title function_\">encrypt</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">account</span>: <span class=\"string\">&#x27;...&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">password</span>: <span class=\"string\">&#x27;...&#x27;</span></span><br><span class=\"line\">&#125;, <span class=\"string\">&#x27;base64&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>后端参考代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key = params[<span class=\"symbol\">:key</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">rsa_client = <span class=\"title class_\">OpenSSL::PKey::RSA</span>.new Rails.application.credentials[<span class=\"symbol\">:private_key</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">account_obj = <span class=\"variable constant_\">JSON</span>.parse(rsa_client.private_decrypt(Base64.decode64(key)))</span><br><span class=\"line\">account = account_obj[<span class=\"string\">&#x27;account&#x27;</span>]</span><br><span class=\"line\">password = account_obj[<span class=\"string\">&#x27;password&#x27;</span>]</span><br></pre></td></tr></table></figure>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"node-rsa与ruby-openSSL的一点问题\"><a href=\"#node-rsa与ruby-openSSL的一点问题\" class=\"headerlink\" title=\"node-rsa与ruby openSSL的一点问题\"></a>node-rsa与ruby openSSL的一点问题</h1><h2 id=\"1-问题描述\"><a href=\"#1-问题描述\" class=\"headerlink\" title=\"1. 问题描述\"></a>1. 问题描述</h2><p>最近和朋友做一个个人项目，期间希望使用非对称加密来实现前端加密用户名和密码，后端解密验证的功能。</p>\n<p>在第一版设计的时候前后端技术栈是<code>React + Express</code>，我们很快找到了<a href=\"https://www.npmjs.com/package/node-rsa\">node-rsa</a>这个包，由于前后端都是 <code>JavaScript</code>，使用同一个包之后这个问题很快解决了。</p>\n<p>但是后来因为一些事情导致了项目停滞了很久，之后再启动时我提出使用<code>Ruby on Rails</code>来快速完成后端，迁移的过程在其他方面都还算比较顺利，唯独在重写非对称加密的时候卡壳了，使用统一签发的证书，前端加密后后端怎么都解不开。</p>\n<p>前端参考代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">NodeRSA</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;node-rsa&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">public_key</span>: <span class=\"string\">&quot;-----BEGIN PUBLIC KEY-----太长省略-----END PUBLIC KEY-----&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> key = <span class=\"keyword\">new</span> <span class=\"title class_\">NodeRSA</span>(obj.<span class=\"property\">public_key</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> encode = key.<span class=\"title function_\">encrypt</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">account</span>: <span class=\"string\">&#x27;...&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">password</span>: <span class=\"string\">&#x27;...&#x27;</span></span><br><span class=\"line\">&#125;, <span class=\"string\">&#x27;base64&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>后端参考代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key = params[<span class=\"symbol\">:key</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">rsa_client = <span class=\"title class_\">OpenSSL::PKey::RSA</span>.new Rails.application.credentials[<span class=\"symbol\">:private_key</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">account_obj = <span class=\"variable constant_\">JSON</span>.parse(rsa_client.private_decrypt(key))</span><br><span class=\"line\">account = account_obj[<span class=\"string\">&#x27;account&#x27;</span>]</span><br><span class=\"line\">password = account_obj[<span class=\"string\">&#x27;password&#x27;</span>]</span><br></pre></td></tr></table></figure>\n\n<p>使用上述代码无法完成解密。</p>\n<h2 id=\"2-解决方案\"><a href=\"#2-解决方案\" class=\"headerlink\" title=\"2. 解决方案\"></a>2. 解决方案</h2><p>无法完成解密主要原因有2个：</p>\n<ol>\n<li>前端 <code>node-rsa</code> 库与后端 <code>OpenSSL::PKey::RSA</code> 库默认填充方式不一致。</li>\n<li>前端加密后对密文进行了 <code>Base64</code> 再加密（可能是考虑到字节编码对传输的影响）。</li>\n</ol>\n<p>修改代码为如下，<strong>前端指定了填充方式而后端对密文先进行了Base64解密</strong>。</p>\n<p>前端参考代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">NodeRSA</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;node-rsa&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">public_key</span>: <span class=\"string\">&quot;-----BEGIN PUBLIC KEY-----太长省略-----END PUBLIC KEY-----&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> key = <span class=\"keyword\">new</span> <span class=\"title class_\">NodeRSA</span>(obj.<span class=\"property\">public_key</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">key.<span class=\"title function_\">setOptions</span>(&#123; <span class=\"attr\">encryptionScheme</span>: <span class=\"string\">&#x27;pkcs1&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> encode = key.<span class=\"title function_\">encrypt</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">account</span>: <span class=\"string\">&#x27;...&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">password</span>: <span class=\"string\">&#x27;...&#x27;</span></span><br><span class=\"line\">&#125;, <span class=\"string\">&#x27;base64&#x27;</span>);</span><br></pre></td></tr></table></figure>\n<p>后端参考代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key = params[<span class=\"symbol\">:key</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">rsa_client = <span class=\"title class_\">OpenSSL::PKey::RSA</span>.new Rails.application.credentials[<span class=\"symbol\">:private_key</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">account_obj = <span class=\"variable constant_\">JSON</span>.parse(rsa_client.private_decrypt(Base64.decode64(key)))</span><br><span class=\"line\">account = account_obj[<span class=\"string\">&#x27;account&#x27;</span>]</span><br><span class=\"line\">password = account_obj[<span class=\"string\">&#x27;password&#x27;</span>]</span><br></pre></td></tr></table></figure>\n"},{"_content":"# node-sass提示找不到python的解决方案\n\n**问题描述**\n\n安装`node-sass`时报错提示找不到`python`\n\n**解决方案**\n~~~ shell\nnpm install -g node-gyp\n~~~\n\n话说现在大概都用`dart-sass`了吧……","source":"_posts/node-sass提示找不到python的解决方案.md","raw":"# node-sass提示找不到python的解决方案\n\n**问题描述**\n\n安装`node-sass`时报错提示找不到`python`\n\n**解决方案**\n~~~ shell\nnpm install -g node-gyp\n~~~\n\n话说现在大概都用`dart-sass`了吧……","slug":"node-sass提示找不到python的解决方案","published":1,"date":"2022-05-03T08:46:25.182Z","updated":"2022-05-03T08:46:25.182Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdud001or2ve3xqaabaz","content":"<h1 id=\"node-sass提示找不到python的解决方案\"><a href=\"#node-sass提示找不到python的解决方案\" class=\"headerlink\" title=\"node-sass提示找不到python的解决方案\"></a>node-sass提示找不到python的解决方案</h1><p><strong>问题描述</strong></p>\n<p>安装<code>node-sass</code>时报错提示找不到<code>python</code></p>\n<p><strong>解决方案</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g node-gyp</span><br></pre></td></tr></table></figure>\n\n<p>话说现在大概都用<code>dart-sass</code>了吧……</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"node-sass提示找不到python的解决方案\"><a href=\"#node-sass提示找不到python的解决方案\" class=\"headerlink\" title=\"node-sass提示找不到python的解决方案\"></a>node-sass提示找不到python的解决方案</h1><p><strong>问题描述</strong></p>\n<p>安装<code>node-sass</code>时报错提示找不到<code>python</code></p>\n<p><strong>解决方案</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g node-gyp</span><br></pre></td></tr></table></figure>\n\n<p>话说现在大概都用<code>dart-sass</code>了吧……</p>\n"},{"_content":"# Servlet  + JSP 实现验证码\n\n使用Servlet+Jsp完成验证码主要有如下步骤\n1. 完成HTML页面的编写\n2. 完成生成随机验证码的Servlet\n3. 完成刷新更换验证码的功能\n4. 完成验证验证码是否正确是Servlet\n\n## 1. Html的编写\n\n页面结构相对比较简单，主要有`input-text`,`img`,`a`三种元素组成，`input-text`用于用户输入验证码，`img`用于显示验证码，而通常页面中都会用`a`标签来保证用户能更好的输入验证码。\n\n~~~jsp\n验证码：\n<input type=\"text\" name=\"CheckCode\">\n<img alt=\"验证码\" id=\"imagecode\" src=\"<%=request.getContextPath()%>/servlet/ImageServlet\"/>\n<a href=\"javascript:ReloadCode();\">看不清楚，换一张</a>\n~~~\n\n效果如图\n\n![预览](https://upload-images.jianshu.io/upload_images/13085799-9e6828c1708fb560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2. 完成生成随机验证码的Servlet\n\n我们使用Servlet来完成对应的功能，创建`ImageServlet`类并继承自`HttpServlet`类。编写`doGet()`方法\n\n~~~java\npackage com.yuchi;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.Random;\n\nimport javax.imageio.ImageIO;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class ImageServlet extends HttpServlet {\n\tpublic void doGet(HttpServletRequest Request,HttpServletResponse Response) throws IOException {\n\t\t//BufferedImage将图片存入缓存中，有三个构造方法，此处的三个参数为图片的宽，高，以及创建的图像类型。\n\t\tBufferedImage bi = new BufferedImage(68, 22, BufferedImage.TYPE_INT_RGB);\n\t\t//为bi创建图形上下文\n\t\tGraphics g = bi.getGraphics();\n\t\t//设置颜色，此处调用的构造方法是基于RGB数值作为参数的\n\t\tColor c = new Color(200, 150, 255);\n\t\t//设置颜色\t\t\t\n\t\tg.setColor(c);\n\t\t//该方法用于填充指定的矩形，参数是坐标和宽高\n\t\tg.fillRect(0, 0, 68, 22);\n\t\t\t\n\t\t//编写随机获取验证码的部分\n\t\t\t\n\t\t//将字符串转换为字符数组\n\t\tchar[] ch = \"abcdefghijklmnopqrstuvwxyz0123456789\".toCharArray();\n\t\t//随机类，在本程序中只使用了 int nextInt(int n) 方法，作用是生成一个0-n的伪随机int值\n\t\tRandom r = new Random();\n\t\t\t\n\t\tint len = ch.length,index;\n\t\t\t\n\t\t//用于存储随机生成的四位验证码\n\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t//从0-len随机获取一个作为下标\n\t\t\tindex = r.nextInt(len);\n\t\t\t//随机获取颜色\n\t\t\tg.setColor(new Color(r.nextInt(200), r.nextInt(150), r.nextInt(255)));\n\t\t\t\t\n\t\t\t//在图形中绘制指定的String，参数对应要绘制的String以及坐标\n\t\t\tg.drawString(ch[index] + \" \", (i * 15) + 3, 18);\n\t\t\t\t\n\t\t\t//将内容添加到StringBuffer\n\t\t\tsb.append(ch[index]);\n\t\t}\n\t\t\t\n\t\t//将验证码信息放入session中用于验证\n\t\tRequest.getSession().setAttribute(\"PicCode\", sb.toString());\n\t\t//将文件流输出，参数要写入的RenderedImage，输出的文件格式，输出到的ImageOutputStream\n\t\tImageIO.write(bi, \"JPG\", Response.getOutputStream());\n\t}\n}\n~~~\n## 2.5 关于`doGet()`方法中的内容详解（个人理解）\n~~~java\nBufferedImage bi = new BufferedImage(68, 22, BufferedImage.TYPE_INT_RGB);\n~~~\n\n查阅了API，`BufferedImage`类似乎用于将图片存入缓存中，在这里我们调用的构造方法有三个参数，分别对应图片的宽高和创建的图像格式。此处的`BufferedImage.TYPE_INT_RGB`是一个类成员属性。详见API\n\n![TYPE_INT_RGB](https://upload-images.jianshu.io/upload_images/13085799-8c3b2d8d99f38ccb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n~~~java\n//为bi创建图形上下文\nGraphics g = bi.getGraphics();\n//设置颜色，此处调用的构造方法是基于RGB数值作为参数的\nColor c = new Color(200, 150, 255);\n//设置颜色\t\t\t\ng.setColor(c);\n//该方法用于填充指定的矩形，参数是坐标和宽高\ng.fillRect(0, 0, 68, 22);\n~~~\n\nAPI上说“Graphics 类是所有图形上下文的抽象基类，允许应用程序在组件（已经在各种设备上实现）以及闭屏图像上进行绘制。 ”\n\n这里我认为其类似于MFC里那个`PDC`，获取了屏幕之后，所有的操作都是基于它的，这里的`Graphics`也是一样，关于颜色，大小等操作都是基于它进行设置的。\n\n即`setColor()`和`fillRect()`方法，前者的参数是一个`Color`类对象，该类有多重构造方法，而此处使用的是三个`int`数值，对应的是`RGB`数值大于0小于256.而后者则用于填充指定的矩形，参数是坐标和宽高。\n\n~~~java\n//编写随机获取验证码的部分\n\t\t\t\n//将字符串转换为字符数组\nchar[] ch = \"abcdefghijklmnopqrstuvwxyz0123456789\".toCharArray();\n~~~\n\n此处使用了`toCharArray()`方法将字符串转换为字符数组，如果不适用该方法，`char[] ch`是没有办法这样赋值的。\n\n~~~java\n//随机类，在本程序中只使用了 int nextInt(int n) 方法，作用是生成一个0-n的伪随机int值\nRandom r = new Random();\n~~~\n\nAPI中将`Random`称为伪随机，并称`Math.random()`更容易使用= =！\n\n![Random](https://upload-images.jianshu.io/upload_images/13085799-fba99a03c33efc09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n~~~java\nint len = ch.length, index;\n\t\t\t\n//用于存储随机生成的四位验证码\nStringBuffer sb = new StringBuffer();\n~~~\n\n定义了用于存储长度的`len`以及对应的下标`index `，并定义了`StringBuffer`类对象用来存储随机生成的验证码。\n\n~~~java\nfor(int i = 0; i < 4; i++) {\n\t//从0-len随机获取一个作为下标\n\tindex = r.nextInt(len);\n\t//随机获取颜色\n\tg.setColor(new Color(r.nextInt(200), r.nextInt(150), r.nextInt(255)));\n\t\t\t\t\n\t//在图形中绘制指定的String，参数对应要绘制的String以及坐标\n\tg.drawString(ch[index] + \" \",(i * 15) + 3, 18);\n\t\t\t\t\n\t//将内容添加到StringBuffer\n\tsb.append(ch[index]);\n}\n~~~\n\n使用for循环生成4次随机字符，`r.nextInt(int len)`方法用于生成一个随机的0~len之间的`int`变量。后面的获取颜色中也是如此使用。\n\n`void drawString(String str, int x,int y)`方法用于将指定文本绘制到图形中，参数分别对应指定的String文本，以及宽高。\n\n最后利用`StringBuffer.append()`方法将生成的字符添加到类对象`sb`中。\n\n~~~java\n//将验证码信息放入session中用于验证\nRequest.getSession().setAttribute(\"PicCode\", sb.toString());\n//将文件流输出，参数要写入的RenderedImage，输出的文件格式，输出到的ImageOutputStream\nImageIO.write(bi, \"JPG\", Response.getOutputStream());\n~~~\n\n创建session并添加`sb.toString()`用于实现判断\n\n最后一个方法是我觉得最迷的- -！`ImageIO.write()`方法，API中有三种构造方法，用于将`ImageWriter`按指定格式以三种不同方式输出。\n\n![ImageIO.write()方法](https://upload-images.jianshu.io/upload_images/13085799-c2d19e6dff79c306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n完成了如上代码的编写之后需要配置`servlet`打开`web.xml`添加如下代码。\n\n~~~xml\n<servlet>\n\t<servlet-name>ImageServlet</servlet-name>\n\t<servlet-class>com.yuchi.ImageServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n\t<servlet-name>ImageServlet</servlet-name>\n\t<url-pattern>/servlet/ImageServlet</url-pattern>\n</servlet-mapping>\n~~~\n部署后运行。\n\n![部署后运行](https://upload-images.jianshu.io/upload_images/13085799-bfd7dd83ae10413e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n到此处为止，随机生成验证码的功能就完成了。\n\n## 3. 完成刷新更换验证码的功能\n\n事实上我们在页面中使用验证码时往往容易出现验证码看不清的情况，因此我们需要有一个用户按钮使得验证码可以刷新，此处我们给`a`标签写上`JavaScript`以完成刷新功能的实现。\n\n~~~js\n<script type=\"text/javascript\">\n\tfunction ReloadCode(){\n\t\tvar time = new Date();\n\t\tdocument.getElementById(\"imagecode\").src = \"<%=request.getContextPath()%>/servlet/ImageServlet?d=\" + time;\n\t}\n</script>\n~~~\n\n此处使用了`document.getElementById()`获取到`img`标签之后，直接修改其`src`属性即可完成刷新，但IE浏览器似乎有一个缓存功能会使得刷新并不能生效，因此需要增加一个时间作为参数，使得每一次刷新的内容都不相同，这样IE才不会认为此次刷新是不需要的。\n\n到这里，整个用户界面就算完成了效果如图\n\n![效果预览](https://upload-images.jianshu.io/upload_images/13085799-6b87902c641c47f9.gif?imageMogr2/auto-orient/strip)\n\n## 4. 完成对验证码的验证功能\n\n其实验证功能的原理很简单，取出之前存入`Session`中的验证码，与用户的填入的验证码对比即可。\n\n新建`LoginServlet`类，同样继承自`HttpServlet`类\n~~~java\npackage com.yuchi;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class LoginServlet extends HttpServlet {\n\tpublic void doPost(HttpServletRequest Request,HttpServletResponse Response) throws IOException {\n\t\tString PicCode = (String) Request.getSession().getAttribute(\"PicCode\");\n\t\tString CheckCode = Request.getParameter(\"CheckCode\");\n\t\t\t\t\n\t\tCheckCode = CheckCode.toLowerCase();\n\t\t\t\t\n\t\tResponse.setContentType(\"text/html;charset=gbk\");\n\t\tPrintWriter out=Response.getWriter();\n\t\t\t\t\n\t\tif(CheckCode.equals(PicCode)) {\n\t\t\tout.print(\"正确！\");\n\t\t}else {\n\t\t\tout.print(\"错误！\");\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n}\n\n~~~\n\n这一次我们选择使用`post`传参，因此方法也变成了`doPost()`【实在因为我对get那种URL传参的方式有点厌恶……】。\n\n\n在类的编写中需要注意到几个问题\n- 验证码的大小写问题\n- 字符编码\n- 输出流的关闭\n\n因此在类中我们编写了一些用于解决这些问题的语句\n~~~java\n//将用户的验证码统一为小写\nCheckCode=CheckCode.toLowerCase();\n//设置页面的字符编码为gbk\nResponse.setContentType(\"text/html;charset=gbk\");\n//刷新流并关闭\nout.flush();\nout.close();\n~~~\n\n编写对应的Servlet并更改HTML结构\n\n~~~xml\n<servlet>\n\t<servlet-name>LoginServlet</servlet-name>\n\t<servlet-class>com.yuchi.LoginServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n\t<servlet-name>LoginServlet</servlet-name>\n\t<url-pattern>/servlet/LoginServlet</url-pattern>\n</servlet-mapping>\n~~~\n\n~~~jsp\n<form action=\"<%=request.getContextPath()%>/servlet/LoginServlet\" method=\"post\">\n\t......\n\t<input type=\"submit\" value=\"提交\">\n</form>\n~~~\n\n以上，一个基本的验证码功能就完成了。效果如图:\n\n![基本演示](https://upload-images.jianshu.io/upload_images/13085799-d6b2385e05c5f827.gif?imageMogr2/auto-orient/strip)\n","source":"_posts/servlet+jsp实现验证码.md","raw":"# Servlet  + JSP 实现验证码\n\n使用Servlet+Jsp完成验证码主要有如下步骤\n1. 完成HTML页面的编写\n2. 完成生成随机验证码的Servlet\n3. 完成刷新更换验证码的功能\n4. 完成验证验证码是否正确是Servlet\n\n## 1. Html的编写\n\n页面结构相对比较简单，主要有`input-text`,`img`,`a`三种元素组成，`input-text`用于用户输入验证码，`img`用于显示验证码，而通常页面中都会用`a`标签来保证用户能更好的输入验证码。\n\n~~~jsp\n验证码：\n<input type=\"text\" name=\"CheckCode\">\n<img alt=\"验证码\" id=\"imagecode\" src=\"<%=request.getContextPath()%>/servlet/ImageServlet\"/>\n<a href=\"javascript:ReloadCode();\">看不清楚，换一张</a>\n~~~\n\n效果如图\n\n![预览](https://upload-images.jianshu.io/upload_images/13085799-9e6828c1708fb560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2. 完成生成随机验证码的Servlet\n\n我们使用Servlet来完成对应的功能，创建`ImageServlet`类并继承自`HttpServlet`类。编写`doGet()`方法\n\n~~~java\npackage com.yuchi;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.Random;\n\nimport javax.imageio.ImageIO;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class ImageServlet extends HttpServlet {\n\tpublic void doGet(HttpServletRequest Request,HttpServletResponse Response) throws IOException {\n\t\t//BufferedImage将图片存入缓存中，有三个构造方法，此处的三个参数为图片的宽，高，以及创建的图像类型。\n\t\tBufferedImage bi = new BufferedImage(68, 22, BufferedImage.TYPE_INT_RGB);\n\t\t//为bi创建图形上下文\n\t\tGraphics g = bi.getGraphics();\n\t\t//设置颜色，此处调用的构造方法是基于RGB数值作为参数的\n\t\tColor c = new Color(200, 150, 255);\n\t\t//设置颜色\t\t\t\n\t\tg.setColor(c);\n\t\t//该方法用于填充指定的矩形，参数是坐标和宽高\n\t\tg.fillRect(0, 0, 68, 22);\n\t\t\t\n\t\t//编写随机获取验证码的部分\n\t\t\t\n\t\t//将字符串转换为字符数组\n\t\tchar[] ch = \"abcdefghijklmnopqrstuvwxyz0123456789\".toCharArray();\n\t\t//随机类，在本程序中只使用了 int nextInt(int n) 方法，作用是生成一个0-n的伪随机int值\n\t\tRandom r = new Random();\n\t\t\t\n\t\tint len = ch.length,index;\n\t\t\t\n\t\t//用于存储随机生成的四位验证码\n\t\tStringBuffer sb = new StringBuffer();\n\t\t\t\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t//从0-len随机获取一个作为下标\n\t\t\tindex = r.nextInt(len);\n\t\t\t//随机获取颜色\n\t\t\tg.setColor(new Color(r.nextInt(200), r.nextInt(150), r.nextInt(255)));\n\t\t\t\t\n\t\t\t//在图形中绘制指定的String，参数对应要绘制的String以及坐标\n\t\t\tg.drawString(ch[index] + \" \", (i * 15) + 3, 18);\n\t\t\t\t\n\t\t\t//将内容添加到StringBuffer\n\t\t\tsb.append(ch[index]);\n\t\t}\n\t\t\t\n\t\t//将验证码信息放入session中用于验证\n\t\tRequest.getSession().setAttribute(\"PicCode\", sb.toString());\n\t\t//将文件流输出，参数要写入的RenderedImage，输出的文件格式，输出到的ImageOutputStream\n\t\tImageIO.write(bi, \"JPG\", Response.getOutputStream());\n\t}\n}\n~~~\n## 2.5 关于`doGet()`方法中的内容详解（个人理解）\n~~~java\nBufferedImage bi = new BufferedImage(68, 22, BufferedImage.TYPE_INT_RGB);\n~~~\n\n查阅了API，`BufferedImage`类似乎用于将图片存入缓存中，在这里我们调用的构造方法有三个参数，分别对应图片的宽高和创建的图像格式。此处的`BufferedImage.TYPE_INT_RGB`是一个类成员属性。详见API\n\n![TYPE_INT_RGB](https://upload-images.jianshu.io/upload_images/13085799-8c3b2d8d99f38ccb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n~~~java\n//为bi创建图形上下文\nGraphics g = bi.getGraphics();\n//设置颜色，此处调用的构造方法是基于RGB数值作为参数的\nColor c = new Color(200, 150, 255);\n//设置颜色\t\t\t\ng.setColor(c);\n//该方法用于填充指定的矩形，参数是坐标和宽高\ng.fillRect(0, 0, 68, 22);\n~~~\n\nAPI上说“Graphics 类是所有图形上下文的抽象基类，允许应用程序在组件（已经在各种设备上实现）以及闭屏图像上进行绘制。 ”\n\n这里我认为其类似于MFC里那个`PDC`，获取了屏幕之后，所有的操作都是基于它的，这里的`Graphics`也是一样，关于颜色，大小等操作都是基于它进行设置的。\n\n即`setColor()`和`fillRect()`方法，前者的参数是一个`Color`类对象，该类有多重构造方法，而此处使用的是三个`int`数值，对应的是`RGB`数值大于0小于256.而后者则用于填充指定的矩形，参数是坐标和宽高。\n\n~~~java\n//编写随机获取验证码的部分\n\t\t\t\n//将字符串转换为字符数组\nchar[] ch = \"abcdefghijklmnopqrstuvwxyz0123456789\".toCharArray();\n~~~\n\n此处使用了`toCharArray()`方法将字符串转换为字符数组，如果不适用该方法，`char[] ch`是没有办法这样赋值的。\n\n~~~java\n//随机类，在本程序中只使用了 int nextInt(int n) 方法，作用是生成一个0-n的伪随机int值\nRandom r = new Random();\n~~~\n\nAPI中将`Random`称为伪随机，并称`Math.random()`更容易使用= =！\n\n![Random](https://upload-images.jianshu.io/upload_images/13085799-fba99a03c33efc09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n~~~java\nint len = ch.length, index;\n\t\t\t\n//用于存储随机生成的四位验证码\nStringBuffer sb = new StringBuffer();\n~~~\n\n定义了用于存储长度的`len`以及对应的下标`index `，并定义了`StringBuffer`类对象用来存储随机生成的验证码。\n\n~~~java\nfor(int i = 0; i < 4; i++) {\n\t//从0-len随机获取一个作为下标\n\tindex = r.nextInt(len);\n\t//随机获取颜色\n\tg.setColor(new Color(r.nextInt(200), r.nextInt(150), r.nextInt(255)));\n\t\t\t\t\n\t//在图形中绘制指定的String，参数对应要绘制的String以及坐标\n\tg.drawString(ch[index] + \" \",(i * 15) + 3, 18);\n\t\t\t\t\n\t//将内容添加到StringBuffer\n\tsb.append(ch[index]);\n}\n~~~\n\n使用for循环生成4次随机字符，`r.nextInt(int len)`方法用于生成一个随机的0~len之间的`int`变量。后面的获取颜色中也是如此使用。\n\n`void drawString(String str, int x,int y)`方法用于将指定文本绘制到图形中，参数分别对应指定的String文本，以及宽高。\n\n最后利用`StringBuffer.append()`方法将生成的字符添加到类对象`sb`中。\n\n~~~java\n//将验证码信息放入session中用于验证\nRequest.getSession().setAttribute(\"PicCode\", sb.toString());\n//将文件流输出，参数要写入的RenderedImage，输出的文件格式，输出到的ImageOutputStream\nImageIO.write(bi, \"JPG\", Response.getOutputStream());\n~~~\n\n创建session并添加`sb.toString()`用于实现判断\n\n最后一个方法是我觉得最迷的- -！`ImageIO.write()`方法，API中有三种构造方法，用于将`ImageWriter`按指定格式以三种不同方式输出。\n\n![ImageIO.write()方法](https://upload-images.jianshu.io/upload_images/13085799-c2d19e6dff79c306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n完成了如上代码的编写之后需要配置`servlet`打开`web.xml`添加如下代码。\n\n~~~xml\n<servlet>\n\t<servlet-name>ImageServlet</servlet-name>\n\t<servlet-class>com.yuchi.ImageServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n\t<servlet-name>ImageServlet</servlet-name>\n\t<url-pattern>/servlet/ImageServlet</url-pattern>\n</servlet-mapping>\n~~~\n部署后运行。\n\n![部署后运行](https://upload-images.jianshu.io/upload_images/13085799-bfd7dd83ae10413e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n到此处为止，随机生成验证码的功能就完成了。\n\n## 3. 完成刷新更换验证码的功能\n\n事实上我们在页面中使用验证码时往往容易出现验证码看不清的情况，因此我们需要有一个用户按钮使得验证码可以刷新，此处我们给`a`标签写上`JavaScript`以完成刷新功能的实现。\n\n~~~js\n<script type=\"text/javascript\">\n\tfunction ReloadCode(){\n\t\tvar time = new Date();\n\t\tdocument.getElementById(\"imagecode\").src = \"<%=request.getContextPath()%>/servlet/ImageServlet?d=\" + time;\n\t}\n</script>\n~~~\n\n此处使用了`document.getElementById()`获取到`img`标签之后，直接修改其`src`属性即可完成刷新，但IE浏览器似乎有一个缓存功能会使得刷新并不能生效，因此需要增加一个时间作为参数，使得每一次刷新的内容都不相同，这样IE才不会认为此次刷新是不需要的。\n\n到这里，整个用户界面就算完成了效果如图\n\n![效果预览](https://upload-images.jianshu.io/upload_images/13085799-6b87902c641c47f9.gif?imageMogr2/auto-orient/strip)\n\n## 4. 完成对验证码的验证功能\n\n其实验证功能的原理很简单，取出之前存入`Session`中的验证码，与用户的填入的验证码对比即可。\n\n新建`LoginServlet`类，同样继承自`HttpServlet`类\n~~~java\npackage com.yuchi;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class LoginServlet extends HttpServlet {\n\tpublic void doPost(HttpServletRequest Request,HttpServletResponse Response) throws IOException {\n\t\tString PicCode = (String) Request.getSession().getAttribute(\"PicCode\");\n\t\tString CheckCode = Request.getParameter(\"CheckCode\");\n\t\t\t\t\n\t\tCheckCode = CheckCode.toLowerCase();\n\t\t\t\t\n\t\tResponse.setContentType(\"text/html;charset=gbk\");\n\t\tPrintWriter out=Response.getWriter();\n\t\t\t\t\n\t\tif(CheckCode.equals(PicCode)) {\n\t\t\tout.print(\"正确！\");\n\t\t}else {\n\t\t\tout.print(\"错误！\");\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n}\n\n~~~\n\n这一次我们选择使用`post`传参，因此方法也变成了`doPost()`【实在因为我对get那种URL传参的方式有点厌恶……】。\n\n\n在类的编写中需要注意到几个问题\n- 验证码的大小写问题\n- 字符编码\n- 输出流的关闭\n\n因此在类中我们编写了一些用于解决这些问题的语句\n~~~java\n//将用户的验证码统一为小写\nCheckCode=CheckCode.toLowerCase();\n//设置页面的字符编码为gbk\nResponse.setContentType(\"text/html;charset=gbk\");\n//刷新流并关闭\nout.flush();\nout.close();\n~~~\n\n编写对应的Servlet并更改HTML结构\n\n~~~xml\n<servlet>\n\t<servlet-name>LoginServlet</servlet-name>\n\t<servlet-class>com.yuchi.LoginServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n\t<servlet-name>LoginServlet</servlet-name>\n\t<url-pattern>/servlet/LoginServlet</url-pattern>\n</servlet-mapping>\n~~~\n\n~~~jsp\n<form action=\"<%=request.getContextPath()%>/servlet/LoginServlet\" method=\"post\">\n\t......\n\t<input type=\"submit\" value=\"提交\">\n</form>\n~~~\n\n以上，一个基本的验证码功能就完成了。效果如图:\n\n![基本演示](https://upload-images.jianshu.io/upload_images/13085799-d6b2385e05c5f827.gif?imageMogr2/auto-orient/strip)\n","slug":"servlet+jsp实现验证码","published":1,"date":"2022-05-03T08:46:25.182Z","updated":"2022-05-03T08:46:25.182Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdud001pr2veedbp41gk","content":"<h1 id=\"Servlet-JSP-实现验证码\"><a href=\"#Servlet-JSP-实现验证码\" class=\"headerlink\" title=\"Servlet  + JSP 实现验证码\"></a>Servlet  + JSP 实现验证码</h1><p>使用Servlet+Jsp完成验证码主要有如下步骤</p>\n<ol>\n<li>完成HTML页面的编写</li>\n<li>完成生成随机验证码的Servlet</li>\n<li>完成刷新更换验证码的功能</li>\n<li>完成验证验证码是否正确是Servlet</li>\n</ol>\n<h2 id=\"1-Html的编写\"><a href=\"#1-Html的编写\" class=\"headerlink\" title=\"1. Html的编写\"></a>1. Html的编写</h2><p>页面结构相对比较简单，主要有<code>input-text</code>,<code>img</code>,<code>a</code>三种元素组成，<code>input-text</code>用于用户输入验证码，<code>img</code>用于显示验证码，而通常页面中都会用<code>a</code>标签来保证用户能更好的输入验证码。</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">验证码：</span><br><span class=\"line\">&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;CheckCode&quot;</span>&gt;</span><br><span class=\"line\">&lt;img alt=<span class=\"string\">&quot;验证码&quot;</span> id=<span class=\"string\">&quot;imagecode&quot;</span> src=<span class=\"string\">&quot;&lt;%=request.getContextPath()%&gt;/servlet/ImageServlet&quot;</span>/&gt;</span><br><span class=\"line\">&lt;a href=<span class=\"string\">&quot;javascript:ReloadCode();&quot;</span>&gt;看不清楚，换一张&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-9e6828c1708fb560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"预览\"></p>\n<h2 id=\"2-完成生成随机验证码的Servlet\"><a href=\"#2-完成生成随机验证码的Servlet\" class=\"headerlink\" title=\"2. 完成生成随机验证码的Servlet\"></a>2. 完成生成随机验证码的Servlet</h2><p>我们使用Servlet来完成对应的功能，创建<code>ImageServlet</code>类并继承自<code>HttpServlet</code>类。编写<code>doGet()</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.yuchi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.awt.Color;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.awt.Graphics;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.awt.image.BufferedImage;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.imageio.ImageIO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImageServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest Request,HttpServletResponse Response)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//BufferedImage将图片存入缓存中，有三个构造方法，此处的三个参数为图片的宽，高，以及创建的图像类型。</span></span><br><span class=\"line\">\t\t<span class=\"type\">BufferedImage</span> <span class=\"variable\">bi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedImage</span>(<span class=\"number\">68</span>, <span class=\"number\">22</span>, BufferedImage.TYPE_INT_RGB);</span><br><span class=\"line\">\t\t<span class=\"comment\">//为bi创建图形上下文</span></span><br><span class=\"line\">\t\t<span class=\"type\">Graphics</span> <span class=\"variable\">g</span> <span class=\"operator\">=</span> bi.getGraphics();</span><br><span class=\"line\">\t\t<span class=\"comment\">//设置颜色，此处调用的构造方法是基于RGB数值作为参数的</span></span><br><span class=\"line\">\t\t<span class=\"type\">Color</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Color</span>(<span class=\"number\">200</span>, <span class=\"number\">150</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//设置颜色\t\t\t</span></span><br><span class=\"line\">\t\tg.setColor(c);</span><br><span class=\"line\">\t\t<span class=\"comment\">//该方法用于填充指定的矩形，参数是坐标和宽高</span></span><br><span class=\"line\">\t\tg.fillRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">68</span>, <span class=\"number\">22</span>);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//编写随机获取验证码的部分</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//将字符串转换为字符数组</span></span><br><span class=\"line\">\t\t<span class=\"type\">char</span>[] ch = <span class=\"string\">&quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;</span>.toCharArray();</span><br><span class=\"line\">\t\t<span class=\"comment\">//随机类，在本程序中只使用了 int nextInt(int n) 方法，作用是生成一个0-n的伪随机int值</span></span><br><span class=\"line\">\t\t<span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> ch.length,index;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//用于存储随机生成的四位验证码</span></span><br><span class=\"line\">\t\t<span class=\"type\">StringBuffer</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//从0-len随机获取一个作为下标</span></span><br><span class=\"line\">\t\t\tindex = r.nextInt(len);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//随机获取颜色</span></span><br><span class=\"line\">\t\t\tg.setColor(<span class=\"keyword\">new</span> <span class=\"title class_\">Color</span>(r.nextInt(<span class=\"number\">200</span>), r.nextInt(<span class=\"number\">150</span>), r.nextInt(<span class=\"number\">255</span>)));</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//在图形中绘制指定的String，参数对应要绘制的String以及坐标</span></span><br><span class=\"line\">\t\t\tg.drawString(ch[index] + <span class=\"string\">&quot; &quot;</span>, (i * <span class=\"number\">15</span>) + <span class=\"number\">3</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//将内容添加到StringBuffer</span></span><br><span class=\"line\">\t\t\tsb.append(ch[index]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//将验证码信息放入session中用于验证</span></span><br><span class=\"line\">\t\tRequest.getSession().setAttribute(<span class=\"string\">&quot;PicCode&quot;</span>, sb.toString());</span><br><span class=\"line\">\t\t<span class=\"comment\">//将文件流输出，参数要写入的RenderedImage，输出的文件格式，输出到的ImageOutputStream</span></span><br><span class=\"line\">\t\tImageIO.write(bi, <span class=\"string\">&quot;JPG&quot;</span>, Response.getOutputStream());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-5-关于doGet-方法中的内容详解（个人理解）\"><a href=\"#2-5-关于doGet-方法中的内容详解（个人理解）\" class=\"headerlink\" title=\"2.5 关于doGet()方法中的内容详解（个人理解）\"></a>2.5 关于<code>doGet()</code>方法中的内容详解（个人理解）</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BufferedImage</span> <span class=\"variable\">bi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedImage</span>(<span class=\"number\">68</span>, <span class=\"number\">22</span>, BufferedImage.TYPE_INT_RGB);</span><br></pre></td></tr></table></figure>\n\n<p>查阅了API，<code>BufferedImage</code>类似乎用于将图片存入缓存中，在这里我们调用的构造方法有三个参数，分别对应图片的宽高和创建的图像格式。此处的<code>BufferedImage.TYPE_INT_RGB</code>是一个类成员属性。详见API</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-8c3b2d8d99f38ccb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TYPE_INT_RGB\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//为bi创建图形上下文</span></span><br><span class=\"line\"><span class=\"type\">Graphics</span> <span class=\"variable\">g</span> <span class=\"operator\">=</span> bi.getGraphics();</span><br><span class=\"line\"><span class=\"comment\">//设置颜色，此处调用的构造方法是基于RGB数值作为参数的</span></span><br><span class=\"line\"><span class=\"type\">Color</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Color</span>(<span class=\"number\">200</span>, <span class=\"number\">150</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"comment\">//设置颜色\t\t\t</span></span><br><span class=\"line\">g.setColor(c);</span><br><span class=\"line\"><span class=\"comment\">//该方法用于填充指定的矩形，参数是坐标和宽高</span></span><br><span class=\"line\">g.fillRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">68</span>, <span class=\"number\">22</span>);</span><br></pre></td></tr></table></figure>\n\n<p>API上说“Graphics 类是所有图形上下文的抽象基类，允许应用程序在组件（已经在各种设备上实现）以及闭屏图像上进行绘制。 ”</p>\n<p>这里我认为其类似于MFC里那个<code>PDC</code>，获取了屏幕之后，所有的操作都是基于它的，这里的<code>Graphics</code>也是一样，关于颜色，大小等操作都是基于它进行设置的。</p>\n<p>即<code>setColor()</code>和<code>fillRect()</code>方法，前者的参数是一个<code>Color</code>类对象，该类有多重构造方法，而此处使用的是三个<code>int</code>数值，对应的是<code>RGB</code>数值大于0小于256.而后者则用于填充指定的矩形，参数是坐标和宽高。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//编写随机获取验证码的部分</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\"><span class=\"comment\">//将字符串转换为字符数组</span></span><br><span class=\"line\"><span class=\"type\">char</span>[] ch = <span class=\"string\">&quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;</span>.toCharArray();</span><br></pre></td></tr></table></figure>\n\n<p>此处使用了<code>toCharArray()</code>方法将字符串转换为字符数组，如果不适用该方法，<code>char[] ch</code>是没有办法这样赋值的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//随机类，在本程序中只使用了 int nextInt(int n) 方法，作用是生成一个0-n的伪随机int值</span></span><br><span class=\"line\"><span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br></pre></td></tr></table></figure>\n\n<p>API中将<code>Random</code>称为伪随机，并称<code>Math.random()</code>更容易使用&#x3D; &#x3D;！</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-fba99a03c33efc09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Random\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> ch.length, index;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\"><span class=\"comment\">//用于存储随机生成的四位验证码</span></span><br><span class=\"line\"><span class=\"type\">StringBuffer</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br></pre></td></tr></table></figure>\n\n<p>定义了用于存储长度的<code>len</code>以及对应的下标<code>index </code>，并定义了<code>StringBuffer</code>类对象用来存储随机生成的验证码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从0-len随机获取一个作为下标</span></span><br><span class=\"line\">\tindex = r.nextInt(len);</span><br><span class=\"line\">\t<span class=\"comment\">//随机获取颜色</span></span><br><span class=\"line\">\tg.setColor(<span class=\"keyword\">new</span> <span class=\"title class_\">Color</span>(r.nextInt(<span class=\"number\">200</span>), r.nextInt(<span class=\"number\">150</span>), r.nextInt(<span class=\"number\">255</span>)));</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t<span class=\"comment\">//在图形中绘制指定的String，参数对应要绘制的String以及坐标</span></span><br><span class=\"line\">\tg.drawString(ch[index] + <span class=\"string\">&quot; &quot;</span>,(i * <span class=\"number\">15</span>) + <span class=\"number\">3</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t<span class=\"comment\">//将内容添加到StringBuffer</span></span><br><span class=\"line\">\tsb.append(ch[index]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用for循环生成4次随机字符，<code>r.nextInt(int len)</code>方法用于生成一个随机的0~len之间的<code>int</code>变量。后面的获取颜色中也是如此使用。</p>\n<p><code>void drawString(String str, int x,int y)</code>方法用于将指定文本绘制到图形中，参数分别对应指定的String文本，以及宽高。</p>\n<p>最后利用<code>StringBuffer.append()</code>方法将生成的字符添加到类对象<code>sb</code>中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将验证码信息放入session中用于验证</span></span><br><span class=\"line\">Request.getSession().setAttribute(<span class=\"string\">&quot;PicCode&quot;</span>, sb.toString());</span><br><span class=\"line\"><span class=\"comment\">//将文件流输出，参数要写入的RenderedImage，输出的文件格式，输出到的ImageOutputStream</span></span><br><span class=\"line\">ImageIO.write(bi, <span class=\"string\">&quot;JPG&quot;</span>, Response.getOutputStream());</span><br></pre></td></tr></table></figure>\n\n<p>创建session并添加<code>sb.toString()</code>用于实现判断</p>\n<p>最后一个方法是我觉得最迷的- -！<code>ImageIO.write()</code>方法，API中有三种构造方法，用于将<code>ImageWriter</code>按指定格式以三种不同方式输出。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-c2d19e6dff79c306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ImageIO.write()方法\"></p>\n<p>完成了如上代码的编写之后需要配置<code>servlet</code>打开<code>web.xml</code>添加如下代码。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>ImageServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.yuchi.ImageServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>ImageServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/servlet/ImageServlet<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>部署后运行。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-bfd7dd83ae10413e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"部署后运行\"></p>\n<p>到此处为止，随机生成验证码的功能就完成了。</p>\n<h2 id=\"3-完成刷新更换验证码的功能\"><a href=\"#3-完成刷新更换验证码的功能\" class=\"headerlink\" title=\"3. 完成刷新更换验证码的功能\"></a>3. 完成刷新更换验证码的功能</h2><p>事实上我们在页面中使用验证码时往往容易出现验证码看不清的情况，因此我们需要有一个用户按钮使得验证码可以刷新，此处我们给<code>a</code>标签写上<code>JavaScript</code>以完成刷新功能的实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">ReloadCode</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> time = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">\t\t<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;imagecode&quot;</span>).<span class=\"property\">src</span> = <span class=\"string\">&quot;&lt;%=request.getContextPath()%&gt;/servlet/ImageServlet?d=&quot;</span> + time;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>此处使用了<code>document.getElementById()</code>获取到<code>img</code>标签之后，直接修改其<code>src</code>属性即可完成刷新，但IE浏览器似乎有一个缓存功能会使得刷新并不能生效，因此需要增加一个时间作为参数，使得每一次刷新的内容都不相同，这样IE才不会认为此次刷新是不需要的。</p>\n<p>到这里，整个用户界面就算完成了效果如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-6b87902c641c47f9.gif?imageMogr2/auto-orient/strip\" alt=\"效果预览\"></p>\n<h2 id=\"4-完成对验证码的验证功能\"><a href=\"#4-完成对验证码的验证功能\" class=\"headerlink\" title=\"4. 完成对验证码的验证功能\"></a>4. 完成对验证码的验证功能</h2><p>其实验证功能的原理很简单，取出之前存入<code>Session</code>中的验证码，与用户的填入的验证码对比即可。</p>\n<p>新建<code>LoginServlet</code>类，同样继承自<code>HttpServlet</code>类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.yuchi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doPost</span><span class=\"params\">(HttpServletRequest Request,HttpServletResponse Response)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">PicCode</span> <span class=\"operator\">=</span> (String) Request.getSession().getAttribute(<span class=\"string\">&quot;PicCode&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">CheckCode</span> <span class=\"operator\">=</span> Request.getParameter(<span class=\"string\">&quot;CheckCode&quot;</span>);</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\tCheckCode = CheckCode.toLowerCase();</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\tResponse.setContentType(<span class=\"string\">&quot;text/html;charset=gbk&quot;</span>);</span><br><span class=\"line\">\t\tPrintWriter out=Response.getWriter();</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(CheckCode.equals(PicCode)) &#123;</span><br><span class=\"line\">\t\t\tout.print(<span class=\"string\">&quot;正确！&quot;</span>);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tout.print(<span class=\"string\">&quot;错误！&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tout.flush();</span><br><span class=\"line\">\t\tout.close();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这一次我们选择使用<code>post</code>传参，因此方法也变成了<code>doPost()</code>【实在因为我对get那种URL传参的方式有点厌恶……】。</p>\n<p>在类的编写中需要注意到几个问题</p>\n<ul>\n<li>验证码的大小写问题</li>\n<li>字符编码</li>\n<li>输出流的关闭</li>\n</ul>\n<p>因此在类中我们编写了一些用于解决这些问题的语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将用户的验证码统一为小写</span></span><br><span class=\"line\">CheckCode=CheckCode.toLowerCase();</span><br><span class=\"line\"><span class=\"comment\">//设置页面的字符编码为gbk</span></span><br><span class=\"line\">Response.setContentType(<span class=\"string\">&quot;text/html;charset=gbk&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//刷新流并关闭</span></span><br><span class=\"line\">out.flush();</span><br><span class=\"line\">out.close();</span><br></pre></td></tr></table></figure>\n\n<p>编写对应的Servlet并更改HTML结构</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>LoginServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.yuchi.LoginServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>LoginServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/servlet/LoginServlet<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;&lt;%=request.getContextPath()%&gt;/servlet/LoginServlet&quot;</span> method=<span class=\"string\">&quot;post&quot;</span>&gt;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;提交&quot;</span>&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>以上，一个基本的验证码功能就完成了。效果如图:</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-d6b2385e05c5f827.gif?imageMogr2/auto-orient/strip\" alt=\"基本演示\"></p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"Servlet-JSP-实现验证码\"><a href=\"#Servlet-JSP-实现验证码\" class=\"headerlink\" title=\"Servlet  + JSP 实现验证码\"></a>Servlet  + JSP 实现验证码</h1><p>使用Servlet+Jsp完成验证码主要有如下步骤</p>\n<ol>\n<li>完成HTML页面的编写</li>\n<li>完成生成随机验证码的Servlet</li>\n<li>完成刷新更换验证码的功能</li>\n<li>完成验证验证码是否正确是Servlet</li>\n</ol>\n<h2 id=\"1-Html的编写\"><a href=\"#1-Html的编写\" class=\"headerlink\" title=\"1. Html的编写\"></a>1. Html的编写</h2><p>页面结构相对比较简单，主要有<code>input-text</code>,<code>img</code>,<code>a</code>三种元素组成，<code>input-text</code>用于用户输入验证码，<code>img</code>用于显示验证码，而通常页面中都会用<code>a</code>标签来保证用户能更好的输入验证码。</p>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">验证码：</span><br><span class=\"line\">&lt;input type=<span class=\"string\">&quot;text&quot;</span> name=<span class=\"string\">&quot;CheckCode&quot;</span>&gt;</span><br><span class=\"line\">&lt;img alt=<span class=\"string\">&quot;验证码&quot;</span> id=<span class=\"string\">&quot;imagecode&quot;</span> src=<span class=\"string\">&quot;&lt;%=request.getContextPath()%&gt;/servlet/ImageServlet&quot;</span>/&gt;</span><br><span class=\"line\">&lt;a href=<span class=\"string\">&quot;javascript:ReloadCode();&quot;</span>&gt;看不清楚，换一张&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-9e6828c1708fb560.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"预览\"></p>\n<h2 id=\"2-完成生成随机验证码的Servlet\"><a href=\"#2-完成生成随机验证码的Servlet\" class=\"headerlink\" title=\"2. 完成生成随机验证码的Servlet\"></a>2. 完成生成随机验证码的Servlet</h2><p>我们使用Servlet来完成对应的功能，创建<code>ImageServlet</code>类并继承自<code>HttpServlet</code>类。编写<code>doGet()</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.yuchi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.awt.Color;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.awt.Graphics;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.awt.image.BufferedImage;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.imageio.ImageIO;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImageServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doGet</span><span class=\"params\">(HttpServletRequest Request,HttpServletResponse Response)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//BufferedImage将图片存入缓存中，有三个构造方法，此处的三个参数为图片的宽，高，以及创建的图像类型。</span></span><br><span class=\"line\">\t\t<span class=\"type\">BufferedImage</span> <span class=\"variable\">bi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedImage</span>(<span class=\"number\">68</span>, <span class=\"number\">22</span>, BufferedImage.TYPE_INT_RGB);</span><br><span class=\"line\">\t\t<span class=\"comment\">//为bi创建图形上下文</span></span><br><span class=\"line\">\t\t<span class=\"type\">Graphics</span> <span class=\"variable\">g</span> <span class=\"operator\">=</span> bi.getGraphics();</span><br><span class=\"line\">\t\t<span class=\"comment\">//设置颜色，此处调用的构造方法是基于RGB数值作为参数的</span></span><br><span class=\"line\">\t\t<span class=\"type\">Color</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Color</span>(<span class=\"number\">200</span>, <span class=\"number\">150</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//设置颜色\t\t\t</span></span><br><span class=\"line\">\t\tg.setColor(c);</span><br><span class=\"line\">\t\t<span class=\"comment\">//该方法用于填充指定的矩形，参数是坐标和宽高</span></span><br><span class=\"line\">\t\tg.fillRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">68</span>, <span class=\"number\">22</span>);</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//编写随机获取验证码的部分</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//将字符串转换为字符数组</span></span><br><span class=\"line\">\t\t<span class=\"type\">char</span>[] ch = <span class=\"string\">&quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;</span>.toCharArray();</span><br><span class=\"line\">\t\t<span class=\"comment\">//随机类，在本程序中只使用了 int nextInt(int n) 方法，作用是生成一个0-n的伪随机int值</span></span><br><span class=\"line\">\t\t<span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> ch.length,index;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//用于存储随机生成的四位验证码</span></span><br><span class=\"line\">\t\t<span class=\"type\">StringBuffer</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//从0-len随机获取一个作为下标</span></span><br><span class=\"line\">\t\t\tindex = r.nextInt(len);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//随机获取颜色</span></span><br><span class=\"line\">\t\t\tg.setColor(<span class=\"keyword\">new</span> <span class=\"title class_\">Color</span>(r.nextInt(<span class=\"number\">200</span>), r.nextInt(<span class=\"number\">150</span>), r.nextInt(<span class=\"number\">255</span>)));</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//在图形中绘制指定的String，参数对应要绘制的String以及坐标</span></span><br><span class=\"line\">\t\t\tg.drawString(ch[index] + <span class=\"string\">&quot; &quot;</span>, (i * <span class=\"number\">15</span>) + <span class=\"number\">3</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//将内容添加到StringBuffer</span></span><br><span class=\"line\">\t\t\tsb.append(ch[index]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">//将验证码信息放入session中用于验证</span></span><br><span class=\"line\">\t\tRequest.getSession().setAttribute(<span class=\"string\">&quot;PicCode&quot;</span>, sb.toString());</span><br><span class=\"line\">\t\t<span class=\"comment\">//将文件流输出，参数要写入的RenderedImage，输出的文件格式，输出到的ImageOutputStream</span></span><br><span class=\"line\">\t\tImageIO.write(bi, <span class=\"string\">&quot;JPG&quot;</span>, Response.getOutputStream());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-5-关于doGet-方法中的内容详解（个人理解）\"><a href=\"#2-5-关于doGet-方法中的内容详解（个人理解）\" class=\"headerlink\" title=\"2.5 关于doGet()方法中的内容详解（个人理解）\"></a>2.5 关于<code>doGet()</code>方法中的内容详解（个人理解）</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BufferedImage</span> <span class=\"variable\">bi</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedImage</span>(<span class=\"number\">68</span>, <span class=\"number\">22</span>, BufferedImage.TYPE_INT_RGB);</span><br></pre></td></tr></table></figure>\n\n<p>查阅了API，<code>BufferedImage</code>类似乎用于将图片存入缓存中，在这里我们调用的构造方法有三个参数，分别对应图片的宽高和创建的图像格式。此处的<code>BufferedImage.TYPE_INT_RGB</code>是一个类成员属性。详见API</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-8c3b2d8d99f38ccb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"TYPE_INT_RGB\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//为bi创建图形上下文</span></span><br><span class=\"line\"><span class=\"type\">Graphics</span> <span class=\"variable\">g</span> <span class=\"operator\">=</span> bi.getGraphics();</span><br><span class=\"line\"><span class=\"comment\">//设置颜色，此处调用的构造方法是基于RGB数值作为参数的</span></span><br><span class=\"line\"><span class=\"type\">Color</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Color</span>(<span class=\"number\">200</span>, <span class=\"number\">150</span>, <span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"comment\">//设置颜色\t\t\t</span></span><br><span class=\"line\">g.setColor(c);</span><br><span class=\"line\"><span class=\"comment\">//该方法用于填充指定的矩形，参数是坐标和宽高</span></span><br><span class=\"line\">g.fillRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">68</span>, <span class=\"number\">22</span>);</span><br></pre></td></tr></table></figure>\n\n<p>API上说“Graphics 类是所有图形上下文的抽象基类，允许应用程序在组件（已经在各种设备上实现）以及闭屏图像上进行绘制。 ”</p>\n<p>这里我认为其类似于MFC里那个<code>PDC</code>，获取了屏幕之后，所有的操作都是基于它的，这里的<code>Graphics</code>也是一样，关于颜色，大小等操作都是基于它进行设置的。</p>\n<p>即<code>setColor()</code>和<code>fillRect()</code>方法，前者的参数是一个<code>Color</code>类对象，该类有多重构造方法，而此处使用的是三个<code>int</code>数值，对应的是<code>RGB</code>数值大于0小于256.而后者则用于填充指定的矩形，参数是坐标和宽高。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//编写随机获取验证码的部分</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\"><span class=\"comment\">//将字符串转换为字符数组</span></span><br><span class=\"line\"><span class=\"type\">char</span>[] ch = <span class=\"string\">&quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;</span>.toCharArray();</span><br></pre></td></tr></table></figure>\n\n<p>此处使用了<code>toCharArray()</code>方法将字符串转换为字符数组，如果不适用该方法，<code>char[] ch</code>是没有办法这样赋值的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//随机类，在本程序中只使用了 int nextInt(int n) 方法，作用是生成一个0-n的伪随机int值</span></span><br><span class=\"line\"><span class=\"type\">Random</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Random</span>();</span><br></pre></td></tr></table></figure>\n\n<p>API中将<code>Random</code>称为伪随机，并称<code>Math.random()</code>更容易使用&#x3D; &#x3D;！</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-fba99a03c33efc09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Random\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> ch.length, index;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\"><span class=\"comment\">//用于存储随机生成的四位验证码</span></span><br><span class=\"line\"><span class=\"type\">StringBuffer</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br></pre></td></tr></table></figure>\n\n<p>定义了用于存储长度的<code>len</code>以及对应的下标<code>index </code>，并定义了<code>StringBuffer</code>类对象用来存储随机生成的验证码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//从0-len随机获取一个作为下标</span></span><br><span class=\"line\">\tindex = r.nextInt(len);</span><br><span class=\"line\">\t<span class=\"comment\">//随机获取颜色</span></span><br><span class=\"line\">\tg.setColor(<span class=\"keyword\">new</span> <span class=\"title class_\">Color</span>(r.nextInt(<span class=\"number\">200</span>), r.nextInt(<span class=\"number\">150</span>), r.nextInt(<span class=\"number\">255</span>)));</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t<span class=\"comment\">//在图形中绘制指定的String，参数对应要绘制的String以及坐标</span></span><br><span class=\"line\">\tg.drawString(ch[index] + <span class=\"string\">&quot; &quot;</span>,(i * <span class=\"number\">15</span>) + <span class=\"number\">3</span>, <span class=\"number\">18</span>);</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t<span class=\"comment\">//将内容添加到StringBuffer</span></span><br><span class=\"line\">\tsb.append(ch[index]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用for循环生成4次随机字符，<code>r.nextInt(int len)</code>方法用于生成一个随机的0~len之间的<code>int</code>变量。后面的获取颜色中也是如此使用。</p>\n<p><code>void drawString(String str, int x,int y)</code>方法用于将指定文本绘制到图形中，参数分别对应指定的String文本，以及宽高。</p>\n<p>最后利用<code>StringBuffer.append()</code>方法将生成的字符添加到类对象<code>sb</code>中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将验证码信息放入session中用于验证</span></span><br><span class=\"line\">Request.getSession().setAttribute(<span class=\"string\">&quot;PicCode&quot;</span>, sb.toString());</span><br><span class=\"line\"><span class=\"comment\">//将文件流输出，参数要写入的RenderedImage，输出的文件格式，输出到的ImageOutputStream</span></span><br><span class=\"line\">ImageIO.write(bi, <span class=\"string\">&quot;JPG&quot;</span>, Response.getOutputStream());</span><br></pre></td></tr></table></figure>\n\n<p>创建session并添加<code>sb.toString()</code>用于实现判断</p>\n<p>最后一个方法是我觉得最迷的- -！<code>ImageIO.write()</code>方法，API中有三种构造方法，用于将<code>ImageWriter</code>按指定格式以三种不同方式输出。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-c2d19e6dff79c306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"ImageIO.write()方法\"></p>\n<p>完成了如上代码的编写之后需要配置<code>servlet</code>打开<code>web.xml</code>添加如下代码。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>ImageServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.yuchi.ImageServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>ImageServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/servlet/ImageServlet<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>部署后运行。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-bfd7dd83ae10413e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"部署后运行\"></p>\n<p>到此处为止，随机生成验证码的功能就完成了。</p>\n<h2 id=\"3-完成刷新更换验证码的功能\"><a href=\"#3-完成刷新更换验证码的功能\" class=\"headerlink\" title=\"3. 完成刷新更换验证码的功能\"></a>3. 完成刷新更换验证码的功能</h2><p>事实上我们在页面中使用验证码时往往容易出现验证码看不清的情况，因此我们需要有一个用户按钮使得验证码可以刷新，此处我们给<code>a</code>标签写上<code>JavaScript</code>以完成刷新功能的实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">function</span> <span class=\"title function_\">ReloadCode</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> time = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\">\t\t<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;imagecode&quot;</span>).<span class=\"property\">src</span> = <span class=\"string\">&quot;&lt;%=request.getContextPath()%&gt;/servlet/ImageServlet?d=&quot;</span> + time;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<p>此处使用了<code>document.getElementById()</code>获取到<code>img</code>标签之后，直接修改其<code>src</code>属性即可完成刷新，但IE浏览器似乎有一个缓存功能会使得刷新并不能生效，因此需要增加一个时间作为参数，使得每一次刷新的内容都不相同，这样IE才不会认为此次刷新是不需要的。</p>\n<p>到这里，整个用户界面就算完成了效果如图</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-6b87902c641c47f9.gif?imageMogr2/auto-orient/strip\" alt=\"效果预览\"></p>\n<h2 id=\"4-完成对验证码的验证功能\"><a href=\"#4-完成对验证码的验证功能\" class=\"headerlink\" title=\"4. 完成对验证码的验证功能\"></a>4. 完成对验证码的验证功能</h2><p>其实验证功能的原理很简单，取出之前存入<code>Session</code>中的验证码，与用户的填入的验证码对比即可。</p>\n<p>新建<code>LoginServlet</code>类，同样继承自<code>HttpServlet</code>类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.yuchi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.PrintWriter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginServlet</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">HttpServlet</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doPost</span><span class=\"params\">(HttpServletRequest Request,HttpServletResponse Response)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">PicCode</span> <span class=\"operator\">=</span> (String) Request.getSession().getAttribute(<span class=\"string\">&quot;PicCode&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">CheckCode</span> <span class=\"operator\">=</span> Request.getParameter(<span class=\"string\">&quot;CheckCode&quot;</span>);</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\tCheckCode = CheckCode.toLowerCase();</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\tResponse.setContentType(<span class=\"string\">&quot;text/html;charset=gbk&quot;</span>);</span><br><span class=\"line\">\t\tPrintWriter out=Response.getWriter();</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(CheckCode.equals(PicCode)) &#123;</span><br><span class=\"line\">\t\t\tout.print(<span class=\"string\">&quot;正确！&quot;</span>);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tout.print(<span class=\"string\">&quot;错误！&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tout.flush();</span><br><span class=\"line\">\t\tout.close();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这一次我们选择使用<code>post</code>传参，因此方法也变成了<code>doPost()</code>【实在因为我对get那种URL传参的方式有点厌恶……】。</p>\n<p>在类的编写中需要注意到几个问题</p>\n<ul>\n<li>验证码的大小写问题</li>\n<li>字符编码</li>\n<li>输出流的关闭</li>\n</ul>\n<p>因此在类中我们编写了一些用于解决这些问题的语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将用户的验证码统一为小写</span></span><br><span class=\"line\">CheckCode=CheckCode.toLowerCase();</span><br><span class=\"line\"><span class=\"comment\">//设置页面的字符编码为gbk</span></span><br><span class=\"line\">Response.setContentType(<span class=\"string\">&quot;text/html;charset=gbk&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//刷新流并关闭</span></span><br><span class=\"line\">out.flush();</span><br><span class=\"line\">out.close();</span><br></pre></td></tr></table></figure>\n\n<p>编写对应的Servlet并更改HTML结构</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>LoginServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.yuchi.LoginServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>LoginServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/servlet/LoginServlet<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">&quot;&lt;%=request.getContextPath()%&gt;/servlet/LoginServlet&quot;</span> method=<span class=\"string\">&quot;post&quot;</span>&gt;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t&lt;input type=<span class=\"string\">&quot;submit&quot;</span> value=<span class=\"string\">&quot;提交&quot;</span>&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>\n\n<p>以上，一个基本的验证码功能就完成了。效果如图:</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-d6b2385e05c5f827.gif?imageMogr2/auto-orient/strip\" alt=\"基本演示\"></p>\n"},{"_content":"# tortoiseGit SSH公钥的配置\n\n使用Git命令行生成公钥和私钥\n\n1. 进入`git push`界面（备注：左Shift + 鼠标右键弹出菜单里面，有直接进入命令行的菜单，但是这里千万不要用这个，因为这里进入的命令行和系统cmd进入的权限不一样，生成的秘钥是不一样的，踩过这个坑），我这里默认路径是`C:\\Users\\Administrator`,这个路径没有要求，任何目录都可以，生成钥的时候需要输入密码，这里默认写**123456**，后面clone代码的时候需要用到。\n\n2. 执行命令：`ssh-keygen –t rsa –C xxxx@xxx.com(你的邮箱)`\n\n3. 输入保存的文件名：enter\n\n4. 输入密码:enter\n\n即可成功创建公钥和私钥，这里会保存到C:\\Users\\Administrator 目录下\n","source":"_posts/tortoiseGit-SSH公钥的配置.md","raw":"# tortoiseGit SSH公钥的配置\n\n使用Git命令行生成公钥和私钥\n\n1. 进入`git push`界面（备注：左Shift + 鼠标右键弹出菜单里面，有直接进入命令行的菜单，但是这里千万不要用这个，因为这里进入的命令行和系统cmd进入的权限不一样，生成的秘钥是不一样的，踩过这个坑），我这里默认路径是`C:\\Users\\Administrator`,这个路径没有要求，任何目录都可以，生成钥的时候需要输入密码，这里默认写**123456**，后面clone代码的时候需要用到。\n\n2. 执行命令：`ssh-keygen –t rsa –C xxxx@xxx.com(你的邮箱)`\n\n3. 输入保存的文件名：enter\n\n4. 输入密码:enter\n\n即可成功创建公钥和私钥，这里会保存到C:\\Users\\Administrator 目录下\n","slug":"tortoiseGit-SSH公钥的配置","published":1,"date":"2022-05-03T08:46:25.142Z","updated":"2022-05-03T08:46:25.142Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdue001qr2vefrhf9ojo","content":"<h1 id=\"tortoiseGit-SSH公钥的配置\"><a href=\"#tortoiseGit-SSH公钥的配置\" class=\"headerlink\" title=\"tortoiseGit SSH公钥的配置\"></a>tortoiseGit SSH公钥的配置</h1><p>使用Git命令行生成公钥和私钥</p>\n<ol>\n<li><p>进入<code>git push</code>界面（备注：左Shift + 鼠标右键弹出菜单里面，有直接进入命令行的菜单，但是这里千万不要用这个，因为这里进入的命令行和系统cmd进入的权限不一样，生成的秘钥是不一样的，踩过这个坑），我这里默认路径是<code>C:\\Users\\Administrator</code>,这个路径没有要求，任何目录都可以，生成钥的时候需要输入密码，这里默认写<strong>123456</strong>，后面clone代码的时候需要用到。</p>\n</li>\n<li><p>执行命令：<code>ssh-keygen –t rsa –C xxxx@xxx.com(你的邮箱)</code></p>\n</li>\n<li><p>输入保存的文件名：enter</p>\n</li>\n<li><p>输入密码:enter</p>\n</li>\n</ol>\n<p>即可成功创建公钥和私钥，这里会保存到C:\\Users\\Administrator 目录下</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"tortoiseGit-SSH公钥的配置\"><a href=\"#tortoiseGit-SSH公钥的配置\" class=\"headerlink\" title=\"tortoiseGit SSH公钥的配置\"></a>tortoiseGit SSH公钥的配置</h1><p>使用Git命令行生成公钥和私钥</p>\n<ol>\n<li><p>进入<code>git push</code>界面（备注：左Shift + 鼠标右键弹出菜单里面，有直接进入命令行的菜单，但是这里千万不要用这个，因为这里进入的命令行和系统cmd进入的权限不一样，生成的秘钥是不一样的，踩过这个坑），我这里默认路径是<code>C:\\Users\\Administrator</code>,这个路径没有要求，任何目录都可以，生成钥的时候需要输入密码，这里默认写<strong>123456</strong>，后面clone代码的时候需要用到。</p>\n</li>\n<li><p>执行命令：<code>ssh-keygen –t rsa –C xxxx@xxx.com(你的邮箱)</code></p>\n</li>\n<li><p>输入保存的文件名：enter</p>\n</li>\n<li><p>输入密码:enter</p>\n</li>\n</ol>\n<p>即可成功创建公钥和私钥，这里会保存到C:\\Users\\Administrator 目录下</p>\n"},{"title":"一次马虎导致的Tomcat闪退……","date":"2018-09-05T14:00:00.000Z","_content":"\n昨天弄完新的小`demo`准备挂到服务器上，在服务器上关掉了`Tomcat`然后删掉了`webapps`文件夹下的War问价以及对应的文件夹。\n\n紧接着上传了新的`War`文件并构建了数据库之后再启动`Tomcat`就发现命令行里跑几句代码之后命令行就没了。\n\n百度了很多方法说在`StatrUp`最末加上`PAUSE`，于是看到了这样一段代码\n~~~\nNOTE: Picked up JDK_JAVA_OPTIONS:  --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED\n~~~\n于是乎百度Google找了几个小时也没弄明白，回到`Tomcat`的`Conf`文件夹下查看日志多次报`A child container failed during start`的错误。\n\n在百度之后看到了`server.Xml`，于是回到该文件中查看配置的路径，发现这样一句话\n~~~xml\n<Context path=\"\" docBase=\"C:\\apache-tomcat-9.0.7\\webapps\\......\" debug=\"0\" reloadable=\"true\" /> \n~~~\n其中配置的文件路径俨然是之前的项目名= =！\n\n于是光速改掉之后再启动`StartUp`发现已经可以启动了，然后新的页面也可以访问。（mmp）\n\n这么一点小问题能折腾这么久也是挺佩服自己……再加上昨天还能犯忘记导入jar包这种错误真是内心全是波澜。\n","source":"_posts/一次马虎导致的Tomcat闪退…….md","raw":"---\ntitle: 一次马虎导致的Tomcat闪退……\ndate:  2018.09.05 22:00\ntags:\n  - 读书笔记\n  - 时间管理\ncategories:\n  - 好书分享\n---\n\n昨天弄完新的小`demo`准备挂到服务器上，在服务器上关掉了`Tomcat`然后删掉了`webapps`文件夹下的War问价以及对应的文件夹。\n\n紧接着上传了新的`War`文件并构建了数据库之后再启动`Tomcat`就发现命令行里跑几句代码之后命令行就没了。\n\n百度了很多方法说在`StatrUp`最末加上`PAUSE`，于是看到了这样一段代码\n~~~\nNOTE: Picked up JDK_JAVA_OPTIONS:  --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED\n~~~\n于是乎百度Google找了几个小时也没弄明白，回到`Tomcat`的`Conf`文件夹下查看日志多次报`A child container failed during start`的错误。\n\n在百度之后看到了`server.Xml`，于是回到该文件中查看配置的路径，发现这样一句话\n~~~xml\n<Context path=\"\" docBase=\"C:\\apache-tomcat-9.0.7\\webapps\\......\" debug=\"0\" reloadable=\"true\" /> \n~~~\n其中配置的文件路径俨然是之前的项目名= =！\n\n于是光速改掉之后再启动`StartUp`发现已经可以启动了，然后新的页面也可以访问。（mmp）\n\n这么一点小问题能折腾这么久也是挺佩服自己……再加上昨天还能犯忘记导入jar包这种错误真是内心全是波澜。\n","slug":"一次马虎导致的Tomcat闪退……","published":1,"updated":"2022-05-03T11:31:48.412Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mduf001rr2veezsg09tg","content":"<p>昨天弄完新的小<code>demo</code>准备挂到服务器上，在服务器上关掉了<code>Tomcat</code>然后删掉了<code>webapps</code>文件夹下的War问价以及对应的文件夹。</p>\n<p>紧接着上传了新的<code>War</code>文件并构建了数据库之后再启动<code>Tomcat</code>就发现命令行里跑几句代码之后命令行就没了。</p>\n<p>百度了很多方法说在<code>StatrUp</code>最末加上<code>PAUSE</code>，于是看到了这样一段代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NOTE: Picked up JDK_JAVA_OPTIONS:  --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED</span><br></pre></td></tr></table></figure>\n<p>于是乎百度Google找了几个小时也没弄明白，回到<code>Tomcat</code>的<code>Conf</code>文件夹下查看日志多次报<code>A child container failed during start</code>的错误。</p>\n<p>在百度之后看到了<code>server.Xml</code>，于是回到该文件中查看配置的路径，发现这样一句话</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Context</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">docBase</span>=<span class=\"string\">&quot;C:\\apache-tomcat-9.0.7\\webapps\\......&quot;</span> <span class=\"attr\">debug</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">reloadable</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure>\n<p>其中配置的文件路径俨然是之前的项目名&#x3D; &#x3D;！</p>\n<p>于是光速改掉之后再启动<code>StartUp</code>发现已经可以启动了，然后新的页面也可以访问。（mmp）</p>\n<p>这么一点小问题能折腾这么久也是挺佩服自己……再加上昨天还能犯忘记导入jar包这种错误真是内心全是波澜。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<p>昨天弄完新的小<code>demo</code>准备挂到服务器上，在服务器上关掉了<code>Tomcat</code>然后删掉了<code>webapps</code>文件夹下的War问价以及对应的文件夹。</p>\n<p>紧接着上传了新的<code>War</code>文件并构建了数据库之后再启动<code>Tomcat</code>就发现命令行里跑几句代码之后命令行就没了。</p>\n<p>百度了很多方法说在<code>StatrUp</code>最末加上<code>PAUSE</code>，于是看到了这样一段代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NOTE: Picked up JDK_JAVA_OPTIONS:  --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED</span><br></pre></td></tr></table></figure>\n<p>于是乎百度Google找了几个小时也没弄明白，回到<code>Tomcat</code>的<code>Conf</code>文件夹下查看日志多次报<code>A child container failed during start</code>的错误。</p>\n<p>在百度之后看到了<code>server.Xml</code>，于是回到该文件中查看配置的路径，发现这样一句话</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Context</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">docBase</span>=<span class=\"string\">&quot;C:\\apache-tomcat-9.0.7\\webapps\\......&quot;</span> <span class=\"attr\">debug</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">reloadable</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure>\n<p>其中配置的文件路径俨然是之前的项目名&#x3D; &#x3D;！</p>\n<p>于是光速改掉之后再启动<code>StartUp</code>发现已经可以启动了，然后新的页面也可以访问。（mmp）</p>\n<p>这么一点小问题能折腾这么久也是挺佩服自己……再加上昨天还能犯忘记导入jar包这种错误真是内心全是波澜。</p>\n"},{"_content":"# 云服务器：个人网站初体验\n\n折腾了一天，终于算是跌跌撞撞的入了门hhhh\n\n## 1. 登录云服务器\n起初想到这个是打算往云服务器里copy文件，然后找到了这种方式。\n\n运行 - mstsc，在计算机中填入对应的云服务器公网ip，为了数据共享，还要在本地资源中进行设置\n\n![mstsc](https://upload-images.jianshu.io/upload_images/13085799-b8f7f96474772e40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![远程桌面连接](https://upload-images.jianshu.io/upload_images/13085799-e86670de65af607a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![本地资源详细信息](https://upload-images.jianshu.io/upload_images/13085799-11431f1add22fc6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![连接](https://upload-images.jianshu.io/upload_images/13085799-0aae73ffd0381b61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\ntip：在弹出填入凭证时需要注意，凭证是云服务器的用户名和对应的账户密码（比如：Administrator和123456）\n\n成功登陆后可以看到自己的云服务器界面，这里我选择的是Windows，容易上手（虽然很早就知道服务器就是一台不关机的电脑，但是看到那个开机画面还是兴奋= =！）。\n\n![云服务器](https://upload-images.jianshu.io/upload_images/13085799-724223ccff4810c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2. 配置运行环境\n这一步就不再过多的赘述了- -无非就是该装软件的装该配置环境变量的配置。。。\n\n# 3. 部署web项目\n在eclipse中完成项目的编写后，右键项目 - 导出为war包。\n\n![导出](https://upload-images.jianshu.io/upload_images/13085799-d6e20e8b8b28866f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![war文件](https://upload-images.jianshu.io/upload_images/13085799-4459a545c9213052.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n选择下一步之后选择位置后，我们就得到了一个war文件\n\n![image.png](https://upload-images.jianshu.io/upload_images/13085799-3ccf28f17007eb4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\ntip:需要注意的，使用了数据库的项目也需要导出对应的sql文件\n\n![image.png](https://upload-images.jianshu.io/upload_images/13085799-9fd6ab28d0ab4eff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n之后将得到的两个文件（war，sql）放到云服务器上。\n\n- war文件放到tomcat安装目录下的webapps里\n![image.png](https://upload-images.jianshu.io/upload_images/13085799-0b4b4b7a52284b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- sql文件则导入对应的数据库完成数据库的还原。\n\n- 启动apache-tomcat-9.0.7\\bin\\startup.exe文件后，在浏览器中输入对应的文件目录`localhost:8080//xxxx//welcome.jsp`即可看到如下运行结果\n![在服务器运行页面](https://upload-images.jianshu.io/upload_images/13085799-31ae54c93c281891.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n此时在不关闭tomcat的情况下，我们可以在任意电脑访问到此页面，只需要将localhost替换为云服务器的IP就可以了。\n\n## 4. 更改配置使得可以通过ip地址直接访问\n\n很容易发现以上步骤虽然可以使页面正常发布与被访问，路径却过于冗长，于是我们通过修改配置文件直接使用ip地址访问页面。\n### 4.1. 修改sever.xml文件\n在`apache-tomcat-9.0.7\\conf`目录下找到sever.xml文件，用记事本打开，将端口号修改为80\n![修改端口号](https://upload-images.jianshu.io/upload_images/13085799-5c32fe2066684dbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n######在<host>标签中添加如下代码\n~~~xml\n<Context path=\"\" docBase=\"C:\\apache-tomcat-9.0.7\\webapps\\......\" debug=\"0\" reloadable=\"true\" /> \n~~~\n其中docBase指的是项目目录\n\n![添加代码](https://upload-images.jianshu.io/upload_images/13085799-9a0fc8639deb8103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 4.2. 修改web.xml文件\n在`apache-tomcat-9.0.7\\webapps`目录下找到自己的项目目录，进入`WEB-INF`目录找到web.xml文件，用记事本打开并添加如下代码\n\n~~~xml\n<welcome-file>Welcome.jsp</welcome-file>\n~~~\n\n中间的页面为要访问的页面\n\n![添加代码](https://upload-images.jianshu.io/upload_images/13085799-b358434fe1a9f461.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n保存之后重启tomcat后就可以使用IP访问页面啦\n\n![使用IP访问页面](https://upload-images.jianshu.io/upload_images/13085799-4e31dd806c1bbb95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n\n\n","source":"_posts/云服务器：个人网站初体验.md","raw":"# 云服务器：个人网站初体验\n\n折腾了一天，终于算是跌跌撞撞的入了门hhhh\n\n## 1. 登录云服务器\n起初想到这个是打算往云服务器里copy文件，然后找到了这种方式。\n\n运行 - mstsc，在计算机中填入对应的云服务器公网ip，为了数据共享，还要在本地资源中进行设置\n\n![mstsc](https://upload-images.jianshu.io/upload_images/13085799-b8f7f96474772e40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![远程桌面连接](https://upload-images.jianshu.io/upload_images/13085799-e86670de65af607a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![本地资源详细信息](https://upload-images.jianshu.io/upload_images/13085799-11431f1add22fc6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![连接](https://upload-images.jianshu.io/upload_images/13085799-0aae73ffd0381b61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\ntip：在弹出填入凭证时需要注意，凭证是云服务器的用户名和对应的账户密码（比如：Administrator和123456）\n\n成功登陆后可以看到自己的云服务器界面，这里我选择的是Windows，容易上手（虽然很早就知道服务器就是一台不关机的电脑，但是看到那个开机画面还是兴奋= =！）。\n\n![云服务器](https://upload-images.jianshu.io/upload_images/13085799-724223ccff4810c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2. 配置运行环境\n这一步就不再过多的赘述了- -无非就是该装软件的装该配置环境变量的配置。。。\n\n# 3. 部署web项目\n在eclipse中完成项目的编写后，右键项目 - 导出为war包。\n\n![导出](https://upload-images.jianshu.io/upload_images/13085799-d6e20e8b8b28866f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![war文件](https://upload-images.jianshu.io/upload_images/13085799-4459a545c9213052.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n选择下一步之后选择位置后，我们就得到了一个war文件\n\n![image.png](https://upload-images.jianshu.io/upload_images/13085799-3ccf28f17007eb4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\ntip:需要注意的，使用了数据库的项目也需要导出对应的sql文件\n\n![image.png](https://upload-images.jianshu.io/upload_images/13085799-9fd6ab28d0ab4eff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n之后将得到的两个文件（war，sql）放到云服务器上。\n\n- war文件放到tomcat安装目录下的webapps里\n![image.png](https://upload-images.jianshu.io/upload_images/13085799-0b4b4b7a52284b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- sql文件则导入对应的数据库完成数据库的还原。\n\n- 启动apache-tomcat-9.0.7\\bin\\startup.exe文件后，在浏览器中输入对应的文件目录`localhost:8080//xxxx//welcome.jsp`即可看到如下运行结果\n![在服务器运行页面](https://upload-images.jianshu.io/upload_images/13085799-31ae54c93c281891.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n此时在不关闭tomcat的情况下，我们可以在任意电脑访问到此页面，只需要将localhost替换为云服务器的IP就可以了。\n\n## 4. 更改配置使得可以通过ip地址直接访问\n\n很容易发现以上步骤虽然可以使页面正常发布与被访问，路径却过于冗长，于是我们通过修改配置文件直接使用ip地址访问页面。\n### 4.1. 修改sever.xml文件\n在`apache-tomcat-9.0.7\\conf`目录下找到sever.xml文件，用记事本打开，将端口号修改为80\n![修改端口号](https://upload-images.jianshu.io/upload_images/13085799-5c32fe2066684dbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n######在<host>标签中添加如下代码\n~~~xml\n<Context path=\"\" docBase=\"C:\\apache-tomcat-9.0.7\\webapps\\......\" debug=\"0\" reloadable=\"true\" /> \n~~~\n其中docBase指的是项目目录\n\n![添加代码](https://upload-images.jianshu.io/upload_images/13085799-9a0fc8639deb8103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 4.2. 修改web.xml文件\n在`apache-tomcat-9.0.7\\webapps`目录下找到自己的项目目录，进入`WEB-INF`目录找到web.xml文件，用记事本打开并添加如下代码\n\n~~~xml\n<welcome-file>Welcome.jsp</welcome-file>\n~~~\n\n中间的页面为要访问的页面\n\n![添加代码](https://upload-images.jianshu.io/upload_images/13085799-b358434fe1a9f461.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n保存之后重启tomcat后就可以使用IP访问页面啦\n\n![使用IP访问页面](https://upload-images.jianshu.io/upload_images/13085799-4e31dd806c1bbb95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n\n\n","slug":"云服务器：个人网站初体验","published":1,"date":"2022-05-03T08:46:25.142Z","updated":"2022-05-03T08:46:25.142Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdug001sr2ve9cbs8pro","content":"<h1 id=\"云服务器：个人网站初体验\"><a href=\"#云服务器：个人网站初体验\" class=\"headerlink\" title=\"云服务器：个人网站初体验\"></a>云服务器：个人网站初体验</h1><p>折腾了一天，终于算是跌跌撞撞的入了门hhhh</p>\n<h2 id=\"1-登录云服务器\"><a href=\"#1-登录云服务器\" class=\"headerlink\" title=\"1. 登录云服务器\"></a>1. 登录云服务器</h2><p>起初想到这个是打算往云服务器里copy文件，然后找到了这种方式。</p>\n<p>运行 - mstsc，在计算机中填入对应的云服务器公网ip，为了数据共享，还要在本地资源中进行设置</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-b8f7f96474772e40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"mstsc\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-e86670de65af607a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"远程桌面连接\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-11431f1add22fc6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"本地资源详细信息\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-0aae73ffd0381b61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"连接\"></p>\n<p>tip：在弹出填入凭证时需要注意，凭证是云服务器的用户名和对应的账户密码（比如：Administrator和123456）</p>\n<p>成功登陆后可以看到自己的云服务器界面，这里我选择的是Windows，容易上手（虽然很早就知道服务器就是一台不关机的电脑，但是看到那个开机画面还是兴奋&#x3D; &#x3D;！）。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-724223ccff4810c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"云服务器\"></p>\n<h2 id=\"2-配置运行环境\"><a href=\"#2-配置运行环境\" class=\"headerlink\" title=\"2. 配置运行环境\"></a>2. 配置运行环境</h2><p>这一步就不再过多的赘述了- -无非就是该装软件的装该配置环境变量的配置。。。</p>\n<h1 id=\"3-部署web项目\"><a href=\"#3-部署web项目\" class=\"headerlink\" title=\"3. 部署web项目\"></a>3. 部署web项目</h1><p>在eclipse中完成项目的编写后，右键项目 - 导出为war包。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-d6e20e8b8b28866f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"导出\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-4459a545c9213052.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"war文件\"></p>\n<p>选择下一步之后选择位置后，我们就得到了一个war文件</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-3ccf28f17007eb4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>tip:需要注意的，使用了数据库的项目也需要导出对应的sql文件</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-9fd6ab28d0ab4eff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>之后将得到的两个文件（war，sql）放到云服务器上。</p>\n<ul>\n<li><p>war文件放到tomcat安装目录下的webapps里<br><img src=\"https://upload-images.jianshu.io/upload_images/13085799-0b4b4b7a52284b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n</li>\n<li><p>sql文件则导入对应的数据库完成数据库的还原。</p>\n</li>\n<li><p>启动apache-tomcat-9.0.7\\bin\\startup.exe文件后，在浏览器中输入对应的文件目录<code>localhost:8080//xxxx//welcome.jsp</code>即可看到如下运行结果<br><img src=\"https://upload-images.jianshu.io/upload_images/13085799-31ae54c93c281891.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"在服务器运行页面\"></p>\n</li>\n</ul>\n<p>此时在不关闭tomcat的情况下，我们可以在任意电脑访问到此页面，只需要将localhost替换为云服务器的IP就可以了。</p>\n<h2 id=\"4-更改配置使得可以通过ip地址直接访问\"><a href=\"#4-更改配置使得可以通过ip地址直接访问\" class=\"headerlink\" title=\"4. 更改配置使得可以通过ip地址直接访问\"></a>4. 更改配置使得可以通过ip地址直接访问</h2><p>很容易发现以上步骤虽然可以使页面正常发布与被访问，路径却过于冗长，于是我们通过修改配置文件直接使用ip地址访问页面。</p>\n<h3 id=\"4-1-修改sever-xml文件\"><a href=\"#4-1-修改sever-xml文件\" class=\"headerlink\" title=\"4.1. 修改sever.xml文件\"></a>4.1. 修改sever.xml文件</h3><p>在<code>apache-tomcat-9.0.7\\conf</code>目录下找到sever.xml文件，用记事本打开，将端口号修改为80<br><img src=\"https://upload-images.jianshu.io/upload_images/13085799-5c32fe2066684dbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改端口号\"><br>######在<host>标签中添加如下代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Context</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">docBase</span>=<span class=\"string\">&quot;C:\\apache-tomcat-9.0.7\\webapps\\......&quot;</span> <span class=\"attr\">debug</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">reloadable</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure>\n<p>其中docBase指的是项目目录</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-9a0fc8639deb8103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加代码\"></p>\n<h3 id=\"4-2-修改web-xml文件\"><a href=\"#4-2-修改web-xml文件\" class=\"headerlink\" title=\"4.2. 修改web.xml文件\"></a>4.2. 修改web.xml文件</h3><p>在<code>apache-tomcat-9.0.7\\webapps</code>目录下找到自己的项目目录，进入<code>WEB-INF</code>目录找到web.xml文件，用记事本打开并添加如下代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">welcome-file</span>&gt;</span>Welcome.jsp<span class=\"tag\">&lt;/<span class=\"name\">welcome-file</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>中间的页面为要访问的页面</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-b358434fe1a9f461.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加代码\"></p>\n<p>保存之后重启tomcat后就可以使用IP访问页面啦</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-4e31dd806c1bbb95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"使用IP访问页面\"></p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"云服务器：个人网站初体验\"><a href=\"#云服务器：个人网站初体验\" class=\"headerlink\" title=\"云服务器：个人网站初体验\"></a>云服务器：个人网站初体验</h1><p>折腾了一天，终于算是跌跌撞撞的入了门hhhh</p>\n<h2 id=\"1-登录云服务器\"><a href=\"#1-登录云服务器\" class=\"headerlink\" title=\"1. 登录云服务器\"></a>1. 登录云服务器</h2><p>起初想到这个是打算往云服务器里copy文件，然后找到了这种方式。</p>\n<p>运行 - mstsc，在计算机中填入对应的云服务器公网ip，为了数据共享，还要在本地资源中进行设置</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-b8f7f96474772e40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"mstsc\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-e86670de65af607a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"远程桌面连接\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-11431f1add22fc6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"本地资源详细信息\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-0aae73ffd0381b61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"连接\"></p>\n<p>tip：在弹出填入凭证时需要注意，凭证是云服务器的用户名和对应的账户密码（比如：Administrator和123456）</p>\n<p>成功登陆后可以看到自己的云服务器界面，这里我选择的是Windows，容易上手（虽然很早就知道服务器就是一台不关机的电脑，但是看到那个开机画面还是兴奋&#x3D; &#x3D;！）。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-724223ccff4810c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"云服务器\"></p>\n<h2 id=\"2-配置运行环境\"><a href=\"#2-配置运行环境\" class=\"headerlink\" title=\"2. 配置运行环境\"></a>2. 配置运行环境</h2><p>这一步就不再过多的赘述了- -无非就是该装软件的装该配置环境变量的配置。。。</p>\n<h1 id=\"3-部署web项目\"><a href=\"#3-部署web项目\" class=\"headerlink\" title=\"3. 部署web项目\"></a>3. 部署web项目</h1><p>在eclipse中完成项目的编写后，右键项目 - 导出为war包。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-d6e20e8b8b28866f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"导出\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-4459a545c9213052.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"war文件\"></p>\n<p>选择下一步之后选择位置后，我们就得到了一个war文件</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-3ccf28f17007eb4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>tip:需要注意的，使用了数据库的项目也需要导出对应的sql文件</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-9fd6ab28d0ab4eff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<p>之后将得到的两个文件（war，sql）放到云服务器上。</p>\n<ul>\n<li><p>war文件放到tomcat安装目录下的webapps里<br><img src=\"https://upload-images.jianshu.io/upload_images/13085799-0b4b4b7a52284b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n</li>\n<li><p>sql文件则导入对应的数据库完成数据库的还原。</p>\n</li>\n<li><p>启动apache-tomcat-9.0.7\\bin\\startup.exe文件后，在浏览器中输入对应的文件目录<code>localhost:8080//xxxx//welcome.jsp</code>即可看到如下运行结果<br><img src=\"https://upload-images.jianshu.io/upload_images/13085799-31ae54c93c281891.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"在服务器运行页面\"></p>\n</li>\n</ul>\n<p>此时在不关闭tomcat的情况下，我们可以在任意电脑访问到此页面，只需要将localhost替换为云服务器的IP就可以了。</p>\n<h2 id=\"4-更改配置使得可以通过ip地址直接访问\"><a href=\"#4-更改配置使得可以通过ip地址直接访问\" class=\"headerlink\" title=\"4. 更改配置使得可以通过ip地址直接访问\"></a>4. 更改配置使得可以通过ip地址直接访问</h2><p>很容易发现以上步骤虽然可以使页面正常发布与被访问，路径却过于冗长，于是我们通过修改配置文件直接使用ip地址访问页面。</p>\n<h3 id=\"4-1-修改sever-xml文件\"><a href=\"#4-1-修改sever-xml文件\" class=\"headerlink\" title=\"4.1. 修改sever.xml文件\"></a>4.1. 修改sever.xml文件</h3><p>在<code>apache-tomcat-9.0.7\\conf</code>目录下找到sever.xml文件，用记事本打开，将端口号修改为80<br><img src=\"https://upload-images.jianshu.io/upload_images/13085799-5c32fe2066684dbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改端口号\"><br>######在<host>标签中添加如下代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Context</span> <span class=\"attr\">path</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">docBase</span>=<span class=\"string\">&quot;C:\\apache-tomcat-9.0.7\\webapps\\......&quot;</span> <span class=\"attr\">debug</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"attr\">reloadable</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure>\n<p>其中docBase指的是项目目录</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-9a0fc8639deb8103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加代码\"></p>\n<h3 id=\"4-2-修改web-xml文件\"><a href=\"#4-2-修改web-xml文件\" class=\"headerlink\" title=\"4.2. 修改web.xml文件\"></a>4.2. 修改web.xml文件</h3><p>在<code>apache-tomcat-9.0.7\\webapps</code>目录下找到自己的项目目录，进入<code>WEB-INF</code>目录找到web.xml文件，用记事本打开并添加如下代码</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">welcome-file</span>&gt;</span>Welcome.jsp<span class=\"tag\">&lt;/<span class=\"name\">welcome-file</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>中间的页面为要访问的页面</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-b358434fe1a9f461.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加代码\"></p>\n<p>保存之后重启tomcat后就可以使用IP访问页面啦</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/13085799-4e31dd806c1bbb95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"使用IP访问页面\"></p>\n"},{"title":"从Rails视角看现代前端——换一种方式实现SPA","date":"2021-07-08T12:25:00.000Z","_content":"# 前言\n其实想写这篇文很久了……\n\n从毕业实习接触 `Rails` 到现在两年多了。一开始是基于 `Rails` 框架来给 `Android` 客户端提供 `API` 接口，后来也尝试在 `Rails` 上倒腾了一些前端的东西，说从 `Rails` 中受益匪浅是一点都不夸张的。\n\n`Ruby On Rails` 作为经典的 `MVC` 框架，在前端领域有着自己独到的见解，在学习的过程中也不断的让我反思自己曾经信奉的那些东西是否过于片面。\n\n本文将简单的分享 `Rails` 框架的前端技术发展历程，亦是对自己摸索的总结，在这之前有一点很重要那就是：**本文没有战争。**\n\n---\n\n# 当我们今天谈论起前端，我们更多的是在谈论什么？\n试想一个问题：如果今天有两位前端工程师碰面，他们大概会聊什么？\n\n我的脑子里很快浮现出一些关键字：`vue`, `react`, `angular`, `webpack`, `vite`, `redux`, 跨平台，小程序，组件化，工程化，微前端……\n\n相信对于大部分前端工程师来说，我们工作的每一天都在使用或者探讨这些东西。\n\n不难发现，这些东西的背后有着一个很基本的共同逻辑：如何更好的基于 `JavaScript` 来完成页面的构建。\n\n于是我们推导出一个结论——当今天我们聊起前端，我们更多的是在谈论以 `JS Render` 为基础的技术体系。\n\n于是问题来了……我们真的只有 `JS Render` 吗？\n\n让我们简单的过一下前端技术发展经历的几个比较典型的阶段：\n1. `MVC` 时代，通过服务端语言开发的模板引擎，动态，快速的生成 `HTML` 页面。关键字：`JSP`, `ASP` 等。\n   - 优点：开发效率高，复杂程度低。\n   - 缺点：结构混乱，交互体验差，分工不明确。\n2. `AJAX` 时代，通过 `AJAX` 显著改善了交互的问题，初显分离之态。关键字：`AJXA`, `JQuery` 等。\n   - 优点：交互效果显著改善。\n   - 缺点：依赖 `JavaScript` 带来了大量的兼容问题和性能问题，以及代码结构依然混乱，且大量依赖于 `AJAX` 实现的页面出现了 `SEO` 问题。\n3. `SPA` 时代，通过 `JavaScript` 实现的渲染引擎，直接由 `JS` 完成页面的渲染，前后端完全分离。关键字：`vue`, `react`, `ajax`, 前后端分离等。\n   - 优点：富客户端，交互效果起飞，以工程化的方式解决了代码混乱的问题，人员分工明确。\n   - 缺点：依然没有解决 `JavaScript` 带来的兼容问题与 `SEO` 问题，同时渲染引擎加入了渲染生命周期，以及各种数据抽象层提高了编码的心智负担。\n\n以上的列举不算特别完整和严谨，但大体上能够说明前端技术发展历程的主要思路中，有两个比较重要的点：\n1. 如何更高效的组织代码，解决代码结构混乱的问题。\n2. 如何解决用户体验差的问题。\n\n而此时，我们就不得不回过头来简单的探讨一下过去的 `MVC` 架构下的前端到底是怎样的了。\n\n---\n\n# MVC下的前端开发是什么样子？\n相信说到 `MVC` 架构下的前端开发，不少经验丰富的前端工程师会有一些久远的回忆，一些刻板印象涌上心头：\n1. 开发时 `HTML` 与服务端语言混编。\n2. 稍微复杂的需求需要编写大量 `DOM` 操作来实现。\n3. 交互体验差，每一次换页都需要重新加载服务端资源。\n4. ……\n\n以 `Rails` 为例，`MVC` 的 `View` 层通常使用模板引擎技术来实现快速生成 `HTML`, 其工作原理很简单，既通过服务端语言来组合 `HTML` 片段，例如下面的代码是一种名为 `erb` 的模板引擎，它通过 `Ruby` 来生成一段列表标签。\n\n```erb\n<ul>\n  <%- @books.map do |book| %>\n    <li><%= book[:name] %></li>\n  <%- end %>\n</ul>\n```\n最终得到的 `HTML` 被发送给浏览器端，渲染出结果：\n![image.png](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/1.webp)\n\n我们同样可以为这样的结构编写 `CSS`, `JavaScript`，但就像传统的静态页一样，我们只能在每一个页面单独的引入该页面要使用的 `CSS` 与 `JavaScript` 文件，且在缺乏构建工具的情况下，我们将无缘使用 `Less`, `Sass` 等预处理技术。\n\n最终当我们完成代码的编写后，它可能看起来就像这样：\n\n![图为 GitLab 源码中的视图，使用的模板引擎是 HAML](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/2.webp)\n\n而其交互体验可能就像这样：\n![图例为某些使用 JSP 开发的系统](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/3.webp)\n\n\n正如前面所说，这样的项目有几个很要命的问题：\n1. 代码结构的问题：模板引擎的语法并不完全与 `HTML` 一致，最好的例子就是上面的 `HAML`。同时由于混杂了大量的服务端逻辑，它要求开发人员需要对后端逻辑有一定的了解。\n2. 交互体验的问题：传统的 `MVC` 在访问链接，提交表单时，往往伴随浏览器的刷新行为，而每一次刷新都会导致浏览器重新拉取资源与页面渲染，交互体验极差。\n3. 分工不明确，事实上从模板引擎的角度来看，能够更好完成编码的反而是更熟悉服务端开发的人员，并非以编写页面为擅长的前端开发人员。\n4. 缺少必要的构建工具，没有办法使用更高效的开发技术如 `Sass`，`ECMAScript` 的部分新特性。\n5. 资源管理不合理，需要多次重复拉取相同的资源文件。\n\n站在今天的视角我们很容易理解这些问题，也能很容易想到对策。\n\n而站在产品和用户体验的角度，我们首先要解决的是交互部分的问题，让页面无刷新更新最简单的方法就是 `AJAX` 。\n\n---\n# AJAX: 通过局部刷新来提升用户体验\n\n`AJAX` 可以帮助我们在不刷新浏览器的情况下完成局部更新，实现更高效可用的交互。`AJAX` 作为一项成熟的技术发展已经接近 20 年了，这里不再进行赘述了。\n\n简单看一下通过 `AJAX` 改造前后的页面跳转效果\n\n![不使用ajax时的页面跳转](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/4.webp)\n\n![使用ajax时的页面跳转](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/5.webp) \n\n但 `AJAX` 的引入并不是没有代价的，完全依靠 `AJAX` 来动态更新的数据没有办法获得 `SEO` 的支持。同时使用 `AJAX` 意味着需要编写些许的 `JavaScript` 代码来完成 `DOM` 节点的更新操作。另一个更复杂的问题在于，当我们期望通过 `AJAX` 来完成整个应用的无刷新换页、提交时，意味着我们有大量的 `HTML` 会在 `JavaScript` 中动态的插入，即由此来完成页面的局部刷新。此时，代码的可维护性大大的降低，最终化为一头失控的猛兽。  \n\n难道我们一定要在完全由 `JS Redner` 的环境里才能实现浏览器的无缝刷新吗？其实不然。\n\n---\n\n# Turbolinks：PJAX的魔法\n`Rails` 在 4.0 版本默认引入了一个扩展—— `Turbolinks`。\n\n`Turbolinks` 是一个轻量，但略带侵略性的 `JavaScript` 库。关于它的一切，其实要从更早的一项技术说起——`PJAX`.\n\n`PJAX` 是一项简单易懂却很有效的技术，在它的 `GitHub` 页上有这样的介绍：`PJAX = AJAX + pushState`. \n\n其工作原理很简单：\n1. 当在页面中点击一个 `a` 标签，或提交 `form` 表单时，并非以浏览器的默认行为进行跳转或提交，而是以 `xhr` 的方式请求目标地址。\n2. 服务端在完成请求的处理后，依然基于模板引擎的技术返回渲染完成后的静态 `HTML` 片段。\n3. 将服务端返回的 `HTML` 片段替换到当前页面的指定位置。\n4. 使用 `history.pushState` 更新浏览器当前的 `URL` 以正常维护浏览器的地址栏。\n\n`PJAX` 将上述的步骤封装为一个方法，开发者可以快速的实现指定节点的局部渲染：\n\n```javascript\n$(document).pjax('a', '#pjax-container');\n```\n\n整理一下思路，看似无奇的操作背后隐藏着哪些细节：\n1. 可以有选择的替换页面的部分标签或全部标签来实现局部刷新。\n2. 由于指向的超链接本质上依然返回 `HTML`, 因而不影响 `SEO` 效果。\n3. 由于返回的部分会被更新到视图中，因而服务端在 `PJAX` 请求的页面应当仅返回 `HTML` 片段而非完整的 `HTML` 页。\n\n`Turbolinks` 是 `Rails` 基于 `PJAX` 的再实现，它吸取了 `PJAX` 的思路，同时还做出了改进和扩展。\n\n相比 `PJAX` 中隐式的条件需要调整服务端渲染的片段，`Turbolinks` 更加大胆的选择了让服务端照常返回完整的 `HTML` 页，而后在本地对页面的 `head` 标签进行合并，同时将 `body` 标签完整的替换到当前页面以实现页面的无缝刷新。\n\n这样做的第一大好处是，当应用运行在不支持 `history.pushState` 的环境时，由于服务端照常返回了完整的页面，可以实现优雅降级，浏览器依然能够正常的加载页面。\n\n第二大好处在于，在这种策略之下 `Turbolink` 不需要开发者手动的指定节点进行局部渲染，一经安装，整个应用都自动实现了无缝刷新。\n\n第三大好处，`Turbolinks` 合并的 `head` 标签中，不会拉取重复的资源，减少了资源文件的重复加载。\n\n除此之外 `Turbolinks` 还扩充了部分功能，其中比较典型的包括：\n\n1. 在页面加载完成后，通过 `Node.cloneNode()` 来缓存页面，使得在网络断开期间也能访问已经缓存的页面。\n2. 在 `Turbolinks` 换页期间维护了一个内部的进度条用来向用户展示 `loading` 状态，与其它的特性相同，它不需要用户编写任何额外的代码。\n\n![turbolinks换页](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/6.webp)\n\n观察上图，注意几个细节：\n1. 点击链接时，浏览器并没有刷新。\n2. 页面更新前后浏览器顶部自己维护了加载的进度条。\n3. 页面切换时，`NetWork` 里实际发送的是 `xhr` 类型的请求。\n4. 请求返回的是完整的 `HTML` 页。\n\n总结一下，`Turbolinks` 是一个吸收了 `PJAX` 思路，以最低成本实现更高交互的轻量级 `JavaScript` 库。\n\n说完了 `Turbolinks` 的优点，我们还得说一说 `Turbolinks` 的缺点，毕竟没有哪一项技术是完美的。\n\n`Turbolinks` 的存在的第一个问题，由 `PJAX` 继承而来，且由于 `Turbolinks` 机制上的改进，这个问题被更加放大。当节点被动态添加至页面时，有一个我们不得不注意到一个问题：已经注册的 `JavaScript` 事件如何处理？\n\n在使用 `PJAX` 的时候，我们仅添加片段到页面中，并不太会经常出现需要给这些节点添加移出事件的情况。而当整个页面都被替换掉的时候，问题就变得突出了，其问题具体来说体现在：当页面被替换后，由于浏览器没有刷新，当前页面注册的事件、设置的定时器等均依然有效，相对来说下一个页面渲染时的环境并不纯净。此时如果某一个行为触发了上一个页面的事件，则会产生不可预期的影响。另一层考虑则是这些反复留存下来的事件本质上也会造成内存泄露。\n\n解决这一问题的方法从整体思路上说是统一的，既使操作幂等。\n\n`Turbolinks` 提供了换页生命周期的钩子函数，使得可以在换页后做一些事情：\n\n```javascript\ndocument.addEventListener(\"turbolinks:load\", function() {\n  // ...\n})\n```\n请注意，正是由于页面的生命周期发生了变化，实际由 `Turbolinks` 维护的页面只会执行一次 `DOMContentLoaded` 事件，因而如果期望某一行为始终在页面加载后执行，则应该使用 `turbolinks:load` 来替换 `onload`, `DOMContentLoaded` 事件。\n\n解决上述问题具体的方式包括：\n1. 在 `Turbolinks` 对应的生命周期里挂载和移除事件，计时器等。\n2. 使用事件委托，本质依然是幂等，只当节点存在时触发事件。\n3. 见下文。\n\n另外，`Turbolinks` 还存在的另一个问题则来源于 `addEventListener` 方法，在多次换页过程中触发的 `document.addEventListener` 会反复添加事件监听，这样会导致换页后依然能够执行上一个页面 `turbolinks:load` 生命周期里的内容。此时，生命周期内的操作幂等性就变得更加重要了。\n\n---\n# Turbolinks Prefetch：预加载的新思路\n当提到 `Turbolinks` 时，有一个相关衍生的生态组件就不得不拿出来聊一聊了——`Turbolink Prefetch`。\n\n正如 `Prefetch` 这个名字一样，`Turbolinks Prefetch` 会进行预加载操作以提升页面的访问速度，其原理实际是一种叫做 `InstantClick` 技术。主要原理为：当用户鼠标置于链接上时，提前拉取目标地址的页面并缓存，当用户点击鼠标时直接从缓存中读取该页面。\n\n![turbolinks-prefetch](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/7.webp)\n\n观察上图：\n1. 当鼠标经过部分链接时，观察 `NetWork` 自动发送了请求。\n2. 往上滚动时，虽然鼠标再次经过重复的链接，单并没有重复发送请求。\n3. 点击已请求过的链接，`NetWork` 并没有发送其它请求，仅在页面加载后请求了页面上的资源文件。\n4. 与前面 `Turbolinks` 的演示相同，对页面的请求依然使用使用的是 `xhr` 方式。\n\n虽然从技术角度来说，借助 `Turbolinks` 已有的缓存机制实现这一功能似乎并没有什么太大的难度，但我认为这样的思路却非常值得学习：即利用用户的碎片时间提前拉取资源以减少用户的等待时间。从目前来看，这一思路在混合 `APP` 实现 `WebView` 秒开时起到了非常不错的效果。\n\n---\n## Assets Pipeline：Rails 自己的构建工具\n在我们谈论 `MVC` 下实现的前端有哪些问题时，提到了这样几个问题：\n1. 缺少必要的构建工具，没有办法使用更高效的开发技术如 Sass，ECMAScript 的部分新特性。\n2. 资源管理不合理，需要多次重复拉取相同的资源文件。\n3. ……\n\n前面所介绍的 `Turbolinks`，`Turbolinks Prefetch` 等均是来自于交互方面的优化。而上面这些问题则指向了构建工具这一话题。\n\n在今天，当我们开发完成一个前端项目，通常进入生产环境前需要对源代码进行一系列的操作，它们包括：\n1. 编译代码，把 `Sass`, `Less`, 以及高版本的 `ECMAScript` 等非浏览器可以直接执行的内容编译成低版本代码或原生代码；\n2. 压缩代码，去除代码中不必要的换行，注释等，减少文件体积；\n3. 混淆代码，将 `JS` 代码编译为不可读的丑化代码，进一步缩减文件体积；\n4. 合并文件，减少 `HTTP` 请求次数；\n5. 通过摘要算法计算 `Hash` 作为静态资源文件的文件名，使资源可以根据文件内容的变化来合理利用浏览器缓存；\n\n而实现这些操作则需要依赖构建工具，比较有名的就是大家都熟悉的 `webpack`。\n\n实际上，`Rails` 在很早就提供了这样一套框架用于静态资源的构建和管理——`Assets Pipeline`。\n\n放在今天，我们以一名前端工程师的视角来看 `Assets Pipeline` 其实是非常容易理解的。它主要利用 `Sprockets` 这一构建工具来实现了上面描述静态资源压缩，，使得在 `MVC` 的结构下一样可以合理，优雅的管理前端资源。\n\n同时 `Assets Pipeline` 还自带了 `Sass`, `CoffeeScript` 这些从 `Ruby` 社区孵化出的前端技术的支持。其中 `Sass` 提高了编写 `CSS` 的效率。而 `CoffeeScript` 则为 `ES5` 添加了诸多有用的语法扩展。如此，在 `MVC` 结构下也能获得良好的开发体验。\n\n注意一个细节：`Assets Pipeline` 在进行生产环境的预编译行为时，本质上与现在我们运行 `npm run build` 使用 `webpack` 进行打包有着非常大的相似之处。不同之处在于，`Rails MVC` 下的前端开发并不会依赖 `JS Render` ，由此导致现代前端基于 `webpack` 构建的静态资源和 `Rails` 基于 `Assets Pipeline` 构建的静态资源在体积上有着量级的区别。\n\n正是得益于这种技术栈不依赖 `JS` 构建页面，`Assets Pipeline` 可以放心大胆的将静态资源合并为一个单文件而不用担心体积过大造成资源加载慢的问题。\n\n因而当我们查看一个 `Rails` 传统技术开发的网站，会发现它仅在浏览器第一次加载页面时，完整的拉取脚本与样式文件，而后在 `Turbolinks` 启动后，每一次换页都不会也无需拉取静态资源文件，而是仅获取需要显示的 `HTML` 内容。\n\n有一个非常有意思的点：我们的站点在用户交互上与 `SPA` 一样在首屏拉取资源，也像 `SPA` 一样在无缝换页。\n\n---\n# UJS：使用非侵入式的 JavaScript 缩减重复代码\n除了引入完整的构建体系以外，其实 `Rails` 还做有一个较为有趣的前端构建技术名为 `UJS`，它是 `Unobtrusive JavaScript` 的缩写，翻译为中文为 “非侵入式 `JavaScript`”。\n\n`UJS` 本是指将 `JS` 与页面结构分离的代码风格，而 `Rails UJS` 只是基于这样一种风格编码的前端工具库，整个扩展仅有 700+ 行代码。\n\n`Rails UJS` 内部实现了前面我们在 `PJAX` 和 `Turbolinks` 里提到的让 `a` 标签和 `form` 表单自动使用 `xhr` 提交的方法，但它并没有针对这一行为做后续的操作，而是提供了对应的事件回调。即是说，开发人员可以自由的设置某一个 `a` 标签或 `form` 表单为 `xhr` 提交，而需要做的仅仅是在该标签上增加一个 `data-remote=true` 属性，而后即可在回调中拿到对应的请求值。\n\n对比一下使用原生与使用 `Rails UJS` 实现表单 `xhr` 提交的代码\n```javascript\n// 原生\nlet form = document.querySelector(\"form\");\nform.onsubmit = function (e) {\n    e.preventDefault();\n    //阻止submit默认提交行为\n    let fd = new FormData(form); \n    fd.append('userId', '1008611');\n\n    let xhr = new XMLHttpRequest();\n    xhr.open(\"POST\",\"http://www.xxx/api/xxx\");\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            console.log(xhr.responseText)\n        }\n    }\n    xhr.send(fd);\n}\n```\n```javascript\n// 使用 rails_ujs \n// 需要在对应的标签上添加 data-remote=true 就像\n// <form data-remote=\"true\" id=\"remoteForm\" action=\"/welcome/test_render\">...</form>\ndocument.querySelector(\"#remoteLink\").addEventListener('ajax:success', function (xhr, status, err) {\n    console.log(xhr, status, err);\n});\n```\n可以看到代码会简洁很多。\n\n除此之外，`Rails UJS` 也支持了更多的 `xhr` 参数如 `method` 等，使得我们基于这种方式来构建 `xhr` 变的更快更高效，减少了大量的重复代码。\n\n另一个有趣的用法是，在通过 `xhr` 请求时，由服务端渲染一段 `JavaScript`，可以很高效的实现一些交互逻辑。但由于这种方式不便于组织 `JS` 代码文件，此处不过多展开，详情可以读扩展阅读《[Rails 用 RJS 简单有效的实现页面局部刷新](https://ruby-china.org/topics/29046)》。\n\n---\n# Stimulus：Turbolinks 幂等问题的最终解？\n`Turbolinks` 为我们提供了基本的页面交互 `SPA` 化的解决方案，使我们能以非常轻量的方式来实现一个体验极佳的站点。\n\n`Assets Pipeline` 为我们带来的构建手段。\n\n`Rails UJS` 简化了我们构建 `AJAX` 交互的代码量。\n\n但站在今天的角度来看，似乎编码体验上并没有太大的改进。我们依然在重复的码着 `JQuery`，我们也依然在重复的操作 `DOM`，甚至对于如何复用一个页面组件，我们依然没有一个合适的方式。与此同时，引入的 `Turbolinks` 带来了新的负担，编写 `JS` 代码的时候我们需要更加注意幂等性……\n\n当我们开始思考这样的问题的时候，`Stimulus` 来了。\n\n`Stimulus` 同样是一个轻量的前端库，它通过 `H5` 的 `Mutation Observer` 这一特性彻底解决了 `Turbolinks` 幂等的问题。\n\n`Mutation Observer` 可以完成 `DOM` 节点的监听，在 `DOM` 节点发生变化时，指定对应的逻辑。我们可以通俗的理解这一 `API` 为原生的 `DOM` 节点添加了自己的生命周期。\n\n直接看下面的 `Stimulus` 代码：\n```javascript\nimport { Controller } from \"stimulus\"\n\nexport default class extends Controller {\n  static values = { url: String, refreshInterval: Number }\n\n  connect() {\n    this.load()\n\n    if (this.hasRefreshIntervalValue) {\n      this.startRefreshing()\n    }\n  }\n\n  disconnect() {\n    this.stopRefreshing()\n  }\n\n  load() {\n    fetch(this.urlValue)\n      .then(response => response.text())\n      .then(html => this.element.innerHTML = html)\n  }\n\n  startRefreshing() {\n    this.refreshTimer = setInterval(() => {\n      this.load()\n    }, this.refreshIntervalValue)\n  }\n\n  stopRefreshing() {\n    if (this.refreshTimer) {\n      clearInterval(this.refreshTimer)\n    }\n  }\n}\n```\n我有理由相信写过 `vue`, `react` 组件的现代前端工程师可以没有什么压力的阅读这段代码……\n\n`Stimulus` 通过 `data-controller` 将逻辑关联到 `DOM` 节点，同时提供了对应节点的生命周期钩子函数，当节点被渲染后，会触发 `connect` 方法，而节点被销毁时会触发 `disconnect` 。同时 `Stimulus` 还支持定义状态与方法，最终这些内容被合理的挂载到节点的各位置，就像这样：\n```html\n<div data-controller=\"content-loader\"\n     data-content-loader-url-value=\"/messages.html\"\n     data-content-loader-refresh-interval-value=\"5000\"></div>\n```\n这一段代码复制于 `Stimulus` 的文档，它实现了一个可以自动异步加载页面的组件。\n\n由于节点拥有了自己的生命周期，只有当节点真正被渲染在页面上时 `Stimulus` 才会真正的执行对应的挂载逻辑，因而我们不再需要担心伴随 `Turbolinks` 的换页带来的事件绑定心智问题。\n\n同时，`Stimulus` 也完全解决了复用的问题，当需要在另一位置复用这一组件时，我们只需要为该节点添加上对应的 `data-controller` 属性即可。\n\n最后，`Stimulus` 通常在单一文件里定义组件，也就是说，基于 `Stimulus` 开发的应用不会再出现同一个 `JS` 文件里有成百上千行不知所云毫无关联的 `JavaScript` 代码的情况。\n\n---\n# 总结\n\n\n---\n# 结语（碎碎念）\n其实本来打算再倒腾下 `Hotwire` 的，但是实在时间有限……\n\n前端是一个大的领域，即使放到一个框架里，内容也是非常多的。\n\n关于 `Rails` 的前端内容大概就先写到这里了，后面如果有空还会再补充。\n\n最后放上 [Ruby China](https://ruby-china.org/) 链接，可以从交互等方面来体验一下，几乎完全与 `SPA` 类似的交互体验。\n\n---\n# 参考资料\n- [Ruby On Rails](https://github.com/rails/rails)\n- [JQuery PJAX](https://github.com/defunkt/jquery-pjax)\n- [Turbolinks](https://github.com/turbolinks/turbolinks)\n- [Turbolinks Prefetch](https://github.com/huacnlee/turbolinks-prefetch)\n- [JQuery UJS](https://github.com/rails/jquery-ujs)\n- [Rails UJS](https://github.com/rails/rails-ujs/tree/master)\n- [Stimulus](https://github.com/hotwired/stimulus)\n","source":"_posts/从Rails视角看现代前端——换一种方式实现SPA.md","raw":"---\ntitle: 从Rails视角看现代前端——换一种方式实现SPA\ndate: 2021.07.08 20:25\ntags:\n  - 前端\ncategories:\n  - 程序员的幸福：让代码变成强有力的工具\n---\n# 前言\n其实想写这篇文很久了……\n\n从毕业实习接触 `Rails` 到现在两年多了。一开始是基于 `Rails` 框架来给 `Android` 客户端提供 `API` 接口，后来也尝试在 `Rails` 上倒腾了一些前端的东西，说从 `Rails` 中受益匪浅是一点都不夸张的。\n\n`Ruby On Rails` 作为经典的 `MVC` 框架，在前端领域有着自己独到的见解，在学习的过程中也不断的让我反思自己曾经信奉的那些东西是否过于片面。\n\n本文将简单的分享 `Rails` 框架的前端技术发展历程，亦是对自己摸索的总结，在这之前有一点很重要那就是：**本文没有战争。**\n\n---\n\n# 当我们今天谈论起前端，我们更多的是在谈论什么？\n试想一个问题：如果今天有两位前端工程师碰面，他们大概会聊什么？\n\n我的脑子里很快浮现出一些关键字：`vue`, `react`, `angular`, `webpack`, `vite`, `redux`, 跨平台，小程序，组件化，工程化，微前端……\n\n相信对于大部分前端工程师来说，我们工作的每一天都在使用或者探讨这些东西。\n\n不难发现，这些东西的背后有着一个很基本的共同逻辑：如何更好的基于 `JavaScript` 来完成页面的构建。\n\n于是我们推导出一个结论——当今天我们聊起前端，我们更多的是在谈论以 `JS Render` 为基础的技术体系。\n\n于是问题来了……我们真的只有 `JS Render` 吗？\n\n让我们简单的过一下前端技术发展经历的几个比较典型的阶段：\n1. `MVC` 时代，通过服务端语言开发的模板引擎，动态，快速的生成 `HTML` 页面。关键字：`JSP`, `ASP` 等。\n   - 优点：开发效率高，复杂程度低。\n   - 缺点：结构混乱，交互体验差，分工不明确。\n2. `AJAX` 时代，通过 `AJAX` 显著改善了交互的问题，初显分离之态。关键字：`AJXA`, `JQuery` 等。\n   - 优点：交互效果显著改善。\n   - 缺点：依赖 `JavaScript` 带来了大量的兼容问题和性能问题，以及代码结构依然混乱，且大量依赖于 `AJAX` 实现的页面出现了 `SEO` 问题。\n3. `SPA` 时代，通过 `JavaScript` 实现的渲染引擎，直接由 `JS` 完成页面的渲染，前后端完全分离。关键字：`vue`, `react`, `ajax`, 前后端分离等。\n   - 优点：富客户端，交互效果起飞，以工程化的方式解决了代码混乱的问题，人员分工明确。\n   - 缺点：依然没有解决 `JavaScript` 带来的兼容问题与 `SEO` 问题，同时渲染引擎加入了渲染生命周期，以及各种数据抽象层提高了编码的心智负担。\n\n以上的列举不算特别完整和严谨，但大体上能够说明前端技术发展历程的主要思路中，有两个比较重要的点：\n1. 如何更高效的组织代码，解决代码结构混乱的问题。\n2. 如何解决用户体验差的问题。\n\n而此时，我们就不得不回过头来简单的探讨一下过去的 `MVC` 架构下的前端到底是怎样的了。\n\n---\n\n# MVC下的前端开发是什么样子？\n相信说到 `MVC` 架构下的前端开发，不少经验丰富的前端工程师会有一些久远的回忆，一些刻板印象涌上心头：\n1. 开发时 `HTML` 与服务端语言混编。\n2. 稍微复杂的需求需要编写大量 `DOM` 操作来实现。\n3. 交互体验差，每一次换页都需要重新加载服务端资源。\n4. ……\n\n以 `Rails` 为例，`MVC` 的 `View` 层通常使用模板引擎技术来实现快速生成 `HTML`, 其工作原理很简单，既通过服务端语言来组合 `HTML` 片段，例如下面的代码是一种名为 `erb` 的模板引擎，它通过 `Ruby` 来生成一段列表标签。\n\n```erb\n<ul>\n  <%- @books.map do |book| %>\n    <li><%= book[:name] %></li>\n  <%- end %>\n</ul>\n```\n最终得到的 `HTML` 被发送给浏览器端，渲染出结果：\n![image.png](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/1.webp)\n\n我们同样可以为这样的结构编写 `CSS`, `JavaScript`，但就像传统的静态页一样，我们只能在每一个页面单独的引入该页面要使用的 `CSS` 与 `JavaScript` 文件，且在缺乏构建工具的情况下，我们将无缘使用 `Less`, `Sass` 等预处理技术。\n\n最终当我们完成代码的编写后，它可能看起来就像这样：\n\n![图为 GitLab 源码中的视图，使用的模板引擎是 HAML](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/2.webp)\n\n而其交互体验可能就像这样：\n![图例为某些使用 JSP 开发的系统](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/3.webp)\n\n\n正如前面所说，这样的项目有几个很要命的问题：\n1. 代码结构的问题：模板引擎的语法并不完全与 `HTML` 一致，最好的例子就是上面的 `HAML`。同时由于混杂了大量的服务端逻辑，它要求开发人员需要对后端逻辑有一定的了解。\n2. 交互体验的问题：传统的 `MVC` 在访问链接，提交表单时，往往伴随浏览器的刷新行为，而每一次刷新都会导致浏览器重新拉取资源与页面渲染，交互体验极差。\n3. 分工不明确，事实上从模板引擎的角度来看，能够更好完成编码的反而是更熟悉服务端开发的人员，并非以编写页面为擅长的前端开发人员。\n4. 缺少必要的构建工具，没有办法使用更高效的开发技术如 `Sass`，`ECMAScript` 的部分新特性。\n5. 资源管理不合理，需要多次重复拉取相同的资源文件。\n\n站在今天的视角我们很容易理解这些问题，也能很容易想到对策。\n\n而站在产品和用户体验的角度，我们首先要解决的是交互部分的问题，让页面无刷新更新最简单的方法就是 `AJAX` 。\n\n---\n# AJAX: 通过局部刷新来提升用户体验\n\n`AJAX` 可以帮助我们在不刷新浏览器的情况下完成局部更新，实现更高效可用的交互。`AJAX` 作为一项成熟的技术发展已经接近 20 年了，这里不再进行赘述了。\n\n简单看一下通过 `AJAX` 改造前后的页面跳转效果\n\n![不使用ajax时的页面跳转](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/4.webp)\n\n![使用ajax时的页面跳转](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/5.webp) \n\n但 `AJAX` 的引入并不是没有代价的，完全依靠 `AJAX` 来动态更新的数据没有办法获得 `SEO` 的支持。同时使用 `AJAX` 意味着需要编写些许的 `JavaScript` 代码来完成 `DOM` 节点的更新操作。另一个更复杂的问题在于，当我们期望通过 `AJAX` 来完成整个应用的无刷新换页、提交时，意味着我们有大量的 `HTML` 会在 `JavaScript` 中动态的插入，即由此来完成页面的局部刷新。此时，代码的可维护性大大的降低，最终化为一头失控的猛兽。  \n\n难道我们一定要在完全由 `JS Redner` 的环境里才能实现浏览器的无缝刷新吗？其实不然。\n\n---\n\n# Turbolinks：PJAX的魔法\n`Rails` 在 4.0 版本默认引入了一个扩展—— `Turbolinks`。\n\n`Turbolinks` 是一个轻量，但略带侵略性的 `JavaScript` 库。关于它的一切，其实要从更早的一项技术说起——`PJAX`.\n\n`PJAX` 是一项简单易懂却很有效的技术，在它的 `GitHub` 页上有这样的介绍：`PJAX = AJAX + pushState`. \n\n其工作原理很简单：\n1. 当在页面中点击一个 `a` 标签，或提交 `form` 表单时，并非以浏览器的默认行为进行跳转或提交，而是以 `xhr` 的方式请求目标地址。\n2. 服务端在完成请求的处理后，依然基于模板引擎的技术返回渲染完成后的静态 `HTML` 片段。\n3. 将服务端返回的 `HTML` 片段替换到当前页面的指定位置。\n4. 使用 `history.pushState` 更新浏览器当前的 `URL` 以正常维护浏览器的地址栏。\n\n`PJAX` 将上述的步骤封装为一个方法，开发者可以快速的实现指定节点的局部渲染：\n\n```javascript\n$(document).pjax('a', '#pjax-container');\n```\n\n整理一下思路，看似无奇的操作背后隐藏着哪些细节：\n1. 可以有选择的替换页面的部分标签或全部标签来实现局部刷新。\n2. 由于指向的超链接本质上依然返回 `HTML`, 因而不影响 `SEO` 效果。\n3. 由于返回的部分会被更新到视图中，因而服务端在 `PJAX` 请求的页面应当仅返回 `HTML` 片段而非完整的 `HTML` 页。\n\n`Turbolinks` 是 `Rails` 基于 `PJAX` 的再实现，它吸取了 `PJAX` 的思路，同时还做出了改进和扩展。\n\n相比 `PJAX` 中隐式的条件需要调整服务端渲染的片段，`Turbolinks` 更加大胆的选择了让服务端照常返回完整的 `HTML` 页，而后在本地对页面的 `head` 标签进行合并，同时将 `body` 标签完整的替换到当前页面以实现页面的无缝刷新。\n\n这样做的第一大好处是，当应用运行在不支持 `history.pushState` 的环境时，由于服务端照常返回了完整的页面，可以实现优雅降级，浏览器依然能够正常的加载页面。\n\n第二大好处在于，在这种策略之下 `Turbolink` 不需要开发者手动的指定节点进行局部渲染，一经安装，整个应用都自动实现了无缝刷新。\n\n第三大好处，`Turbolinks` 合并的 `head` 标签中，不会拉取重复的资源，减少了资源文件的重复加载。\n\n除此之外 `Turbolinks` 还扩充了部分功能，其中比较典型的包括：\n\n1. 在页面加载完成后，通过 `Node.cloneNode()` 来缓存页面，使得在网络断开期间也能访问已经缓存的页面。\n2. 在 `Turbolinks` 换页期间维护了一个内部的进度条用来向用户展示 `loading` 状态，与其它的特性相同，它不需要用户编写任何额外的代码。\n\n![turbolinks换页](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/6.webp)\n\n观察上图，注意几个细节：\n1. 点击链接时，浏览器并没有刷新。\n2. 页面更新前后浏览器顶部自己维护了加载的进度条。\n3. 页面切换时，`NetWork` 里实际发送的是 `xhr` 类型的请求。\n4. 请求返回的是完整的 `HTML` 页。\n\n总结一下，`Turbolinks` 是一个吸收了 `PJAX` 思路，以最低成本实现更高交互的轻量级 `JavaScript` 库。\n\n说完了 `Turbolinks` 的优点，我们还得说一说 `Turbolinks` 的缺点，毕竟没有哪一项技术是完美的。\n\n`Turbolinks` 的存在的第一个问题，由 `PJAX` 继承而来，且由于 `Turbolinks` 机制上的改进，这个问题被更加放大。当节点被动态添加至页面时，有一个我们不得不注意到一个问题：已经注册的 `JavaScript` 事件如何处理？\n\n在使用 `PJAX` 的时候，我们仅添加片段到页面中，并不太会经常出现需要给这些节点添加移出事件的情况。而当整个页面都被替换掉的时候，问题就变得突出了，其问题具体来说体现在：当页面被替换后，由于浏览器没有刷新，当前页面注册的事件、设置的定时器等均依然有效，相对来说下一个页面渲染时的环境并不纯净。此时如果某一个行为触发了上一个页面的事件，则会产生不可预期的影响。另一层考虑则是这些反复留存下来的事件本质上也会造成内存泄露。\n\n解决这一问题的方法从整体思路上说是统一的，既使操作幂等。\n\n`Turbolinks` 提供了换页生命周期的钩子函数，使得可以在换页后做一些事情：\n\n```javascript\ndocument.addEventListener(\"turbolinks:load\", function() {\n  // ...\n})\n```\n请注意，正是由于页面的生命周期发生了变化，实际由 `Turbolinks` 维护的页面只会执行一次 `DOMContentLoaded` 事件，因而如果期望某一行为始终在页面加载后执行，则应该使用 `turbolinks:load` 来替换 `onload`, `DOMContentLoaded` 事件。\n\n解决上述问题具体的方式包括：\n1. 在 `Turbolinks` 对应的生命周期里挂载和移除事件，计时器等。\n2. 使用事件委托，本质依然是幂等，只当节点存在时触发事件。\n3. 见下文。\n\n另外，`Turbolinks` 还存在的另一个问题则来源于 `addEventListener` 方法，在多次换页过程中触发的 `document.addEventListener` 会反复添加事件监听，这样会导致换页后依然能够执行上一个页面 `turbolinks:load` 生命周期里的内容。此时，生命周期内的操作幂等性就变得更加重要了。\n\n---\n# Turbolinks Prefetch：预加载的新思路\n当提到 `Turbolinks` 时，有一个相关衍生的生态组件就不得不拿出来聊一聊了——`Turbolink Prefetch`。\n\n正如 `Prefetch` 这个名字一样，`Turbolinks Prefetch` 会进行预加载操作以提升页面的访问速度，其原理实际是一种叫做 `InstantClick` 技术。主要原理为：当用户鼠标置于链接上时，提前拉取目标地址的页面并缓存，当用户点击鼠标时直接从缓存中读取该页面。\n\n![turbolinks-prefetch](./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/7.webp)\n\n观察上图：\n1. 当鼠标经过部分链接时，观察 `NetWork` 自动发送了请求。\n2. 往上滚动时，虽然鼠标再次经过重复的链接，单并没有重复发送请求。\n3. 点击已请求过的链接，`NetWork` 并没有发送其它请求，仅在页面加载后请求了页面上的资源文件。\n4. 与前面 `Turbolinks` 的演示相同，对页面的请求依然使用使用的是 `xhr` 方式。\n\n虽然从技术角度来说，借助 `Turbolinks` 已有的缓存机制实现这一功能似乎并没有什么太大的难度，但我认为这样的思路却非常值得学习：即利用用户的碎片时间提前拉取资源以减少用户的等待时间。从目前来看，这一思路在混合 `APP` 实现 `WebView` 秒开时起到了非常不错的效果。\n\n---\n## Assets Pipeline：Rails 自己的构建工具\n在我们谈论 `MVC` 下实现的前端有哪些问题时，提到了这样几个问题：\n1. 缺少必要的构建工具，没有办法使用更高效的开发技术如 Sass，ECMAScript 的部分新特性。\n2. 资源管理不合理，需要多次重复拉取相同的资源文件。\n3. ……\n\n前面所介绍的 `Turbolinks`，`Turbolinks Prefetch` 等均是来自于交互方面的优化。而上面这些问题则指向了构建工具这一话题。\n\n在今天，当我们开发完成一个前端项目，通常进入生产环境前需要对源代码进行一系列的操作，它们包括：\n1. 编译代码，把 `Sass`, `Less`, 以及高版本的 `ECMAScript` 等非浏览器可以直接执行的内容编译成低版本代码或原生代码；\n2. 压缩代码，去除代码中不必要的换行，注释等，减少文件体积；\n3. 混淆代码，将 `JS` 代码编译为不可读的丑化代码，进一步缩减文件体积；\n4. 合并文件，减少 `HTTP` 请求次数；\n5. 通过摘要算法计算 `Hash` 作为静态资源文件的文件名，使资源可以根据文件内容的变化来合理利用浏览器缓存；\n\n而实现这些操作则需要依赖构建工具，比较有名的就是大家都熟悉的 `webpack`。\n\n实际上，`Rails` 在很早就提供了这样一套框架用于静态资源的构建和管理——`Assets Pipeline`。\n\n放在今天，我们以一名前端工程师的视角来看 `Assets Pipeline` 其实是非常容易理解的。它主要利用 `Sprockets` 这一构建工具来实现了上面描述静态资源压缩，，使得在 `MVC` 的结构下一样可以合理，优雅的管理前端资源。\n\n同时 `Assets Pipeline` 还自带了 `Sass`, `CoffeeScript` 这些从 `Ruby` 社区孵化出的前端技术的支持。其中 `Sass` 提高了编写 `CSS` 的效率。而 `CoffeeScript` 则为 `ES5` 添加了诸多有用的语法扩展。如此，在 `MVC` 结构下也能获得良好的开发体验。\n\n注意一个细节：`Assets Pipeline` 在进行生产环境的预编译行为时，本质上与现在我们运行 `npm run build` 使用 `webpack` 进行打包有着非常大的相似之处。不同之处在于，`Rails MVC` 下的前端开发并不会依赖 `JS Render` ，由此导致现代前端基于 `webpack` 构建的静态资源和 `Rails` 基于 `Assets Pipeline` 构建的静态资源在体积上有着量级的区别。\n\n正是得益于这种技术栈不依赖 `JS` 构建页面，`Assets Pipeline` 可以放心大胆的将静态资源合并为一个单文件而不用担心体积过大造成资源加载慢的问题。\n\n因而当我们查看一个 `Rails` 传统技术开发的网站，会发现它仅在浏览器第一次加载页面时，完整的拉取脚本与样式文件，而后在 `Turbolinks` 启动后，每一次换页都不会也无需拉取静态资源文件，而是仅获取需要显示的 `HTML` 内容。\n\n有一个非常有意思的点：我们的站点在用户交互上与 `SPA` 一样在首屏拉取资源，也像 `SPA` 一样在无缝换页。\n\n---\n# UJS：使用非侵入式的 JavaScript 缩减重复代码\n除了引入完整的构建体系以外，其实 `Rails` 还做有一个较为有趣的前端构建技术名为 `UJS`，它是 `Unobtrusive JavaScript` 的缩写，翻译为中文为 “非侵入式 `JavaScript`”。\n\n`UJS` 本是指将 `JS` 与页面结构分离的代码风格，而 `Rails UJS` 只是基于这样一种风格编码的前端工具库，整个扩展仅有 700+ 行代码。\n\n`Rails UJS` 内部实现了前面我们在 `PJAX` 和 `Turbolinks` 里提到的让 `a` 标签和 `form` 表单自动使用 `xhr` 提交的方法，但它并没有针对这一行为做后续的操作，而是提供了对应的事件回调。即是说，开发人员可以自由的设置某一个 `a` 标签或 `form` 表单为 `xhr` 提交，而需要做的仅仅是在该标签上增加一个 `data-remote=true` 属性，而后即可在回调中拿到对应的请求值。\n\n对比一下使用原生与使用 `Rails UJS` 实现表单 `xhr` 提交的代码\n```javascript\n// 原生\nlet form = document.querySelector(\"form\");\nform.onsubmit = function (e) {\n    e.preventDefault();\n    //阻止submit默认提交行为\n    let fd = new FormData(form); \n    fd.append('userId', '1008611');\n\n    let xhr = new XMLHttpRequest();\n    xhr.open(\"POST\",\"http://www.xxx/api/xxx\");\n    xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n            console.log(xhr.responseText)\n        }\n    }\n    xhr.send(fd);\n}\n```\n```javascript\n// 使用 rails_ujs \n// 需要在对应的标签上添加 data-remote=true 就像\n// <form data-remote=\"true\" id=\"remoteForm\" action=\"/welcome/test_render\">...</form>\ndocument.querySelector(\"#remoteLink\").addEventListener('ajax:success', function (xhr, status, err) {\n    console.log(xhr, status, err);\n});\n```\n可以看到代码会简洁很多。\n\n除此之外，`Rails UJS` 也支持了更多的 `xhr` 参数如 `method` 等，使得我们基于这种方式来构建 `xhr` 变的更快更高效，减少了大量的重复代码。\n\n另一个有趣的用法是，在通过 `xhr` 请求时，由服务端渲染一段 `JavaScript`，可以很高效的实现一些交互逻辑。但由于这种方式不便于组织 `JS` 代码文件，此处不过多展开，详情可以读扩展阅读《[Rails 用 RJS 简单有效的实现页面局部刷新](https://ruby-china.org/topics/29046)》。\n\n---\n# Stimulus：Turbolinks 幂等问题的最终解？\n`Turbolinks` 为我们提供了基本的页面交互 `SPA` 化的解决方案，使我们能以非常轻量的方式来实现一个体验极佳的站点。\n\n`Assets Pipeline` 为我们带来的构建手段。\n\n`Rails UJS` 简化了我们构建 `AJAX` 交互的代码量。\n\n但站在今天的角度来看，似乎编码体验上并没有太大的改进。我们依然在重复的码着 `JQuery`，我们也依然在重复的操作 `DOM`，甚至对于如何复用一个页面组件，我们依然没有一个合适的方式。与此同时，引入的 `Turbolinks` 带来了新的负担，编写 `JS` 代码的时候我们需要更加注意幂等性……\n\n当我们开始思考这样的问题的时候，`Stimulus` 来了。\n\n`Stimulus` 同样是一个轻量的前端库，它通过 `H5` 的 `Mutation Observer` 这一特性彻底解决了 `Turbolinks` 幂等的问题。\n\n`Mutation Observer` 可以完成 `DOM` 节点的监听，在 `DOM` 节点发生变化时，指定对应的逻辑。我们可以通俗的理解这一 `API` 为原生的 `DOM` 节点添加了自己的生命周期。\n\n直接看下面的 `Stimulus` 代码：\n```javascript\nimport { Controller } from \"stimulus\"\n\nexport default class extends Controller {\n  static values = { url: String, refreshInterval: Number }\n\n  connect() {\n    this.load()\n\n    if (this.hasRefreshIntervalValue) {\n      this.startRefreshing()\n    }\n  }\n\n  disconnect() {\n    this.stopRefreshing()\n  }\n\n  load() {\n    fetch(this.urlValue)\n      .then(response => response.text())\n      .then(html => this.element.innerHTML = html)\n  }\n\n  startRefreshing() {\n    this.refreshTimer = setInterval(() => {\n      this.load()\n    }, this.refreshIntervalValue)\n  }\n\n  stopRefreshing() {\n    if (this.refreshTimer) {\n      clearInterval(this.refreshTimer)\n    }\n  }\n}\n```\n我有理由相信写过 `vue`, `react` 组件的现代前端工程师可以没有什么压力的阅读这段代码……\n\n`Stimulus` 通过 `data-controller` 将逻辑关联到 `DOM` 节点，同时提供了对应节点的生命周期钩子函数，当节点被渲染后，会触发 `connect` 方法，而节点被销毁时会触发 `disconnect` 。同时 `Stimulus` 还支持定义状态与方法，最终这些内容被合理的挂载到节点的各位置，就像这样：\n```html\n<div data-controller=\"content-loader\"\n     data-content-loader-url-value=\"/messages.html\"\n     data-content-loader-refresh-interval-value=\"5000\"></div>\n```\n这一段代码复制于 `Stimulus` 的文档，它实现了一个可以自动异步加载页面的组件。\n\n由于节点拥有了自己的生命周期，只有当节点真正被渲染在页面上时 `Stimulus` 才会真正的执行对应的挂载逻辑，因而我们不再需要担心伴随 `Turbolinks` 的换页带来的事件绑定心智问题。\n\n同时，`Stimulus` 也完全解决了复用的问题，当需要在另一位置复用这一组件时，我们只需要为该节点添加上对应的 `data-controller` 属性即可。\n\n最后，`Stimulus` 通常在单一文件里定义组件，也就是说，基于 `Stimulus` 开发的应用不会再出现同一个 `JS` 文件里有成百上千行不知所云毫无关联的 `JavaScript` 代码的情况。\n\n---\n# 总结\n\n\n---\n# 结语（碎碎念）\n其实本来打算再倒腾下 `Hotwire` 的，但是实在时间有限……\n\n前端是一个大的领域，即使放到一个框架里，内容也是非常多的。\n\n关于 `Rails` 的前端内容大概就先写到这里了，后面如果有空还会再补充。\n\n最后放上 [Ruby China](https://ruby-china.org/) 链接，可以从交互等方面来体验一下，几乎完全与 `SPA` 类似的交互体验。\n\n---\n# 参考资料\n- [Ruby On Rails](https://github.com/rails/rails)\n- [JQuery PJAX](https://github.com/defunkt/jquery-pjax)\n- [Turbolinks](https://github.com/turbolinks/turbolinks)\n- [Turbolinks Prefetch](https://github.com/huacnlee/turbolinks-prefetch)\n- [JQuery UJS](https://github.com/rails/jquery-ujs)\n- [Rails UJS](https://github.com/rails/rails-ujs/tree/master)\n- [Stimulus](https://github.com/hotwired/stimulus)\n","slug":"从Rails视角看现代前端——换一种方式实现SPA","published":1,"updated":"2022-05-03T09:38:10.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdui001vr2veccvr1mw0","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>其实想写这篇文很久了……</p>\n<p>从毕业实习接触 <code>Rails</code> 到现在两年多了。一开始是基于 <code>Rails</code> 框架来给 <code>Android</code> 客户端提供 <code>API</code> 接口，后来也尝试在 <code>Rails</code> 上倒腾了一些前端的东西，说从 <code>Rails</code> 中受益匪浅是一点都不夸张的。</p>\n<p><code>Ruby On Rails</code> 作为经典的 <code>MVC</code> 框架，在前端领域有着自己独到的见解，在学习的过程中也不断的让我反思自己曾经信奉的那些东西是否过于片面。</p>\n<p>本文将简单的分享 <code>Rails</code> 框架的前端技术发展历程，亦是对自己摸索的总结，在这之前有一点很重要那就是：<strong>本文没有战争。</strong></p>\n<hr>\n<h1 id=\"当我们今天谈论起前端，我们更多的是在谈论什么？\"><a href=\"#当我们今天谈论起前端，我们更多的是在谈论什么？\" class=\"headerlink\" title=\"当我们今天谈论起前端，我们更多的是在谈论什么？\"></a>当我们今天谈论起前端，我们更多的是在谈论什么？</h1><p>试想一个问题：如果今天有两位前端工程师碰面，他们大概会聊什么？</p>\n<p>我的脑子里很快浮现出一些关键字：<code>vue</code>, <code>react</code>, <code>angular</code>, <code>webpack</code>, <code>vite</code>, <code>redux</code>, 跨平台，小程序，组件化，工程化，微前端……</p>\n<p>相信对于大部分前端工程师来说，我们工作的每一天都在使用或者探讨这些东西。</p>\n<p>不难发现，这些东西的背后有着一个很基本的共同逻辑：如何更好的基于 <code>JavaScript</code> 来完成页面的构建。</p>\n<p>于是我们推导出一个结论——当今天我们聊起前端，我们更多的是在谈论以 <code>JS Render</code> 为基础的技术体系。</p>\n<p>于是问题来了……我们真的只有 <code>JS Render</code> 吗？</p>\n<p>让我们简单的过一下前端技术发展经历的几个比较典型的阶段：</p>\n<ol>\n<li><code>MVC</code> 时代，通过服务端语言开发的模板引擎，动态，快速的生成 <code>HTML</code> 页面。关键字：<code>JSP</code>, <code>ASP</code> 等。<ul>\n<li>优点：开发效率高，复杂程度低。</li>\n<li>缺点：结构混乱，交互体验差，分工不明确。</li>\n</ul>\n</li>\n<li><code>AJAX</code> 时代，通过 <code>AJAX</code> 显著改善了交互的问题，初显分离之态。关键字：<code>AJXA</code>, <code>JQuery</code> 等。<ul>\n<li>优点：交互效果显著改善。</li>\n<li>缺点：依赖 <code>JavaScript</code> 带来了大量的兼容问题和性能问题，以及代码结构依然混乱，且大量依赖于 <code>AJAX</code> 实现的页面出现了 <code>SEO</code> 问题。</li>\n</ul>\n</li>\n<li><code>SPA</code> 时代，通过 <code>JavaScript</code> 实现的渲染引擎，直接由 <code>JS</code> 完成页面的渲染，前后端完全分离。关键字：<code>vue</code>, <code>react</code>, <code>ajax</code>, 前后端分离等。<ul>\n<li>优点：富客户端，交互效果起飞，以工程化的方式解决了代码混乱的问题，人员分工明确。</li>\n<li>缺点：依然没有解决 <code>JavaScript</code> 带来的兼容问题与 <code>SEO</code> 问题，同时渲染引擎加入了渲染生命周期，以及各种数据抽象层提高了编码的心智负担。</li>\n</ul>\n</li>\n</ol>\n<p>以上的列举不算特别完整和严谨，但大体上能够说明前端技术发展历程的主要思路中，有两个比较重要的点：</p>\n<ol>\n<li>如何更高效的组织代码，解决代码结构混乱的问题。</li>\n<li>如何解决用户体验差的问题。</li>\n</ol>\n<p>而此时，我们就不得不回过头来简单的探讨一下过去的 <code>MVC</code> 架构下的前端到底是怎样的了。</p>\n<hr>\n<h1 id=\"MVC下的前端开发是什么样子？\"><a href=\"#MVC下的前端开发是什么样子？\" class=\"headerlink\" title=\"MVC下的前端开发是什么样子？\"></a>MVC下的前端开发是什么样子？</h1><p>相信说到 <code>MVC</code> 架构下的前端开发，不少经验丰富的前端工程师会有一些久远的回忆，一些刻板印象涌上心头：</p>\n<ol>\n<li>开发时 <code>HTML</code> 与服务端语言混编。</li>\n<li>稍微复杂的需求需要编写大量 <code>DOM</code> 操作来实现。</li>\n<li>交互体验差，每一次换页都需要重新加载服务端资源。</li>\n<li>……</li>\n</ol>\n<p>以 <code>Rails</code> 为例，<code>MVC</code> 的 <code>View</code> 层通常使用模板引擎技术来实现快速生成 <code>HTML</code>, 其工作原理很简单，既通过服务端语言来组合 <code>HTML</code> 片段，例如下面的代码是一种名为 <code>erb</code> 的模板引擎，它通过 <code>Ruby</code> 来生成一段列表标签。</p>\n<figure class=\"highlight erb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  &lt;%-</span><span class=\"language-ruby\"> <span class=\"variable\">@books</span>.map <span class=\"keyword\">do</span> |<span class=\"params\">book</span>| </span><span class=\"language-xml\">%&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>&lt;%=</span><span class=\"language-ruby\"> book[<span class=\"symbol\">:name</span>] </span><span class=\"language-xml\">%&gt;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  &lt;%-</span><span class=\"language-ruby\"> <span class=\"keyword\">end</span> </span><span class=\"language-xml\">%&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>最终得到的 <code>HTML</code> 被发送给浏览器端，渲染出结果：<br><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/1.webp\" alt=\"image.png\"></p>\n<p>我们同样可以为这样的结构编写 <code>CSS</code>, <code>JavaScript</code>，但就像传统的静态页一样，我们只能在每一个页面单独的引入该页面要使用的 <code>CSS</code> 与 <code>JavaScript</code> 文件，且在缺乏构建工具的情况下，我们将无缘使用 <code>Less</code>, <code>Sass</code> 等预处理技术。</p>\n<p>最终当我们完成代码的编写后，它可能看起来就像这样：</p>\n<p><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/2.webp\" alt=\"图为 GitLab 源码中的视图，使用的模板引擎是 HAML\"></p>\n<p>而其交互体验可能就像这样：<br><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/3.webp\" alt=\"图例为某些使用 JSP 开发的系统\"></p>\n<p>正如前面所说，这样的项目有几个很要命的问题：</p>\n<ol>\n<li>代码结构的问题：模板引擎的语法并不完全与 <code>HTML</code> 一致，最好的例子就是上面的 <code>HAML</code>。同时由于混杂了大量的服务端逻辑，它要求开发人员需要对后端逻辑有一定的了解。</li>\n<li>交互体验的问题：传统的 <code>MVC</code> 在访问链接，提交表单时，往往伴随浏览器的刷新行为，而每一次刷新都会导致浏览器重新拉取资源与页面渲染，交互体验极差。</li>\n<li>分工不明确，事实上从模板引擎的角度来看，能够更好完成编码的反而是更熟悉服务端开发的人员，并非以编写页面为擅长的前端开发人员。</li>\n<li>缺少必要的构建工具，没有办法使用更高效的开发技术如 <code>Sass</code>，<code>ECMAScript</code> 的部分新特性。</li>\n<li>资源管理不合理，需要多次重复拉取相同的资源文件。</li>\n</ol>\n<p>站在今天的视角我们很容易理解这些问题，也能很容易想到对策。</p>\n<p>而站在产品和用户体验的角度，我们首先要解决的是交互部分的问题，让页面无刷新更新最简单的方法就是 <code>AJAX</code> 。</p>\n<hr>\n<h1 id=\"AJAX-通过局部刷新来提升用户体验\"><a href=\"#AJAX-通过局部刷新来提升用户体验\" class=\"headerlink\" title=\"AJAX: 通过局部刷新来提升用户体验\"></a>AJAX: 通过局部刷新来提升用户体验</h1><p><code>AJAX</code> 可以帮助我们在不刷新浏览器的情况下完成局部更新，实现更高效可用的交互。<code>AJAX</code> 作为一项成熟的技术发展已经接近 20 年了，这里不再进行赘述了。</p>\n<p>简单看一下通过 <code>AJAX</code> 改造前后的页面跳转效果</p>\n<p><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/4.webp\" alt=\"不使用ajax时的页面跳转\"></p>\n<p><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/5.webp\" alt=\"使用ajax时的页面跳转\"> </p>\n<p>但 <code>AJAX</code> 的引入并不是没有代价的，完全依靠 <code>AJAX</code> 来动态更新的数据没有办法获得 <code>SEO</code> 的支持。同时使用 <code>AJAX</code> 意味着需要编写些许的 <code>JavaScript</code> 代码来完成 <code>DOM</code> 节点的更新操作。另一个更复杂的问题在于，当我们期望通过 <code>AJAX</code> 来完成整个应用的无刷新换页、提交时，意味着我们有大量的 <code>HTML</code> 会在 <code>JavaScript</code> 中动态的插入，即由此来完成页面的局部刷新。此时，代码的可维护性大大的降低，最终化为一头失控的猛兽。  </p>\n<p>难道我们一定要在完全由 <code>JS Redner</code> 的环境里才能实现浏览器的无缝刷新吗？其实不然。</p>\n<hr>\n<h1 id=\"Turbolinks：PJAX的魔法\"><a href=\"#Turbolinks：PJAX的魔法\" class=\"headerlink\" title=\"Turbolinks：PJAX的魔法\"></a>Turbolinks：PJAX的魔法</h1><p><code>Rails</code> 在 4.0 版本默认引入了一个扩展—— <code>Turbolinks</code>。</p>\n<p><code>Turbolinks</code> 是一个轻量，但略带侵略性的 <code>JavaScript</code> 库。关于它的一切，其实要从更早的一项技术说起——<code>PJAX</code>.</p>\n<p><code>PJAX</code> 是一项简单易懂却很有效的技术，在它的 <code>GitHub</code> 页上有这样的介绍：<code>PJAX = AJAX + pushState</code>. </p>\n<p>其工作原理很简单：</p>\n<ol>\n<li>当在页面中点击一个 <code>a</code> 标签，或提交 <code>form</code> 表单时，并非以浏览器的默认行为进行跳转或提交，而是以 <code>xhr</code> 的方式请求目标地址。</li>\n<li>服务端在完成请求的处理后，依然基于模板引擎的技术返回渲染完成后的静态 <code>HTML</code> 片段。</li>\n<li>将服务端返回的 <code>HTML</code> 片段替换到当前页面的指定位置。</li>\n<li>使用 <code>history.pushState</code> 更新浏览器当前的 <code>URL</code> 以正常维护浏览器的地址栏。</li>\n</ol>\n<p><code>PJAX</code> 将上述的步骤封装为一个方法，开发者可以快速的实现指定节点的局部渲染：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">pjax</span>(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;#pjax-container&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>整理一下思路，看似无奇的操作背后隐藏着哪些细节：</p>\n<ol>\n<li>可以有选择的替换页面的部分标签或全部标签来实现局部刷新。</li>\n<li>由于指向的超链接本质上依然返回 <code>HTML</code>, 因而不影响 <code>SEO</code> 效果。</li>\n<li>由于返回的部分会被更新到视图中，因而服务端在 <code>PJAX</code> 请求的页面应当仅返回 <code>HTML</code> 片段而非完整的 <code>HTML</code> 页。</li>\n</ol>\n<p><code>Turbolinks</code> 是 <code>Rails</code> 基于 <code>PJAX</code> 的再实现，它吸取了 <code>PJAX</code> 的思路，同时还做出了改进和扩展。</p>\n<p>相比 <code>PJAX</code> 中隐式的条件需要调整服务端渲染的片段，<code>Turbolinks</code> 更加大胆的选择了让服务端照常返回完整的 <code>HTML</code> 页，而后在本地对页面的 <code>head</code> 标签进行合并，同时将 <code>body</code> 标签完整的替换到当前页面以实现页面的无缝刷新。</p>\n<p>这样做的第一大好处是，当应用运行在不支持 <code>history.pushState</code> 的环境时，由于服务端照常返回了完整的页面，可以实现优雅降级，浏览器依然能够正常的加载页面。</p>\n<p>第二大好处在于，在这种策略之下 <code>Turbolink</code> 不需要开发者手动的指定节点进行局部渲染，一经安装，整个应用都自动实现了无缝刷新。</p>\n<p>第三大好处，<code>Turbolinks</code> 合并的 <code>head</code> 标签中，不会拉取重复的资源，减少了资源文件的重复加载。</p>\n<p>除此之外 <code>Turbolinks</code> 还扩充了部分功能，其中比较典型的包括：</p>\n<ol>\n<li>在页面加载完成后，通过 <code>Node.cloneNode()</code> 来缓存页面，使得在网络断开期间也能访问已经缓存的页面。</li>\n<li>在 <code>Turbolinks</code> 换页期间维护了一个内部的进度条用来向用户展示 <code>loading</code> 状态，与其它的特性相同，它不需要用户编写任何额外的代码。</li>\n</ol>\n<p><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/6.webp\" alt=\"turbolinks换页\"></p>\n<p>观察上图，注意几个细节：</p>\n<ol>\n<li>点击链接时，浏览器并没有刷新。</li>\n<li>页面更新前后浏览器顶部自己维护了加载的进度条。</li>\n<li>页面切换时，<code>NetWork</code> 里实际发送的是 <code>xhr</code> 类型的请求。</li>\n<li>请求返回的是完整的 <code>HTML</code> 页。</li>\n</ol>\n<p>总结一下，<code>Turbolinks</code> 是一个吸收了 <code>PJAX</code> 思路，以最低成本实现更高交互的轻量级 <code>JavaScript</code> 库。</p>\n<p>说完了 <code>Turbolinks</code> 的优点，我们还得说一说 <code>Turbolinks</code> 的缺点，毕竟没有哪一项技术是完美的。</p>\n<p><code>Turbolinks</code> 的存在的第一个问题，由 <code>PJAX</code> 继承而来，且由于 <code>Turbolinks</code> 机制上的改进，这个问题被更加放大。当节点被动态添加至页面时，有一个我们不得不注意到一个问题：已经注册的 <code>JavaScript</code> 事件如何处理？</p>\n<p>在使用 <code>PJAX</code> 的时候，我们仅添加片段到页面中，并不太会经常出现需要给这些节点添加移出事件的情况。而当整个页面都被替换掉的时候，问题就变得突出了，其问题具体来说体现在：当页面被替换后，由于浏览器没有刷新，当前页面注册的事件、设置的定时器等均依然有效，相对来说下一个页面渲染时的环境并不纯净。此时如果某一个行为触发了上一个页面的事件，则会产生不可预期的影响。另一层考虑则是这些反复留存下来的事件本质上也会造成内存泄露。</p>\n<p>解决这一问题的方法从整体思路上说是统一的，既使操作幂等。</p>\n<p><code>Turbolinks</code> 提供了换页生命周期的钩子函数，使得可以在换页后做一些事情：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;turbolinks:load&quot;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>请注意，正是由于页面的生命周期发生了变化，实际由 <code>Turbolinks</code> 维护的页面只会执行一次 <code>DOMContentLoaded</code> 事件，因而如果期望某一行为始终在页面加载后执行，则应该使用 <code>turbolinks:load</code> 来替换 <code>onload</code>, <code>DOMContentLoaded</code> 事件。</p>\n<p>解决上述问题具体的方式包括：</p>\n<ol>\n<li>在 <code>Turbolinks</code> 对应的生命周期里挂载和移除事件，计时器等。</li>\n<li>使用事件委托，本质依然是幂等，只当节点存在时触发事件。</li>\n<li>见下文。</li>\n</ol>\n<p>另外，<code>Turbolinks</code> 还存在的另一个问题则来源于 <code>addEventListener</code> 方法，在多次换页过程中触发的 <code>document.addEventListener</code> 会反复添加事件监听，这样会导致换页后依然能够执行上一个页面 <code>turbolinks:load</code> 生命周期里的内容。此时，生命周期内的操作幂等性就变得更加重要了。</p>\n<hr>\n<h1 id=\"Turbolinks-Prefetch：预加载的新思路\"><a href=\"#Turbolinks-Prefetch：预加载的新思路\" class=\"headerlink\" title=\"Turbolinks Prefetch：预加载的新思路\"></a>Turbolinks Prefetch：预加载的新思路</h1><p>当提到 <code>Turbolinks</code> 时，有一个相关衍生的生态组件就不得不拿出来聊一聊了——<code>Turbolink Prefetch</code>。</p>\n<p>正如 <code>Prefetch</code> 这个名字一样，<code>Turbolinks Prefetch</code> 会进行预加载操作以提升页面的访问速度，其原理实际是一种叫做 <code>InstantClick</code> 技术。主要原理为：当用户鼠标置于链接上时，提前拉取目标地址的页面并缓存，当用户点击鼠标时直接从缓存中读取该页面。</p>\n<p><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/7.webp\" alt=\"turbolinks-prefetch\"></p>\n<p>观察上图：</p>\n<ol>\n<li>当鼠标经过部分链接时，观察 <code>NetWork</code> 自动发送了请求。</li>\n<li>往上滚动时，虽然鼠标再次经过重复的链接，单并没有重复发送请求。</li>\n<li>点击已请求过的链接，<code>NetWork</code> 并没有发送其它请求，仅在页面加载后请求了页面上的资源文件。</li>\n<li>与前面 <code>Turbolinks</code> 的演示相同，对页面的请求依然使用使用的是 <code>xhr</code> 方式。</li>\n</ol>\n<p>虽然从技术角度来说，借助 <code>Turbolinks</code> 已有的缓存机制实现这一功能似乎并没有什么太大的难度，但我认为这样的思路却非常值得学习：即利用用户的碎片时间提前拉取资源以减少用户的等待时间。从目前来看，这一思路在混合 <code>APP</code> 实现 <code>WebView</code> 秒开时起到了非常不错的效果。</p>\n<hr>\n<h2 id=\"Assets-Pipeline：Rails-自己的构建工具\"><a href=\"#Assets-Pipeline：Rails-自己的构建工具\" class=\"headerlink\" title=\"Assets Pipeline：Rails 自己的构建工具\"></a>Assets Pipeline：Rails 自己的构建工具</h2><p>在我们谈论 <code>MVC</code> 下实现的前端有哪些问题时，提到了这样几个问题：</p>\n<ol>\n<li>缺少必要的构建工具，没有办法使用更高效的开发技术如 Sass，ECMAScript 的部分新特性。</li>\n<li>资源管理不合理，需要多次重复拉取相同的资源文件。</li>\n<li>……</li>\n</ol>\n<p>前面所介绍的 <code>Turbolinks</code>，<code>Turbolinks Prefetch</code> 等均是来自于交互方面的优化。而上面这些问题则指向了构建工具这一话题。</p>\n<p>在今天，当我们开发完成一个前端项目，通常进入生产环境前需要对源代码进行一系列的操作，它们包括：</p>\n<ol>\n<li>编译代码，把 <code>Sass</code>, <code>Less</code>, 以及高版本的 <code>ECMAScript</code> 等非浏览器可以直接执行的内容编译成低版本代码或原生代码；</li>\n<li>压缩代码，去除代码中不必要的换行，注释等，减少文件体积；</li>\n<li>混淆代码，将 <code>JS</code> 代码编译为不可读的丑化代码，进一步缩减文件体积；</li>\n<li>合并文件，减少 <code>HTTP</code> 请求次数；</li>\n<li>通过摘要算法计算 <code>Hash</code> 作为静态资源文件的文件名，使资源可以根据文件内容的变化来合理利用浏览器缓存；</li>\n</ol>\n<p>而实现这些操作则需要依赖构建工具，比较有名的就是大家都熟悉的 <code>webpack</code>。</p>\n<p>实际上，<code>Rails</code> 在很早就提供了这样一套框架用于静态资源的构建和管理——<code>Assets Pipeline</code>。</p>\n<p>放在今天，我们以一名前端工程师的视角来看 <code>Assets Pipeline</code> 其实是非常容易理解的。它主要利用 <code>Sprockets</code> 这一构建工具来实现了上面描述静态资源压缩，，使得在 <code>MVC</code> 的结构下一样可以合理，优雅的管理前端资源。</p>\n<p>同时 <code>Assets Pipeline</code> 还自带了 <code>Sass</code>, <code>CoffeeScript</code> 这些从 <code>Ruby</code> 社区孵化出的前端技术的支持。其中 <code>Sass</code> 提高了编写 <code>CSS</code> 的效率。而 <code>CoffeeScript</code> 则为 <code>ES5</code> 添加了诸多有用的语法扩展。如此，在 <code>MVC</code> 结构下也能获得良好的开发体验。</p>\n<p>注意一个细节：<code>Assets Pipeline</code> 在进行生产环境的预编译行为时，本质上与现在我们运行 <code>npm run build</code> 使用 <code>webpack</code> 进行打包有着非常大的相似之处。不同之处在于，<code>Rails MVC</code> 下的前端开发并不会依赖 <code>JS Render</code> ，由此导致现代前端基于 <code>webpack</code> 构建的静态资源和 <code>Rails</code> 基于 <code>Assets Pipeline</code> 构建的静态资源在体积上有着量级的区别。</p>\n<p>正是得益于这种技术栈不依赖 <code>JS</code> 构建页面，<code>Assets Pipeline</code> 可以放心大胆的将静态资源合并为一个单文件而不用担心体积过大造成资源加载慢的问题。</p>\n<p>因而当我们查看一个 <code>Rails</code> 传统技术开发的网站，会发现它仅在浏览器第一次加载页面时，完整的拉取脚本与样式文件，而后在 <code>Turbolinks</code> 启动后，每一次换页都不会也无需拉取静态资源文件，而是仅获取需要显示的 <code>HTML</code> 内容。</p>\n<p>有一个非常有意思的点：我们的站点在用户交互上与 <code>SPA</code> 一样在首屏拉取资源，也像 <code>SPA</code> 一样在无缝换页。</p>\n<hr>\n<h1 id=\"UJS：使用非侵入式的-JavaScript-缩减重复代码\"><a href=\"#UJS：使用非侵入式的-JavaScript-缩减重复代码\" class=\"headerlink\" title=\"UJS：使用非侵入式的 JavaScript 缩减重复代码\"></a>UJS：使用非侵入式的 JavaScript 缩减重复代码</h1><p>除了引入完整的构建体系以外，其实 <code>Rails</code> 还做有一个较为有趣的前端构建技术名为 <code>UJS</code>，它是 <code>Unobtrusive JavaScript</code> 的缩写，翻译为中文为 “非侵入式 <code>JavaScript</code>”。</p>\n<p><code>UJS</code> 本是指将 <code>JS</code> 与页面结构分离的代码风格，而 <code>Rails UJS</code> 只是基于这样一种风格编码的前端工具库，整个扩展仅有 700+ 行代码。</p>\n<p><code>Rails UJS</code> 内部实现了前面我们在 <code>PJAX</code> 和 <code>Turbolinks</code> 里提到的让 <code>a</code> 标签和 <code>form</code> 表单自动使用 <code>xhr</code> 提交的方法，但它并没有针对这一行为做后续的操作，而是提供了对应的事件回调。即是说，开发人员可以自由的设置某一个 <code>a</code> 标签或 <code>form</code> 表单为 <code>xhr</code> 提交，而需要做的仅仅是在该标签上增加一个 <code>data-remote=true</code> 属性，而后即可在回调中拿到对应的请求值。</p>\n<p>对比一下使用原生与使用 <code>Rails UJS</code> 实现表单 <code>xhr</code> 提交的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原生</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> form = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;form&quot;</span>);</span><br><span class=\"line\">form.<span class=\"property\">onsubmit</span> = <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    e.<span class=\"title function_\">preventDefault</span>();</span><br><span class=\"line\">    <span class=\"comment\">//阻止submit默认提交行为</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fd = <span class=\"keyword\">new</span> <span class=\"title class_\">FormData</span>(form); </span><br><span class=\"line\">    fd.<span class=\"title function_\">append</span>(<span class=\"string\">&#x27;userId&#x27;</span>, <span class=\"string\">&#x27;1008611&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span><br><span class=\"line\">    xhr.<span class=\"title function_\">open</span>(<span class=\"string\">&quot;POST&quot;</span>,<span class=\"string\">&quot;http://www.xxx/api/xxx&quot;</span>);</span><br><span class=\"line\">    xhr.<span class=\"property\">onreadystatechange</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (xhr.<span class=\"property\">readyState</span> === <span class=\"number\">4</span> &amp;&amp; xhr.<span class=\"property\">status</span> === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(xhr.<span class=\"property\">responseText</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    xhr.<span class=\"title function_\">send</span>(fd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 rails_ujs </span></span><br><span class=\"line\"><span class=\"comment\">// 需要在对应的标签上添加 data-remote=true 就像</span></span><br><span class=\"line\"><span class=\"comment\">// &lt;form data-remote=&quot;true&quot; id=&quot;remoteForm&quot; action=&quot;/welcome/test_render&quot;&gt;...&lt;/form&gt;</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;#remoteLink&quot;</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;ajax:success&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">xhr, status, err</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(xhr, status, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>可以看到代码会简洁很多。</p>\n<p>除此之外，<code>Rails UJS</code> 也支持了更多的 <code>xhr</code> 参数如 <code>method</code> 等，使得我们基于这种方式来构建 <code>xhr</code> 变的更快更高效，减少了大量的重复代码。</p>\n<p>另一个有趣的用法是，在通过 <code>xhr</code> 请求时，由服务端渲染一段 <code>JavaScript</code>，可以很高效的实现一些交互逻辑。但由于这种方式不便于组织 <code>JS</code> 代码文件，此处不过多展开，详情可以读扩展阅读《<a href=\"https://ruby-china.org/topics/29046\">Rails 用 RJS 简单有效的实现页面局部刷新</a>》。</p>\n<hr>\n<h1 id=\"Stimulus：Turbolinks-幂等问题的最终解？\"><a href=\"#Stimulus：Turbolinks-幂等问题的最终解？\" class=\"headerlink\" title=\"Stimulus：Turbolinks 幂等问题的最终解？\"></a>Stimulus：Turbolinks 幂等问题的最终解？</h1><p><code>Turbolinks</code> 为我们提供了基本的页面交互 <code>SPA</code> 化的解决方案，使我们能以非常轻量的方式来实现一个体验极佳的站点。</p>\n<p><code>Assets Pipeline</code> 为我们带来的构建手段。</p>\n<p><code>Rails UJS</code> 简化了我们构建 <code>AJAX</code> 交互的代码量。</p>\n<p>但站在今天的角度来看，似乎编码体验上并没有太大的改进。我们依然在重复的码着 <code>JQuery</code>，我们也依然在重复的操作 <code>DOM</code>，甚至对于如何复用一个页面组件，我们依然没有一个合适的方式。与此同时，引入的 <code>Turbolinks</code> 带来了新的负担，编写 <code>JS</code> 代码的时候我们需要更加注意幂等性……</p>\n<p>当我们开始思考这样的问题的时候，<code>Stimulus</code> 来了。</p>\n<p><code>Stimulus</code> 同样是一个轻量的前端库，它通过 <code>H5</code> 的 <code>Mutation Observer</code> 这一特性彻底解决了 <code>Turbolinks</code> 幂等的问题。</p>\n<p><code>Mutation Observer</code> 可以完成 <code>DOM</code> 节点的监听，在 <code>DOM</code> 节点发生变化时，指定对应的逻辑。我们可以通俗的理解这一 <code>API</code> 为原生的 <code>DOM</code> 节点添加了自己的生命周期。</p>\n<p>直接看下面的 <code>Stimulus</code> 代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Controller</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;stimulus&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">extends</span> <span class=\"title class_\">Controller</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> values = &#123; <span class=\"attr\">url</span>: <span class=\"title class_\">String</span>, <span class=\"attr\">refreshInterval</span>: <span class=\"title class_\">Number</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">connect</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">load</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">hasRefreshIntervalValue</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">startRefreshing</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">disconnect</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">stopRefreshing</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">load</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">fetch</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">urlValue</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.<span class=\"title function_\">text</span>())</span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">html</span> =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">element</span>.<span class=\"property\">innerHTML</span> = html)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">startRefreshing</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">refreshTimer</span> = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">load</span>()</span><br><span class=\"line\">    &#125;, <span class=\"variable language_\">this</span>.<span class=\"property\">refreshIntervalValue</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">stopRefreshing</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">refreshTimer</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearInterval</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">refreshTimer</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我有理由相信写过 <code>vue</code>, <code>react</code> 组件的现代前端工程师可以没有什么压力的阅读这段代码……</p>\n<p><code>Stimulus</code> 通过 <code>data-controller</code> 将逻辑关联到 <code>DOM</code> 节点，同时提供了对应节点的生命周期钩子函数，当节点被渲染后，会触发 <code>connect</code> 方法，而节点被销毁时会触发 <code>disconnect</code> 。同时 <code>Stimulus</code> 还支持定义状态与方法，最终这些内容被合理的挂载到节点的各位置，就像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-controller</span>=<span class=\"string\">&quot;content-loader&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">data-content-loader-url-value</span>=<span class=\"string\">&quot;/messages.html&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">data-content-loader-refresh-interval-value</span>=<span class=\"string\">&quot;5000&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这一段代码复制于 <code>Stimulus</code> 的文档，它实现了一个可以自动异步加载页面的组件。</p>\n<p>由于节点拥有了自己的生命周期，只有当节点真正被渲染在页面上时 <code>Stimulus</code> 才会真正的执行对应的挂载逻辑，因而我们不再需要担心伴随 <code>Turbolinks</code> 的换页带来的事件绑定心智问题。</p>\n<p>同时，<code>Stimulus</code> 也完全解决了复用的问题，当需要在另一位置复用这一组件时，我们只需要为该节点添加上对应的 <code>data-controller</code> 属性即可。</p>\n<p>最后，<code>Stimulus</code> 通常在单一文件里定义组件，也就是说，基于 <code>Stimulus</code> 开发的应用不会再出现同一个 <code>JS</code> 文件里有成百上千行不知所云毫无关联的 <code>JavaScript</code> 代码的情况。</p>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><hr>\n<h1 id=\"结语（碎碎念）\"><a href=\"#结语（碎碎念）\" class=\"headerlink\" title=\"结语（碎碎念）\"></a>结语（碎碎念）</h1><p>其实本来打算再倒腾下 <code>Hotwire</code> 的，但是实在时间有限……</p>\n<p>前端是一个大的领域，即使放到一个框架里，内容也是非常多的。</p>\n<p>关于 <code>Rails</code> 的前端内容大概就先写到这里了，后面如果有空还会再补充。</p>\n<p>最后放上 <a href=\"https://ruby-china.org/\">Ruby China</a> 链接，可以从交互等方面来体验一下，几乎完全与 <code>SPA</code> 类似的交互体验。</p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"https://github.com/rails/rails\">Ruby On Rails</a></li>\n<li><a href=\"https://github.com/defunkt/jquery-pjax\">JQuery PJAX</a></li>\n<li><a href=\"https://github.com/turbolinks/turbolinks\">Turbolinks</a></li>\n<li><a href=\"https://github.com/huacnlee/turbolinks-prefetch\">Turbolinks Prefetch</a></li>\n<li><a href=\"https://github.com/rails/jquery-ujs\">JQuery UJS</a></li>\n<li><a href=\"https://github.com/rails/rails-ujs/tree/master\">Rails UJS</a></li>\n<li><a href=\"https://github.com/hotwired/stimulus\">Stimulus</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>其实想写这篇文很久了……</p>\n<p>从毕业实习接触 <code>Rails</code> 到现在两年多了。一开始是基于 <code>Rails</code> 框架来给 <code>Android</code> 客户端提供 <code>API</code> 接口，后来也尝试在 <code>Rails</code> 上倒腾了一些前端的东西，说从 <code>Rails</code> 中受益匪浅是一点都不夸张的。</p>\n<p><code>Ruby On Rails</code> 作为经典的 <code>MVC</code> 框架，在前端领域有着自己独到的见解，在学习的过程中也不断的让我反思自己曾经信奉的那些东西是否过于片面。</p>\n<p>本文将简单的分享 <code>Rails</code> 框架的前端技术发展历程，亦是对自己摸索的总结，在这之前有一点很重要那就是：<strong>本文没有战争。</strong></p>\n<hr>\n<h1 id=\"当我们今天谈论起前端，我们更多的是在谈论什么？\"><a href=\"#当我们今天谈论起前端，我们更多的是在谈论什么？\" class=\"headerlink\" title=\"当我们今天谈论起前端，我们更多的是在谈论什么？\"></a>当我们今天谈论起前端，我们更多的是在谈论什么？</h1><p>试想一个问题：如果今天有两位前端工程师碰面，他们大概会聊什么？</p>\n<p>我的脑子里很快浮现出一些关键字：<code>vue</code>, <code>react</code>, <code>angular</code>, <code>webpack</code>, <code>vite</code>, <code>redux</code>, 跨平台，小程序，组件化，工程化，微前端……</p>\n<p>相信对于大部分前端工程师来说，我们工作的每一天都在使用或者探讨这些东西。</p>\n<p>不难发现，这些东西的背后有着一个很基本的共同逻辑：如何更好的基于 <code>JavaScript</code> 来完成页面的构建。</p>\n<p>于是我们推导出一个结论——当今天我们聊起前端，我们更多的是在谈论以 <code>JS Render</code> 为基础的技术体系。</p>\n<p>于是问题来了……我们真的只有 <code>JS Render</code> 吗？</p>\n<p>让我们简单的过一下前端技术发展经历的几个比较典型的阶段：</p>\n<ol>\n<li><code>MVC</code> 时代，通过服务端语言开发的模板引擎，动态，快速的生成 <code>HTML</code> 页面。关键字：<code>JSP</code>, <code>ASP</code> 等。<ul>\n<li>优点：开发效率高，复杂程度低。</li>\n<li>缺点：结构混乱，交互体验差，分工不明确。</li>\n</ul>\n</li>\n<li><code>AJAX</code> 时代，通过 <code>AJAX</code> 显著改善了交互的问题，初显分离之态。关键字：<code>AJXA</code>, <code>JQuery</code> 等。<ul>\n<li>优点：交互效果显著改善。</li>\n<li>缺点：依赖 <code>JavaScript</code> 带来了大量的兼容问题和性能问题，以及代码结构依然混乱，且大量依赖于 <code>AJAX</code> 实现的页面出现了 <code>SEO</code> 问题。</li>\n</ul>\n</li>\n<li><code>SPA</code> 时代，通过 <code>JavaScript</code> 实现的渲染引擎，直接由 <code>JS</code> 完成页面的渲染，前后端完全分离。关键字：<code>vue</code>, <code>react</code>, <code>ajax</code>, 前后端分离等。<ul>\n<li>优点：富客户端，交互效果起飞，以工程化的方式解决了代码混乱的问题，人员分工明确。</li>\n<li>缺点：依然没有解决 <code>JavaScript</code> 带来的兼容问题与 <code>SEO</code> 问题，同时渲染引擎加入了渲染生命周期，以及各种数据抽象层提高了编码的心智负担。</li>\n</ul>\n</li>\n</ol>\n<p>以上的列举不算特别完整和严谨，但大体上能够说明前端技术发展历程的主要思路中，有两个比较重要的点：</p>\n<ol>\n<li>如何更高效的组织代码，解决代码结构混乱的问题。</li>\n<li>如何解决用户体验差的问题。</li>\n</ol>\n<p>而此时，我们就不得不回过头来简单的探讨一下过去的 <code>MVC</code> 架构下的前端到底是怎样的了。</p>\n<hr>\n<h1 id=\"MVC下的前端开发是什么样子？\"><a href=\"#MVC下的前端开发是什么样子？\" class=\"headerlink\" title=\"MVC下的前端开发是什么样子？\"></a>MVC下的前端开发是什么样子？</h1><p>相信说到 <code>MVC</code> 架构下的前端开发，不少经验丰富的前端工程师会有一些久远的回忆，一些刻板印象涌上心头：</p>\n<ol>\n<li>开发时 <code>HTML</code> 与服务端语言混编。</li>\n<li>稍微复杂的需求需要编写大量 <code>DOM</code> 操作来实现。</li>\n<li>交互体验差，每一次换页都需要重新加载服务端资源。</li>\n<li>……</li>\n</ol>\n<p>以 <code>Rails</code> 为例，<code>MVC</code> 的 <code>View</code> 层通常使用模板引擎技术来实现快速生成 <code>HTML</code>, 其工作原理很简单，既通过服务端语言来组合 <code>HTML</code> 片段，例如下面的代码是一种名为 <code>erb</code> 的模板引擎，它通过 <code>Ruby</code> 来生成一段列表标签。</p>\n<figure class=\"highlight erb\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  &lt;%-</span><span class=\"language-ruby\"> <span class=\"variable\">@books</span>.map <span class=\"keyword\">do</span> |<span class=\"params\">book</span>| </span><span class=\"language-xml\">%&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>&lt;%=</span><span class=\"language-ruby\"> book[<span class=\"symbol\">:name</span>] </span><span class=\"language-xml\">%&gt;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  &lt;%-</span><span class=\"language-ruby\"> <span class=\"keyword\">end</span> </span><span class=\"language-xml\">%&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>最终得到的 <code>HTML</code> 被发送给浏览器端，渲染出结果：<br><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/1.webp\" alt=\"image.png\"></p>\n<p>我们同样可以为这样的结构编写 <code>CSS</code>, <code>JavaScript</code>，但就像传统的静态页一样，我们只能在每一个页面单独的引入该页面要使用的 <code>CSS</code> 与 <code>JavaScript</code> 文件，且在缺乏构建工具的情况下，我们将无缘使用 <code>Less</code>, <code>Sass</code> 等预处理技术。</p>\n<p>最终当我们完成代码的编写后，它可能看起来就像这样：</p>\n<p><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/2.webp\" alt=\"图为 GitLab 源码中的视图，使用的模板引擎是 HAML\"></p>\n<p>而其交互体验可能就像这样：<br><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/3.webp\" alt=\"图例为某些使用 JSP 开发的系统\"></p>\n<p>正如前面所说，这样的项目有几个很要命的问题：</p>\n<ol>\n<li>代码结构的问题：模板引擎的语法并不完全与 <code>HTML</code> 一致，最好的例子就是上面的 <code>HAML</code>。同时由于混杂了大量的服务端逻辑，它要求开发人员需要对后端逻辑有一定的了解。</li>\n<li>交互体验的问题：传统的 <code>MVC</code> 在访问链接，提交表单时，往往伴随浏览器的刷新行为，而每一次刷新都会导致浏览器重新拉取资源与页面渲染，交互体验极差。</li>\n<li>分工不明确，事实上从模板引擎的角度来看，能够更好完成编码的反而是更熟悉服务端开发的人员，并非以编写页面为擅长的前端开发人员。</li>\n<li>缺少必要的构建工具，没有办法使用更高效的开发技术如 <code>Sass</code>，<code>ECMAScript</code> 的部分新特性。</li>\n<li>资源管理不合理，需要多次重复拉取相同的资源文件。</li>\n</ol>\n<p>站在今天的视角我们很容易理解这些问题，也能很容易想到对策。</p>\n<p>而站在产品和用户体验的角度，我们首先要解决的是交互部分的问题，让页面无刷新更新最简单的方法就是 <code>AJAX</code> 。</p>\n<hr>\n<h1 id=\"AJAX-通过局部刷新来提升用户体验\"><a href=\"#AJAX-通过局部刷新来提升用户体验\" class=\"headerlink\" title=\"AJAX: 通过局部刷新来提升用户体验\"></a>AJAX: 通过局部刷新来提升用户体验</h1><p><code>AJAX</code> 可以帮助我们在不刷新浏览器的情况下完成局部更新，实现更高效可用的交互。<code>AJAX</code> 作为一项成熟的技术发展已经接近 20 年了，这里不再进行赘述了。</p>\n<p>简单看一下通过 <code>AJAX</code> 改造前后的页面跳转效果</p>\n<p><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/4.webp\" alt=\"不使用ajax时的页面跳转\"></p>\n<p><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/5.webp\" alt=\"使用ajax时的页面跳转\"> </p>\n<p>但 <code>AJAX</code> 的引入并不是没有代价的，完全依靠 <code>AJAX</code> 来动态更新的数据没有办法获得 <code>SEO</code> 的支持。同时使用 <code>AJAX</code> 意味着需要编写些许的 <code>JavaScript</code> 代码来完成 <code>DOM</code> 节点的更新操作。另一个更复杂的问题在于，当我们期望通过 <code>AJAX</code> 来完成整个应用的无刷新换页、提交时，意味着我们有大量的 <code>HTML</code> 会在 <code>JavaScript</code> 中动态的插入，即由此来完成页面的局部刷新。此时，代码的可维护性大大的降低，最终化为一头失控的猛兽。  </p>\n<p>难道我们一定要在完全由 <code>JS Redner</code> 的环境里才能实现浏览器的无缝刷新吗？其实不然。</p>\n<hr>\n<h1 id=\"Turbolinks：PJAX的魔法\"><a href=\"#Turbolinks：PJAX的魔法\" class=\"headerlink\" title=\"Turbolinks：PJAX的魔法\"></a>Turbolinks：PJAX的魔法</h1><p><code>Rails</code> 在 4.0 版本默认引入了一个扩展—— <code>Turbolinks</code>。</p>\n<p><code>Turbolinks</code> 是一个轻量，但略带侵略性的 <code>JavaScript</code> 库。关于它的一切，其实要从更早的一项技术说起——<code>PJAX</code>.</p>\n<p><code>PJAX</code> 是一项简单易懂却很有效的技术，在它的 <code>GitHub</code> 页上有这样的介绍：<code>PJAX = AJAX + pushState</code>. </p>\n<p>其工作原理很简单：</p>\n<ol>\n<li>当在页面中点击一个 <code>a</code> 标签，或提交 <code>form</code> 表单时，并非以浏览器的默认行为进行跳转或提交，而是以 <code>xhr</code> 的方式请求目标地址。</li>\n<li>服务端在完成请求的处理后，依然基于模板引擎的技术返回渲染完成后的静态 <code>HTML</code> 片段。</li>\n<li>将服务端返回的 <code>HTML</code> 片段替换到当前页面的指定位置。</li>\n<li>使用 <code>history.pushState</code> 更新浏览器当前的 <code>URL</code> 以正常维护浏览器的地址栏。</li>\n</ol>\n<p><code>PJAX</code> 将上述的步骤封装为一个方法，开发者可以快速的实现指定节点的局部渲染：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">pjax</span>(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;#pjax-container&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>整理一下思路，看似无奇的操作背后隐藏着哪些细节：</p>\n<ol>\n<li>可以有选择的替换页面的部分标签或全部标签来实现局部刷新。</li>\n<li>由于指向的超链接本质上依然返回 <code>HTML</code>, 因而不影响 <code>SEO</code> 效果。</li>\n<li>由于返回的部分会被更新到视图中，因而服务端在 <code>PJAX</code> 请求的页面应当仅返回 <code>HTML</code> 片段而非完整的 <code>HTML</code> 页。</li>\n</ol>\n<p><code>Turbolinks</code> 是 <code>Rails</code> 基于 <code>PJAX</code> 的再实现，它吸取了 <code>PJAX</code> 的思路，同时还做出了改进和扩展。</p>\n<p>相比 <code>PJAX</code> 中隐式的条件需要调整服务端渲染的片段，<code>Turbolinks</code> 更加大胆的选择了让服务端照常返回完整的 <code>HTML</code> 页，而后在本地对页面的 <code>head</code> 标签进行合并，同时将 <code>body</code> 标签完整的替换到当前页面以实现页面的无缝刷新。</p>\n<p>这样做的第一大好处是，当应用运行在不支持 <code>history.pushState</code> 的环境时，由于服务端照常返回了完整的页面，可以实现优雅降级，浏览器依然能够正常的加载页面。</p>\n<p>第二大好处在于，在这种策略之下 <code>Turbolink</code> 不需要开发者手动的指定节点进行局部渲染，一经安装，整个应用都自动实现了无缝刷新。</p>\n<p>第三大好处，<code>Turbolinks</code> 合并的 <code>head</code> 标签中，不会拉取重复的资源，减少了资源文件的重复加载。</p>\n<p>除此之外 <code>Turbolinks</code> 还扩充了部分功能，其中比较典型的包括：</p>\n<ol>\n<li>在页面加载完成后，通过 <code>Node.cloneNode()</code> 来缓存页面，使得在网络断开期间也能访问已经缓存的页面。</li>\n<li>在 <code>Turbolinks</code> 换页期间维护了一个内部的进度条用来向用户展示 <code>loading</code> 状态，与其它的特性相同，它不需要用户编写任何额外的代码。</li>\n</ol>\n<p><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/6.webp\" alt=\"turbolinks换页\"></p>\n<p>观察上图，注意几个细节：</p>\n<ol>\n<li>点击链接时，浏览器并没有刷新。</li>\n<li>页面更新前后浏览器顶部自己维护了加载的进度条。</li>\n<li>页面切换时，<code>NetWork</code> 里实际发送的是 <code>xhr</code> 类型的请求。</li>\n<li>请求返回的是完整的 <code>HTML</code> 页。</li>\n</ol>\n<p>总结一下，<code>Turbolinks</code> 是一个吸收了 <code>PJAX</code> 思路，以最低成本实现更高交互的轻量级 <code>JavaScript</code> 库。</p>\n<p>说完了 <code>Turbolinks</code> 的优点，我们还得说一说 <code>Turbolinks</code> 的缺点，毕竟没有哪一项技术是完美的。</p>\n<p><code>Turbolinks</code> 的存在的第一个问题，由 <code>PJAX</code> 继承而来，且由于 <code>Turbolinks</code> 机制上的改进，这个问题被更加放大。当节点被动态添加至页面时，有一个我们不得不注意到一个问题：已经注册的 <code>JavaScript</code> 事件如何处理？</p>\n<p>在使用 <code>PJAX</code> 的时候，我们仅添加片段到页面中，并不太会经常出现需要给这些节点添加移出事件的情况。而当整个页面都被替换掉的时候，问题就变得突出了，其问题具体来说体现在：当页面被替换后，由于浏览器没有刷新，当前页面注册的事件、设置的定时器等均依然有效，相对来说下一个页面渲染时的环境并不纯净。此时如果某一个行为触发了上一个页面的事件，则会产生不可预期的影响。另一层考虑则是这些反复留存下来的事件本质上也会造成内存泄露。</p>\n<p>解决这一问题的方法从整体思路上说是统一的，既使操作幂等。</p>\n<p><code>Turbolinks</code> 提供了换页生命周期的钩子函数，使得可以在换页后做一些事情：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&quot;turbolinks:load&quot;</span>, <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>请注意，正是由于页面的生命周期发生了变化，实际由 <code>Turbolinks</code> 维护的页面只会执行一次 <code>DOMContentLoaded</code> 事件，因而如果期望某一行为始终在页面加载后执行，则应该使用 <code>turbolinks:load</code> 来替换 <code>onload</code>, <code>DOMContentLoaded</code> 事件。</p>\n<p>解决上述问题具体的方式包括：</p>\n<ol>\n<li>在 <code>Turbolinks</code> 对应的生命周期里挂载和移除事件，计时器等。</li>\n<li>使用事件委托，本质依然是幂等，只当节点存在时触发事件。</li>\n<li>见下文。</li>\n</ol>\n<p>另外，<code>Turbolinks</code> 还存在的另一个问题则来源于 <code>addEventListener</code> 方法，在多次换页过程中触发的 <code>document.addEventListener</code> 会反复添加事件监听，这样会导致换页后依然能够执行上一个页面 <code>turbolinks:load</code> 生命周期里的内容。此时，生命周期内的操作幂等性就变得更加重要了。</p>\n<hr>\n<h1 id=\"Turbolinks-Prefetch：预加载的新思路\"><a href=\"#Turbolinks-Prefetch：预加载的新思路\" class=\"headerlink\" title=\"Turbolinks Prefetch：预加载的新思路\"></a>Turbolinks Prefetch：预加载的新思路</h1><p>当提到 <code>Turbolinks</code> 时，有一个相关衍生的生态组件就不得不拿出来聊一聊了——<code>Turbolink Prefetch</code>。</p>\n<p>正如 <code>Prefetch</code> 这个名字一样，<code>Turbolinks Prefetch</code> 会进行预加载操作以提升页面的访问速度，其原理实际是一种叫做 <code>InstantClick</code> 技术。主要原理为：当用户鼠标置于链接上时，提前拉取目标地址的页面并缓存，当用户点击鼠标时直接从缓存中读取该页面。</p>\n<p><img src=\"/./images/cong-rails-shi-jiao-kan-xian-dai-qian-duan-huan-yi-chong-fang-shi-shi-xian-spa/7.webp\" alt=\"turbolinks-prefetch\"></p>\n<p>观察上图：</p>\n<ol>\n<li>当鼠标经过部分链接时，观察 <code>NetWork</code> 自动发送了请求。</li>\n<li>往上滚动时，虽然鼠标再次经过重复的链接，单并没有重复发送请求。</li>\n<li>点击已请求过的链接，<code>NetWork</code> 并没有发送其它请求，仅在页面加载后请求了页面上的资源文件。</li>\n<li>与前面 <code>Turbolinks</code> 的演示相同，对页面的请求依然使用使用的是 <code>xhr</code> 方式。</li>\n</ol>\n<p>虽然从技术角度来说，借助 <code>Turbolinks</code> 已有的缓存机制实现这一功能似乎并没有什么太大的难度，但我认为这样的思路却非常值得学习：即利用用户的碎片时间提前拉取资源以减少用户的等待时间。从目前来看，这一思路在混合 <code>APP</code> 实现 <code>WebView</code> 秒开时起到了非常不错的效果。</p>\n<hr>\n<h2 id=\"Assets-Pipeline：Rails-自己的构建工具\"><a href=\"#Assets-Pipeline：Rails-自己的构建工具\" class=\"headerlink\" title=\"Assets Pipeline：Rails 自己的构建工具\"></a>Assets Pipeline：Rails 自己的构建工具</h2><p>在我们谈论 <code>MVC</code> 下实现的前端有哪些问题时，提到了这样几个问题：</p>\n<ol>\n<li>缺少必要的构建工具，没有办法使用更高效的开发技术如 Sass，ECMAScript 的部分新特性。</li>\n<li>资源管理不合理，需要多次重复拉取相同的资源文件。</li>\n<li>……</li>\n</ol>\n<p>前面所介绍的 <code>Turbolinks</code>，<code>Turbolinks Prefetch</code> 等均是来自于交互方面的优化。而上面这些问题则指向了构建工具这一话题。</p>\n<p>在今天，当我们开发完成一个前端项目，通常进入生产环境前需要对源代码进行一系列的操作，它们包括：</p>\n<ol>\n<li>编译代码，把 <code>Sass</code>, <code>Less</code>, 以及高版本的 <code>ECMAScript</code> 等非浏览器可以直接执行的内容编译成低版本代码或原生代码；</li>\n<li>压缩代码，去除代码中不必要的换行，注释等，减少文件体积；</li>\n<li>混淆代码，将 <code>JS</code> 代码编译为不可读的丑化代码，进一步缩减文件体积；</li>\n<li>合并文件，减少 <code>HTTP</code> 请求次数；</li>\n<li>通过摘要算法计算 <code>Hash</code> 作为静态资源文件的文件名，使资源可以根据文件内容的变化来合理利用浏览器缓存；</li>\n</ol>\n<p>而实现这些操作则需要依赖构建工具，比较有名的就是大家都熟悉的 <code>webpack</code>。</p>\n<p>实际上，<code>Rails</code> 在很早就提供了这样一套框架用于静态资源的构建和管理——<code>Assets Pipeline</code>。</p>\n<p>放在今天，我们以一名前端工程师的视角来看 <code>Assets Pipeline</code> 其实是非常容易理解的。它主要利用 <code>Sprockets</code> 这一构建工具来实现了上面描述静态资源压缩，，使得在 <code>MVC</code> 的结构下一样可以合理，优雅的管理前端资源。</p>\n<p>同时 <code>Assets Pipeline</code> 还自带了 <code>Sass</code>, <code>CoffeeScript</code> 这些从 <code>Ruby</code> 社区孵化出的前端技术的支持。其中 <code>Sass</code> 提高了编写 <code>CSS</code> 的效率。而 <code>CoffeeScript</code> 则为 <code>ES5</code> 添加了诸多有用的语法扩展。如此，在 <code>MVC</code> 结构下也能获得良好的开发体验。</p>\n<p>注意一个细节：<code>Assets Pipeline</code> 在进行生产环境的预编译行为时，本质上与现在我们运行 <code>npm run build</code> 使用 <code>webpack</code> 进行打包有着非常大的相似之处。不同之处在于，<code>Rails MVC</code> 下的前端开发并不会依赖 <code>JS Render</code> ，由此导致现代前端基于 <code>webpack</code> 构建的静态资源和 <code>Rails</code> 基于 <code>Assets Pipeline</code> 构建的静态资源在体积上有着量级的区别。</p>\n<p>正是得益于这种技术栈不依赖 <code>JS</code> 构建页面，<code>Assets Pipeline</code> 可以放心大胆的将静态资源合并为一个单文件而不用担心体积过大造成资源加载慢的问题。</p>\n<p>因而当我们查看一个 <code>Rails</code> 传统技术开发的网站，会发现它仅在浏览器第一次加载页面时，完整的拉取脚本与样式文件，而后在 <code>Turbolinks</code> 启动后，每一次换页都不会也无需拉取静态资源文件，而是仅获取需要显示的 <code>HTML</code> 内容。</p>\n<p>有一个非常有意思的点：我们的站点在用户交互上与 <code>SPA</code> 一样在首屏拉取资源，也像 <code>SPA</code> 一样在无缝换页。</p>\n<hr>\n<h1 id=\"UJS：使用非侵入式的-JavaScript-缩减重复代码\"><a href=\"#UJS：使用非侵入式的-JavaScript-缩减重复代码\" class=\"headerlink\" title=\"UJS：使用非侵入式的 JavaScript 缩减重复代码\"></a>UJS：使用非侵入式的 JavaScript 缩减重复代码</h1><p>除了引入完整的构建体系以外，其实 <code>Rails</code> 还做有一个较为有趣的前端构建技术名为 <code>UJS</code>，它是 <code>Unobtrusive JavaScript</code> 的缩写，翻译为中文为 “非侵入式 <code>JavaScript</code>”。</p>\n<p><code>UJS</code> 本是指将 <code>JS</code> 与页面结构分离的代码风格，而 <code>Rails UJS</code> 只是基于这样一种风格编码的前端工具库，整个扩展仅有 700+ 行代码。</p>\n<p><code>Rails UJS</code> 内部实现了前面我们在 <code>PJAX</code> 和 <code>Turbolinks</code> 里提到的让 <code>a</code> 标签和 <code>form</code> 表单自动使用 <code>xhr</code> 提交的方法，但它并没有针对这一行为做后续的操作，而是提供了对应的事件回调。即是说，开发人员可以自由的设置某一个 <code>a</code> 标签或 <code>form</code> 表单为 <code>xhr</code> 提交，而需要做的仅仅是在该标签上增加一个 <code>data-remote=true</code> 属性，而后即可在回调中拿到对应的请求值。</p>\n<p>对比一下使用原生与使用 <code>Rails UJS</code> 实现表单 <code>xhr</code> 提交的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原生</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> form = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;form&quot;</span>);</span><br><span class=\"line\">form.<span class=\"property\">onsubmit</span> = <span class=\"keyword\">function</span> (<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">    e.<span class=\"title function_\">preventDefault</span>();</span><br><span class=\"line\">    <span class=\"comment\">//阻止submit默认提交行为</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fd = <span class=\"keyword\">new</span> <span class=\"title class_\">FormData</span>(form); </span><br><span class=\"line\">    fd.<span class=\"title function_\">append</span>(<span class=\"string\">&#x27;userId&#x27;</span>, <span class=\"string\">&#x27;1008611&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span><br><span class=\"line\">    xhr.<span class=\"title function_\">open</span>(<span class=\"string\">&quot;POST&quot;</span>,<span class=\"string\">&quot;http://www.xxx/api/xxx&quot;</span>);</span><br><span class=\"line\">    xhr.<span class=\"property\">onreadystatechange</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (xhr.<span class=\"property\">readyState</span> === <span class=\"number\">4</span> &amp;&amp; xhr.<span class=\"property\">status</span> === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(xhr.<span class=\"property\">responseText</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    xhr.<span class=\"title function_\">send</span>(fd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 rails_ujs </span></span><br><span class=\"line\"><span class=\"comment\">// 需要在对应的标签上添加 data-remote=true 就像</span></span><br><span class=\"line\"><span class=\"comment\">// &lt;form data-remote=&quot;true&quot; id=&quot;remoteForm&quot; action=&quot;/welcome/test_render&quot;&gt;...&lt;/form&gt;</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;#remoteLink&quot;</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;ajax:success&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">xhr, status, err</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(xhr, status, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>可以看到代码会简洁很多。</p>\n<p>除此之外，<code>Rails UJS</code> 也支持了更多的 <code>xhr</code> 参数如 <code>method</code> 等，使得我们基于这种方式来构建 <code>xhr</code> 变的更快更高效，减少了大量的重复代码。</p>\n<p>另一个有趣的用法是，在通过 <code>xhr</code> 请求时，由服务端渲染一段 <code>JavaScript</code>，可以很高效的实现一些交互逻辑。但由于这种方式不便于组织 <code>JS</code> 代码文件，此处不过多展开，详情可以读扩展阅读《<a href=\"https://ruby-china.org/topics/29046\">Rails 用 RJS 简单有效的实现页面局部刷新</a>》。</p>\n<hr>\n<h1 id=\"Stimulus：Turbolinks-幂等问题的最终解？\"><a href=\"#Stimulus：Turbolinks-幂等问题的最终解？\" class=\"headerlink\" title=\"Stimulus：Turbolinks 幂等问题的最终解？\"></a>Stimulus：Turbolinks 幂等问题的最终解？</h1><p><code>Turbolinks</code> 为我们提供了基本的页面交互 <code>SPA</code> 化的解决方案，使我们能以非常轻量的方式来实现一个体验极佳的站点。</p>\n<p><code>Assets Pipeline</code> 为我们带来的构建手段。</p>\n<p><code>Rails UJS</code> 简化了我们构建 <code>AJAX</code> 交互的代码量。</p>\n<p>但站在今天的角度来看，似乎编码体验上并没有太大的改进。我们依然在重复的码着 <code>JQuery</code>，我们也依然在重复的操作 <code>DOM</code>，甚至对于如何复用一个页面组件，我们依然没有一个合适的方式。与此同时，引入的 <code>Turbolinks</code> 带来了新的负担，编写 <code>JS</code> 代码的时候我们需要更加注意幂等性……</p>\n<p>当我们开始思考这样的问题的时候，<code>Stimulus</code> 来了。</p>\n<p><code>Stimulus</code> 同样是一个轻量的前端库，它通过 <code>H5</code> 的 <code>Mutation Observer</code> 这一特性彻底解决了 <code>Turbolinks</code> 幂等的问题。</p>\n<p><code>Mutation Observer</code> 可以完成 <code>DOM</code> 节点的监听，在 <code>DOM</code> 节点发生变化时，指定对应的逻辑。我们可以通俗的理解这一 <code>API</code> 为原生的 <code>DOM</code> 节点添加了自己的生命周期。</p>\n<p>直接看下面的 <code>Stimulus</code> 代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">Controller</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;stimulus&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">extends</span> <span class=\"title class_\">Controller</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> values = &#123; <span class=\"attr\">url</span>: <span class=\"title class_\">String</span>, <span class=\"attr\">refreshInterval</span>: <span class=\"title class_\">Number</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">connect</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">load</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">hasRefreshIntervalValue</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">startRefreshing</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">disconnect</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">stopRefreshing</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">load</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">fetch</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">urlValue</span>)</span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.<span class=\"title function_\">text</span>())</span><br><span class=\"line\">      .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">html</span> =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">element</span>.<span class=\"property\">innerHTML</span> = html)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">startRefreshing</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">refreshTimer</span> = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">this</span>.<span class=\"title function_\">load</span>()</span><br><span class=\"line\">    &#125;, <span class=\"variable language_\">this</span>.<span class=\"property\">refreshIntervalValue</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">stopRefreshing</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">refreshTimer</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearInterval</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">refreshTimer</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我有理由相信写过 <code>vue</code>, <code>react</code> 组件的现代前端工程师可以没有什么压力的阅读这段代码……</p>\n<p><code>Stimulus</code> 通过 <code>data-controller</code> 将逻辑关联到 <code>DOM</code> 节点，同时提供了对应节点的生命周期钩子函数，当节点被渲染后，会触发 <code>connect</code> 方法，而节点被销毁时会触发 <code>disconnect</code> 。同时 <code>Stimulus</code> 还支持定义状态与方法，最终这些内容被合理的挂载到节点的各位置，就像这样：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-controller</span>=<span class=\"string\">&quot;content-loader&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">data-content-loader-url-value</span>=<span class=\"string\">&quot;/messages.html&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">data-content-loader-refresh-interval-value</span>=<span class=\"string\">&quot;5000&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这一段代码复制于 <code>Stimulus</code> 的文档，它实现了一个可以自动异步加载页面的组件。</p>\n<p>由于节点拥有了自己的生命周期，只有当节点真正被渲染在页面上时 <code>Stimulus</code> 才会真正的执行对应的挂载逻辑，因而我们不再需要担心伴随 <code>Turbolinks</code> 的换页带来的事件绑定心智问题。</p>\n<p>同时，<code>Stimulus</code> 也完全解决了复用的问题，当需要在另一位置复用这一组件时，我们只需要为该节点添加上对应的 <code>data-controller</code> 属性即可。</p>\n<p>最后，<code>Stimulus</code> 通常在单一文件里定义组件，也就是说，基于 <code>Stimulus</code> 开发的应用不会再出现同一个 <code>JS</code> 文件里有成百上千行不知所云毫无关联的 <code>JavaScript</code> 代码的情况。</p>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><hr>\n<h1 id=\"结语（碎碎念）\"><a href=\"#结语（碎碎念）\" class=\"headerlink\" title=\"结语（碎碎念）\"></a>结语（碎碎念）</h1><p>其实本来打算再倒腾下 <code>Hotwire</code> 的，但是实在时间有限……</p>\n<p>前端是一个大的领域，即使放到一个框架里，内容也是非常多的。</p>\n<p>关于 <code>Rails</code> 的前端内容大概就先写到这里了，后面如果有空还会再补充。</p>\n<p>最后放上 <a href=\"https://ruby-china.org/\">Ruby China</a> 链接，可以从交互等方面来体验一下，几乎完全与 <code>SPA</code> 类似的交互体验。</p>\n<hr>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"https://github.com/rails/rails\">Ruby On Rails</a></li>\n<li><a href=\"https://github.com/defunkt/jquery-pjax\">JQuery PJAX</a></li>\n<li><a href=\"https://github.com/turbolinks/turbolinks\">Turbolinks</a></li>\n<li><a href=\"https://github.com/huacnlee/turbolinks-prefetch\">Turbolinks Prefetch</a></li>\n<li><a href=\"https://github.com/rails/jquery-ujs\">JQuery UJS</a></li>\n<li><a href=\"https://github.com/rails/rails-ujs/tree/master\">Rails UJS</a></li>\n<li><a href=\"https://github.com/hotwired/stimulus\">Stimulus</a></li>\n</ul>\n"},{"title":"关于Url传参的一点问题","date":"2018-09-07T14:00:00.000Z","_content":"晚一点看完比赛突然想起来URL传参的问题。\n\n当页面使用URL传参时，可以在浏览器通过修改URL来达成修改传参的效果，对于某些要插入到数据库的操作，这样的现象就略微有些危险了。虽然能使用`doPost()`方法不再在URL中显示传递的参数，但是通过尝试我发现，在已知参数名的情况下，依然可以通过URL进行参数的修改。\n\n**分析：**\n\n其实很容易明白，不过在页面中我是使用了`url?arg=`的方式，还是利用`form-submit`的方式，最终使用的都是`request.getParameter()`在页面开始前获取参数，而后在URL中传递的参数都会再次触发`request.getParameter()`从而覆盖掉之前的数据。\n\n**思考：**\n\n在明白了以上内容后，我尝试使用重定向`response.sendRedirect()`方法在不修改URL的情况下重定向，继而发现这样依然避免不了在新的页面使用`request.getParameter()`方法来获取上一个页面中的内容。\n\n联想到上一次的验证码，我想到了使用`Session`来尝试在新的页面直接由`Session`获取隐私数据，而不再使用这种传参方式。\n\n**困难：**\n\n然而很快我就发现这种想法的实现似乎有些难度，主要问题在于，我似乎没有办法把当前页面用户填写的数据马上获取后存入`Session`中，获取当前页面用户填写的内容的方法我能想到的是`JavaScript`的`document.getElementById()`函数，而这个数据我并没有办法将其存入`Session`中。\n\n**解决：**\n\n之后我想到了使用`Servlet`尝试完成，创建了用于测试的`TestServlet`类，重写了其`doPost()`方法，同时也将`doGet()`方法默认为`doPost()`方法。\n\n~~~java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t// TODO Auto-generated method stub\n\tString c=request.getParameter(\"c\");\n\trequest.getSession().setAttribute(\"c_val\",c);\n\tresponse.sendRedirect(\"../index4.jsp\");\n}\n~~~\n\n此处遇到了一个问题：在Servlet中转发/重定向的文件路径与jsp中并不相同，如上代码中，如果单填写`index4.jsp`是无法访问的，会404。在查阅了相关资料后发现要写`../index4.jsp`\n\n配置web.xml\n~~~xml\n<servlet>\n  \t<servlet-name>TestServlet</servlet-name>\n  \t<servlet-class>com.YuChi.TestServlet</servlet-class>\n  </servlet>\n  <servlet-mapping>\n  \t<servlet-name>TestServlet</servlet-name>\n  \t<url-pattern>/servlet/TestServlet</url-pattern>\n  </servlet-mapping>\n~~~\n\n运行\n\n![直接访问](./images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/1.webp)\n\n![url修改](./images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/2.webp)\n\n到此为止，终于实现了对于url传参的屏蔽效果，但事实上我并不知道这种所谓的屏蔽是否存在其意义，因为当我们使用`doPost()`方法传参时，用户是没有办法通过url得知控制参数的变量的，那么想要通过url修改参数的可行性也就有待考证了。\n","source":"_posts/关于Url传参的一点问题.md","raw":"---\ntitle: 关于Url传参的一点问题\ndate: 2018.09.07 22:00\ntags:\n  - Java\ncategories:\n  - 程序员的幸福：让代码变成强有力的工具\n---\n晚一点看完比赛突然想起来URL传参的问题。\n\n当页面使用URL传参时，可以在浏览器通过修改URL来达成修改传参的效果，对于某些要插入到数据库的操作，这样的现象就略微有些危险了。虽然能使用`doPost()`方法不再在URL中显示传递的参数，但是通过尝试我发现，在已知参数名的情况下，依然可以通过URL进行参数的修改。\n\n**分析：**\n\n其实很容易明白，不过在页面中我是使用了`url?arg=`的方式，还是利用`form-submit`的方式，最终使用的都是`request.getParameter()`在页面开始前获取参数，而后在URL中传递的参数都会再次触发`request.getParameter()`从而覆盖掉之前的数据。\n\n**思考：**\n\n在明白了以上内容后，我尝试使用重定向`response.sendRedirect()`方法在不修改URL的情况下重定向，继而发现这样依然避免不了在新的页面使用`request.getParameter()`方法来获取上一个页面中的内容。\n\n联想到上一次的验证码，我想到了使用`Session`来尝试在新的页面直接由`Session`获取隐私数据，而不再使用这种传参方式。\n\n**困难：**\n\n然而很快我就发现这种想法的实现似乎有些难度，主要问题在于，我似乎没有办法把当前页面用户填写的数据马上获取后存入`Session`中，获取当前页面用户填写的内容的方法我能想到的是`JavaScript`的`document.getElementById()`函数，而这个数据我并没有办法将其存入`Session`中。\n\n**解决：**\n\n之后我想到了使用`Servlet`尝试完成，创建了用于测试的`TestServlet`类，重写了其`doPost()`方法，同时也将`doGet()`方法默认为`doPost()`方法。\n\n~~~java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t// TODO Auto-generated method stub\n\tString c=request.getParameter(\"c\");\n\trequest.getSession().setAttribute(\"c_val\",c);\n\tresponse.sendRedirect(\"../index4.jsp\");\n}\n~~~\n\n此处遇到了一个问题：在Servlet中转发/重定向的文件路径与jsp中并不相同，如上代码中，如果单填写`index4.jsp`是无法访问的，会404。在查阅了相关资料后发现要写`../index4.jsp`\n\n配置web.xml\n~~~xml\n<servlet>\n  \t<servlet-name>TestServlet</servlet-name>\n  \t<servlet-class>com.YuChi.TestServlet</servlet-class>\n  </servlet>\n  <servlet-mapping>\n  \t<servlet-name>TestServlet</servlet-name>\n  \t<url-pattern>/servlet/TestServlet</url-pattern>\n  </servlet-mapping>\n~~~\n\n运行\n\n![直接访问](./images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/1.webp)\n\n![url修改](./images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/2.webp)\n\n到此为止，终于实现了对于url传参的屏蔽效果，但事实上我并不知道这种所谓的屏蔽是否存在其意义，因为当我们使用`doPost()`方法传参时，用户是没有办法通过url得知控制参数的变量的，那么想要通过url修改参数的可行性也就有待考证了。\n","slug":"关于Url传参的一点问题","published":1,"updated":"2022-05-03T09:44:38.552Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdui001wr2vefgau1zvw","content":"<p>晚一点看完比赛突然想起来URL传参的问题。</p>\n<p>当页面使用URL传参时，可以在浏览器通过修改URL来达成修改传参的效果，对于某些要插入到数据库的操作，这样的现象就略微有些危险了。虽然能使用<code>doPost()</code>方法不再在URL中显示传递的参数，但是通过尝试我发现，在已知参数名的情况下，依然可以通过URL进行参数的修改。</p>\n<p><strong>分析：</strong></p>\n<p>其实很容易明白，不过在页面中我是使用了<code>url?arg=</code>的方式，还是利用<code>form-submit</code>的方式，最终使用的都是<code>request.getParameter()</code>在页面开始前获取参数，而后在URL中传递的参数都会再次触发<code>request.getParameter()</code>从而覆盖掉之前的数据。</p>\n<p><strong>思考：</strong></p>\n<p>在明白了以上内容后，我尝试使用重定向<code>response.sendRedirect()</code>方法在不修改URL的情况下重定向，继而发现这样依然避免不了在新的页面使用<code>request.getParameter()</code>方法来获取上一个页面中的内容。</p>\n<p>联想到上一次的验证码，我想到了使用<code>Session</code>来尝试在新的页面直接由<code>Session</code>获取隐私数据，而不再使用这种传参方式。</p>\n<p><strong>困难：</strong></p>\n<p>然而很快我就发现这种想法的实现似乎有些难度，主要问题在于，我似乎没有办法把当前页面用户填写的数据马上获取后存入<code>Session</code>中，获取当前页面用户填写的内容的方法我能想到的是<code>JavaScript</code>的<code>document.getElementById()</code>函数，而这个数据我并没有办法将其存入<code>Session</code>中。</p>\n<p><strong>解决：</strong></p>\n<p>之后我想到了使用<code>Servlet</code>尝试完成，创建了用于测试的<code>TestServlet</code>类，重写了其<code>doPost()</code>方法，同时也将<code>doGet()</code>方法默认为<code>doPost()</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doPost</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\tString c=request.getParameter(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">\trequest.getSession().setAttribute(<span class=\"string\">&quot;c_val&quot;</span>,c);</span><br><span class=\"line\">\tresponse.sendRedirect(<span class=\"string\">&quot;../index4.jsp&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此处遇到了一个问题：在Servlet中转发&#x2F;重定向的文件路径与jsp中并不相同，如上代码中，如果单填写<code>index4.jsp</code>是无法访问的，会404。在查阅了相关资料后发现要写<code>../index4.jsp</code></p>\n<p>配置web.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>TestServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.YuChi.TestServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>TestServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/servlet/TestServlet<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行</p>\n<p><img src=\"/./images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/1.webp\" alt=\"直接访问\"></p>\n<p><img src=\"/./images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/2.webp\" alt=\"url修改\"></p>\n<p>到此为止，终于实现了对于url传参的屏蔽效果，但事实上我并不知道这种所谓的屏蔽是否存在其意义，因为当我们使用<code>doPost()</code>方法传参时，用户是没有办法通过url得知控制参数的变量的，那么想要通过url修改参数的可行性也就有待考证了。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<p>晚一点看完比赛突然想起来URL传参的问题。</p>\n<p>当页面使用URL传参时，可以在浏览器通过修改URL来达成修改传参的效果，对于某些要插入到数据库的操作，这样的现象就略微有些危险了。虽然能使用<code>doPost()</code>方法不再在URL中显示传递的参数，但是通过尝试我发现，在已知参数名的情况下，依然可以通过URL进行参数的修改。</p>\n<p><strong>分析：</strong></p>\n<p>其实很容易明白，不过在页面中我是使用了<code>url?arg=</code>的方式，还是利用<code>form-submit</code>的方式，最终使用的都是<code>request.getParameter()</code>在页面开始前获取参数，而后在URL中传递的参数都会再次触发<code>request.getParameter()</code>从而覆盖掉之前的数据。</p>\n<p><strong>思考：</strong></p>\n<p>在明白了以上内容后，我尝试使用重定向<code>response.sendRedirect()</code>方法在不修改URL的情况下重定向，继而发现这样依然避免不了在新的页面使用<code>request.getParameter()</code>方法来获取上一个页面中的内容。</p>\n<p>联想到上一次的验证码，我想到了使用<code>Session</code>来尝试在新的页面直接由<code>Session</code>获取隐私数据，而不再使用这种传参方式。</p>\n<p><strong>困难：</strong></p>\n<p>然而很快我就发现这种想法的实现似乎有些难度，主要问题在于，我似乎没有办法把当前页面用户填写的数据马上获取后存入<code>Session</code>中，获取当前页面用户填写的内容的方法我能想到的是<code>JavaScript</code>的<code>document.getElementById()</code>函数，而这个数据我并没有办法将其存入<code>Session</code>中。</p>\n<p><strong>解决：</strong></p>\n<p>之后我想到了使用<code>Servlet</code>尝试完成，创建了用于测试的<code>TestServlet</code>类，重写了其<code>doPost()</code>方法，同时也将<code>doGet()</code>方法默认为<code>doPost()</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doPost</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\tString c=request.getParameter(<span class=\"string\">&quot;c&quot;</span>);</span><br><span class=\"line\">\trequest.getSession().setAttribute(<span class=\"string\">&quot;c_val&quot;</span>,c);</span><br><span class=\"line\">\tresponse.sendRedirect(<span class=\"string\">&quot;../index4.jsp&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此处遇到了一个问题：在Servlet中转发&#x2F;重定向的文件路径与jsp中并不相同，如上代码中，如果单填写<code>index4.jsp</code>是无法访问的，会404。在查阅了相关资料后发现要写<code>../index4.jsp</code></p>\n<p>配置web.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>TestServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.YuChi.TestServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>TestServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/servlet/TestServlet<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>运行</p>\n<p><img src=\"/./images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/1.webp\" alt=\"直接访问\"></p>\n<p><img src=\"/./images/guan-yu-url-chuan-can-de-yi-dian-wen-ti/2.webp\" alt=\"url修改\"></p>\n<p>到此为止，终于实现了对于url传参的屏蔽效果，但事实上我并不知道这种所谓的屏蔽是否存在其意义，因为当我们使用<code>doPost()</code>方法传参时，用户是没有办法通过url得知控制参数的变量的，那么想要通过url修改参数的可行性也就有待考证了。</p>\n"},{"title":"关于浏览器那些蛋疼的东西","date":"2018-08-14T05:44:00.000Z","_content":"实习时接手了一台新电脑，然后使用浏览器的时候有了一些想法，记录一下。\n\n记住密码是大家都不会陌生的功能，许多家用电脑都是安装的360浏览器使得这些功能被使用的特别广泛，但这其中却存在着一些安全问题。\n\n![记住密码](./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/1.webp)\n\n如图是我自己登录码云时的界面，因为默认勾选了记住密码所以在登录的时候直接点击登录就可以登录了，非常快捷。\n\n我们按F12进入调试工具，可以看到如下界面，右击密码框选择审查元素后，将对应的HTML标签中的type更改为`text`后直接回车\n\n![image.png](./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/2.webp)\n\n会看到如下画面：\n\n![image.png](./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/3.webp)\n\n\n密码的加密已经没有了。其中的原理很简单，学过HTML的用户都能明白，将`<input>`标签的类型由密码框更改为文本框，但仅仅是这样简单的操作，却能瞬间泄露了用户的密码，让人完全不敢相信，于是我们又打开了一些比较大规模的网站。\n\n![qq邮箱](./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/4.webp)\n\n如图是QQ邮箱的一张登录图片大家都不陌生，我们尝试登录之后保存密码，然后退出重新登录，修改属性后发现\n\n![image.png](./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/5.webp)\n\n一样存在着这样的问题。\n\n但当我们使用一些不带插件的浏览器比如IE时，这种问题并不存在，也就是说为了安全考虑，大家在使用浏览器时还是尽量不要依赖这种功能为妙。\n\n从比较低级的角度说，他人如果盗用了您的电脑，那么很有可能直接获取到您的密码；而在这个Python火热的年代，不借用电脑的情况下盗取密码也着实不是什么难事。\n\n自动填写表单\n\n在很早的时候，我们就知道浏览器中有一款功能叫自动填写表单，但浏览器判断用户需要填写表单时，自动为用户填写入早已保存的信息，使得用户的使用会方便很多；然而事与愿违，在有了这种缺乏识别能力的功能后，许多钓鱼网站开始使用隐藏的表单来“骗取”浏览器自动填入，从而获取到用户的信息并远程发送出去，这使得人们的隐私与信息完全变成了公开的透明的信息。\n\n必须吐槽一下学jsp的时候费劲心思写的cookie自动填表单功能似乎有点问题。。。。\n","source":"_posts/关于浏览器那些蛋疼的东西.md","raw":"---\ntitle: 关于浏览器那些蛋疼的东西\ndate: 2018.08.14 13:44\ntags:\n  - 前端\ncategories:\n  - 程序员的幸福：让代码变成强有力的工具\n---\n实习时接手了一台新电脑，然后使用浏览器的时候有了一些想法，记录一下。\n\n记住密码是大家都不会陌生的功能，许多家用电脑都是安装的360浏览器使得这些功能被使用的特别广泛，但这其中却存在着一些安全问题。\n\n![记住密码](./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/1.webp)\n\n如图是我自己登录码云时的界面，因为默认勾选了记住密码所以在登录的时候直接点击登录就可以登录了，非常快捷。\n\n我们按F12进入调试工具，可以看到如下界面，右击密码框选择审查元素后，将对应的HTML标签中的type更改为`text`后直接回车\n\n![image.png](./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/2.webp)\n\n会看到如下画面：\n\n![image.png](./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/3.webp)\n\n\n密码的加密已经没有了。其中的原理很简单，学过HTML的用户都能明白，将`<input>`标签的类型由密码框更改为文本框，但仅仅是这样简单的操作，却能瞬间泄露了用户的密码，让人完全不敢相信，于是我们又打开了一些比较大规模的网站。\n\n![qq邮箱](./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/4.webp)\n\n如图是QQ邮箱的一张登录图片大家都不陌生，我们尝试登录之后保存密码，然后退出重新登录，修改属性后发现\n\n![image.png](./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/5.webp)\n\n一样存在着这样的问题。\n\n但当我们使用一些不带插件的浏览器比如IE时，这种问题并不存在，也就是说为了安全考虑，大家在使用浏览器时还是尽量不要依赖这种功能为妙。\n\n从比较低级的角度说，他人如果盗用了您的电脑，那么很有可能直接获取到您的密码；而在这个Python火热的年代，不借用电脑的情况下盗取密码也着实不是什么难事。\n\n自动填写表单\n\n在很早的时候，我们就知道浏览器中有一款功能叫自动填写表单，但浏览器判断用户需要填写表单时，自动为用户填写入早已保存的信息，使得用户的使用会方便很多；然而事与愿违，在有了这种缺乏识别能力的功能后，许多钓鱼网站开始使用隐藏的表单来“骗取”浏览器自动填入，从而获取到用户的信息并远程发送出去，这使得人们的隐私与信息完全变成了公开的透明的信息。\n\n必须吐槽一下学jsp的时候费劲心思写的cookie自动填表单功能似乎有点问题。。。。\n","slug":"关于浏览器那些蛋疼的东西","published":1,"updated":"2022-05-03T09:41:46.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mduj001yr2ve6p45c1tz","content":"<p>实习时接手了一台新电脑，然后使用浏览器的时候有了一些想法，记录一下。</p>\n<p>记住密码是大家都不会陌生的功能，许多家用电脑都是安装的360浏览器使得这些功能被使用的特别广泛，但这其中却存在着一些安全问题。</p>\n<p><img src=\"/./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/1.webp\" alt=\"记住密码\"></p>\n<p>如图是我自己登录码云时的界面，因为默认勾选了记住密码所以在登录的时候直接点击登录就可以登录了，非常快捷。</p>\n<p>我们按F12进入调试工具，可以看到如下界面，右击密码框选择审查元素后，将对应的HTML标签中的type更改为<code>text</code>后直接回车</p>\n<p><img src=\"/./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/2.webp\" alt=\"image.png\"></p>\n<p>会看到如下画面：</p>\n<p><img src=\"/./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/3.webp\" alt=\"image.png\"></p>\n<p>密码的加密已经没有了。其中的原理很简单，学过HTML的用户都能明白，将<code>&lt;input&gt;</code>标签的类型由密码框更改为文本框，但仅仅是这样简单的操作，却能瞬间泄露了用户的密码，让人完全不敢相信，于是我们又打开了一些比较大规模的网站。</p>\n<p><img src=\"/./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/4.webp\" alt=\"qq邮箱\"></p>\n<p>如图是QQ邮箱的一张登录图片大家都不陌生，我们尝试登录之后保存密码，然后退出重新登录，修改属性后发现</p>\n<p><img src=\"/./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/5.webp\" alt=\"image.png\"></p>\n<p>一样存在着这样的问题。</p>\n<p>但当我们使用一些不带插件的浏览器比如IE时，这种问题并不存在，也就是说为了安全考虑，大家在使用浏览器时还是尽量不要依赖这种功能为妙。</p>\n<p>从比较低级的角度说，他人如果盗用了您的电脑，那么很有可能直接获取到您的密码；而在这个Python火热的年代，不借用电脑的情况下盗取密码也着实不是什么难事。</p>\n<p>自动填写表单</p>\n<p>在很早的时候，我们就知道浏览器中有一款功能叫自动填写表单，但浏览器判断用户需要填写表单时，自动为用户填写入早已保存的信息，使得用户的使用会方便很多；然而事与愿违，在有了这种缺乏识别能力的功能后，许多钓鱼网站开始使用隐藏的表单来“骗取”浏览器自动填入，从而获取到用户的信息并远程发送出去，这使得人们的隐私与信息完全变成了公开的透明的信息。</p>\n<p>必须吐槽一下学jsp的时候费劲心思写的cookie自动填表单功能似乎有点问题。。。。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<p>实习时接手了一台新电脑，然后使用浏览器的时候有了一些想法，记录一下。</p>\n<p>记住密码是大家都不会陌生的功能，许多家用电脑都是安装的360浏览器使得这些功能被使用的特别广泛，但这其中却存在着一些安全问题。</p>\n<p><img src=\"/./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/1.webp\" alt=\"记住密码\"></p>\n<p>如图是我自己登录码云时的界面，因为默认勾选了记住密码所以在登录的时候直接点击登录就可以登录了，非常快捷。</p>\n<p>我们按F12进入调试工具，可以看到如下界面，右击密码框选择审查元素后，将对应的HTML标签中的type更改为<code>text</code>后直接回车</p>\n<p><img src=\"/./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/2.webp\" alt=\"image.png\"></p>\n<p>会看到如下画面：</p>\n<p><img src=\"/./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/3.webp\" alt=\"image.png\"></p>\n<p>密码的加密已经没有了。其中的原理很简单，学过HTML的用户都能明白，将<code>&lt;input&gt;</code>标签的类型由密码框更改为文本框，但仅仅是这样简单的操作，却能瞬间泄露了用户的密码，让人完全不敢相信，于是我们又打开了一些比较大规模的网站。</p>\n<p><img src=\"/./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/4.webp\" alt=\"qq邮箱\"></p>\n<p>如图是QQ邮箱的一张登录图片大家都不陌生，我们尝试登录之后保存密码，然后退出重新登录，修改属性后发现</p>\n<p><img src=\"/./images/guan-yu-liu-lan-qi-na-xie-dan-teng-de-dong-xi/5.webp\" alt=\"image.png\"></p>\n<p>一样存在着这样的问题。</p>\n<p>但当我们使用一些不带插件的浏览器比如IE时，这种问题并不存在，也就是说为了安全考虑，大家在使用浏览器时还是尽量不要依赖这种功能为妙。</p>\n<p>从比较低级的角度说，他人如果盗用了您的电脑，那么很有可能直接获取到您的密码；而在这个Python火热的年代，不借用电脑的情况下盗取密码也着实不是什么难事。</p>\n<p>自动填写表单</p>\n<p>在很早的时候，我们就知道浏览器中有一款功能叫自动填写表单，但浏览器判断用户需要填写表单时，自动为用户填写入早已保存的信息，使得用户的使用会方便很多；然而事与愿违，在有了这种缺乏识别能力的功能后，许多钓鱼网站开始使用隐藏的表单来“骗取”浏览器自动填入，从而获取到用户的信息并远程发送出去，这使得人们的隐私与信息完全变成了公开的透明的信息。</p>\n<p>必须吐槽一下学jsp的时候费劲心思写的cookie自动填表单功能似乎有点问题。。。。</p>\n"},{"title":"别踩白块儿HTML版的第一天","date":"2018-09-02T14:54:00.000Z","_content":"开始了一个非常有意思的小作业：别踩白块儿。\n\n一开始学前端的时候就已经想到了可以尝试一下，今天是终于开始了。\n首先确定的是思路，页面只有3个按钮：\n- 开始游戏\n- 游戏排名\n- 作者信息\n\n其中游戏排名思路比较明确，使用JSP+mysql来完成即可。\n\n其次是开始游戏，游戏开始，黑白快开始往下落，黑白块用div制作。\n\n关于黑块，需要说明的是，黑块是随机生成的，因此我用了`Math.random（）`方法生成了0-3共4个数，并利用父子节点的关系随机给一个白块替换样式。这样就完成了黑块的随机生成。\n~~~js\nvar FirstContainer = $(\".block_container\")[0];\nvar index_block = $(FirstContainer).children()[black_index];\n$(index_block).addClass(\"black_block\");\n$(index_block).removeClass(\"white_block\");\n// 自动添加div\n$(\"<div class='block_container'><div class='white_block'></div><div class='white_block'></div><div class='white_block'></div><div class='white_block'></div></div>\").prependTo(\".GameFream\");  \n~~~\n\n接下来要实现的是往下滚动，我使用了`prependTo（）`方法往容器里插入div，并且设置了定时器，这样游戏启动之后便可以一直生成新的div块，整个游戏的动态效果差不多有了。\n\n~~~js\n// 自动添加div\n$(\"<div class='block_container'><div class='white_block'></div><div class='white_block'></div><div class='white_block'></div><div class='white_block'></div></div>\").prependTo(\".GameFream\");  \n~~~\n\n接下来要写的是规则，别踩白块儿的游戏机制是用户单击白块或黑块超过屏幕界限时游戏结束，点击黑块则计分。\n\n单击白块很容易写，而屏幕界限则要使用到一个获取屏幕高度的方法了。\n\n~~~js\n// 单击黑块\n$(\".black_block\").click(function() {\n    $(\".black_block\").off('click').click(function() {\n        $(this).addClass(\"finish_block\");\n        $(this).removeClass(\"black_block\");\n        score += 100;\n    })\n})\n\n// 单击白块\n$(\".white_block\").click(function(){\n    if($(this).hasClass(\"white_block\")){\n        clearTimeout(GameTimer);\n        $(\".Game_Over\").show(300);\n        $(\".score\").text(\"您的分数是\"+score);\n    }\n})\n\n // 黑块超过屏幕\nvar PrintHeight = $(window).height();\nvar black_length = $(\".black_block\").length;\nvar black_top = $($(\".black_block\")[black_length - 1]).offset().top;\n\nif(black_top > PrintHeight){\n    clearTimeout(GameTimer);\n    $(\".Game_Over\").show(300);\n    $(\".score\").text(\"您的分数是\" + score);\n}\n~~~\n\n完成了这些，一个简单的游戏模型就有了。\n\n![别踩白块儿](./images/bie-cai-bai-kuai-er-html-ban-de-di-yi-tian/1.webp)\n\n在这个地方遇到了一个问题，是关于事件冒泡的。在获取黑块时，获取了整个页面的黑块，之后计分的时候，事件体执行了多次，导致积分不能正常计入，目前正在鼓捣。\n","source":"_posts/别踩白块儿HTML版的第一天.md","raw":"---\ntitle: 别踩白块儿HTML版的第一天\ndate: 2018.09.02 22:54\ntags:\n  - 前端\ncategories:\n  - 程序员的幸福：让代码变成强有力的工具\n---\n开始了一个非常有意思的小作业：别踩白块儿。\n\n一开始学前端的时候就已经想到了可以尝试一下，今天是终于开始了。\n首先确定的是思路，页面只有3个按钮：\n- 开始游戏\n- 游戏排名\n- 作者信息\n\n其中游戏排名思路比较明确，使用JSP+mysql来完成即可。\n\n其次是开始游戏，游戏开始，黑白快开始往下落，黑白块用div制作。\n\n关于黑块，需要说明的是，黑块是随机生成的，因此我用了`Math.random（）`方法生成了0-3共4个数，并利用父子节点的关系随机给一个白块替换样式。这样就完成了黑块的随机生成。\n~~~js\nvar FirstContainer = $(\".block_container\")[0];\nvar index_block = $(FirstContainer).children()[black_index];\n$(index_block).addClass(\"black_block\");\n$(index_block).removeClass(\"white_block\");\n// 自动添加div\n$(\"<div class='block_container'><div class='white_block'></div><div class='white_block'></div><div class='white_block'></div><div class='white_block'></div></div>\").prependTo(\".GameFream\");  \n~~~\n\n接下来要实现的是往下滚动，我使用了`prependTo（）`方法往容器里插入div，并且设置了定时器，这样游戏启动之后便可以一直生成新的div块，整个游戏的动态效果差不多有了。\n\n~~~js\n// 自动添加div\n$(\"<div class='block_container'><div class='white_block'></div><div class='white_block'></div><div class='white_block'></div><div class='white_block'></div></div>\").prependTo(\".GameFream\");  \n~~~\n\n接下来要写的是规则，别踩白块儿的游戏机制是用户单击白块或黑块超过屏幕界限时游戏结束，点击黑块则计分。\n\n单击白块很容易写，而屏幕界限则要使用到一个获取屏幕高度的方法了。\n\n~~~js\n// 单击黑块\n$(\".black_block\").click(function() {\n    $(\".black_block\").off('click').click(function() {\n        $(this).addClass(\"finish_block\");\n        $(this).removeClass(\"black_block\");\n        score += 100;\n    })\n})\n\n// 单击白块\n$(\".white_block\").click(function(){\n    if($(this).hasClass(\"white_block\")){\n        clearTimeout(GameTimer);\n        $(\".Game_Over\").show(300);\n        $(\".score\").text(\"您的分数是\"+score);\n    }\n})\n\n // 黑块超过屏幕\nvar PrintHeight = $(window).height();\nvar black_length = $(\".black_block\").length;\nvar black_top = $($(\".black_block\")[black_length - 1]).offset().top;\n\nif(black_top > PrintHeight){\n    clearTimeout(GameTimer);\n    $(\".Game_Over\").show(300);\n    $(\".score\").text(\"您的分数是\" + score);\n}\n~~~\n\n完成了这些，一个简单的游戏模型就有了。\n\n![别踩白块儿](./images/bie-cai-bai-kuai-er-html-ban-de-di-yi-tian/1.webp)\n\n在这个地方遇到了一个问题，是关于事件冒泡的。在获取黑块时，获取了整个页面的黑块，之后计分的时候，事件体执行了多次，导致积分不能正常计入，目前正在鼓捣。\n","slug":"别踩白块儿HTML版的第一天","published":1,"updated":"2022-05-03T09:33:26.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mduj0021r2ve0wabeg9y","content":"<p>开始了一个非常有意思的小作业：别踩白块儿。</p>\n<p>一开始学前端的时候就已经想到了可以尝试一下，今天是终于开始了。<br>首先确定的是思路，页面只有3个按钮：</p>\n<ul>\n<li>开始游戏</li>\n<li>游戏排名</li>\n<li>作者信息</li>\n</ul>\n<p>其中游戏排名思路比较明确，使用JSP+mysql来完成即可。</p>\n<p>其次是开始游戏，游戏开始，黑白快开始往下落，黑白块用div制作。</p>\n<p>关于黑块，需要说明的是，黑块是随机生成的，因此我用了<code>Math.random（）</code>方法生成了0-3共4个数，并利用父子节点的关系随机给一个白块替换样式。这样就完成了黑块的随机生成。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">FirstContainer</span> = $(<span class=\"string\">&quot;.block_container&quot;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> index_block = $(<span class=\"title class_\">FirstContainer</span>).<span class=\"title function_\">children</span>()[black_index];</span><br><span class=\"line\">$(index_block).<span class=\"title function_\">addClass</span>(<span class=\"string\">&quot;black_block&quot;</span>);</span><br><span class=\"line\">$(index_block).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&quot;white_block&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 自动添加div</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;&lt;div class=&#x27;block_container&#x27;&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;/div&gt;&quot;</span>).<span class=\"title function_\">prependTo</span>(<span class=\"string\">&quot;.GameFream&quot;</span>);  </span><br></pre></td></tr></table></figure>\n\n<p>接下来要实现的是往下滚动，我使用了<code>prependTo（）</code>方法往容器里插入div，并且设置了定时器，这样游戏启动之后便可以一直生成新的div块，整个游戏的动态效果差不多有了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自动添加div</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;&lt;div class=&#x27;block_container&#x27;&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;/div&gt;&quot;</span>).<span class=\"title function_\">prependTo</span>(<span class=\"string\">&quot;.GameFream&quot;</span>);  </span><br></pre></td></tr></table></figure>\n\n<p>接下来要写的是规则，别踩白块儿的游戏机制是用户单击白块或黑块超过屏幕界限时游戏结束，点击黑块则计分。</p>\n<p>单击白块很容易写，而屏幕界限则要使用到一个获取屏幕高度的方法了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 单击黑块</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;.black_block&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;.black_block&quot;</span>).<span class=\"title function_\">off</span>(<span class=\"string\">&#x27;click&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        $(<span class=\"variable language_\">this</span>).<span class=\"title function_\">addClass</span>(<span class=\"string\">&quot;finish_block&quot;</span>);</span><br><span class=\"line\">        $(<span class=\"variable language_\">this</span>).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&quot;black_block&quot;</span>);</span><br><span class=\"line\">        score += <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单击白块</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;.white_block&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>($(<span class=\"variable language_\">this</span>).<span class=\"title function_\">hasClass</span>(<span class=\"string\">&quot;white_block&quot;</span>))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(<span class=\"title class_\">GameTimer</span>);</span><br><span class=\"line\">        $(<span class=\"string\">&quot;.Game_Over&quot;</span>).<span class=\"title function_\">show</span>(<span class=\"number\">300</span>);</span><br><span class=\"line\">        $(<span class=\"string\">&quot;.score&quot;</span>).<span class=\"title function_\">text</span>(<span class=\"string\">&quot;您的分数是&quot;</span>+score);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 黑块超过屏幕</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">PrintHeight</span> = $(<span class=\"variable language_\">window</span>).<span class=\"title function_\">height</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> black_length = $(<span class=\"string\">&quot;.black_block&quot;</span>).<span class=\"property\">length</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> black_top = $($(<span class=\"string\">&quot;.black_block&quot;</span>)[black_length - <span class=\"number\">1</span>]).<span class=\"title function_\">offset</span>().<span class=\"property\">top</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(black_top &gt; <span class=\"title class_\">PrintHeight</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(<span class=\"title class_\">GameTimer</span>);</span><br><span class=\"line\">    $(<span class=\"string\">&quot;.Game_Over&quot;</span>).<span class=\"title function_\">show</span>(<span class=\"number\">300</span>);</span><br><span class=\"line\">    $(<span class=\"string\">&quot;.score&quot;</span>).<span class=\"title function_\">text</span>(<span class=\"string\">&quot;您的分数是&quot;</span> + score);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成了这些，一个简单的游戏模型就有了。</p>\n<p><img src=\"/./images/bie-cai-bai-kuai-er-html-ban-de-di-yi-tian/1.webp\" alt=\"别踩白块儿\"></p>\n<p>在这个地方遇到了一个问题，是关于事件冒泡的。在获取黑块时，获取了整个页面的黑块，之后计分的时候，事件体执行了多次，导致积分不能正常计入，目前正在鼓捣。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<p>开始了一个非常有意思的小作业：别踩白块儿。</p>\n<p>一开始学前端的时候就已经想到了可以尝试一下，今天是终于开始了。<br>首先确定的是思路，页面只有3个按钮：</p>\n<ul>\n<li>开始游戏</li>\n<li>游戏排名</li>\n<li>作者信息</li>\n</ul>\n<p>其中游戏排名思路比较明确，使用JSP+mysql来完成即可。</p>\n<p>其次是开始游戏，游戏开始，黑白快开始往下落，黑白块用div制作。</p>\n<p>关于黑块，需要说明的是，黑块是随机生成的，因此我用了<code>Math.random（）</code>方法生成了0-3共4个数，并利用父子节点的关系随机给一个白块替换样式。这样就完成了黑块的随机生成。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">FirstContainer</span> = $(<span class=\"string\">&quot;.block_container&quot;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> index_block = $(<span class=\"title class_\">FirstContainer</span>).<span class=\"title function_\">children</span>()[black_index];</span><br><span class=\"line\">$(index_block).<span class=\"title function_\">addClass</span>(<span class=\"string\">&quot;black_block&quot;</span>);</span><br><span class=\"line\">$(index_block).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&quot;white_block&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 自动添加div</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;&lt;div class=&#x27;block_container&#x27;&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;/div&gt;&quot;</span>).<span class=\"title function_\">prependTo</span>(<span class=\"string\">&quot;.GameFream&quot;</span>);  </span><br></pre></td></tr></table></figure>\n\n<p>接下来要实现的是往下滚动，我使用了<code>prependTo（）</code>方法往容器里插入div，并且设置了定时器，这样游戏启动之后便可以一直生成新的div块，整个游戏的动态效果差不多有了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自动添加div</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;&lt;div class=&#x27;block_container&#x27;&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;/div&gt;&quot;</span>).<span class=\"title function_\">prependTo</span>(<span class=\"string\">&quot;.GameFream&quot;</span>);  </span><br></pre></td></tr></table></figure>\n\n<p>接下来要写的是规则，别踩白块儿的游戏机制是用户单击白块或黑块超过屏幕界限时游戏结束，点击黑块则计分。</p>\n<p>单击白块很容易写，而屏幕界限则要使用到一个获取屏幕高度的方法了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 单击黑块</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;.black_block&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;.black_block&quot;</span>).<span class=\"title function_\">off</span>(<span class=\"string\">&#x27;click&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        $(<span class=\"variable language_\">this</span>).<span class=\"title function_\">addClass</span>(<span class=\"string\">&quot;finish_block&quot;</span>);</span><br><span class=\"line\">        $(<span class=\"variable language_\">this</span>).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&quot;black_block&quot;</span>);</span><br><span class=\"line\">        score += <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单击白块</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;.white_block&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>($(<span class=\"variable language_\">this</span>).<span class=\"title function_\">hasClass</span>(<span class=\"string\">&quot;white_block&quot;</span>))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(<span class=\"title class_\">GameTimer</span>);</span><br><span class=\"line\">        $(<span class=\"string\">&quot;.Game_Over&quot;</span>).<span class=\"title function_\">show</span>(<span class=\"number\">300</span>);</span><br><span class=\"line\">        $(<span class=\"string\">&quot;.score&quot;</span>).<span class=\"title function_\">text</span>(<span class=\"string\">&quot;您的分数是&quot;</span>+score);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 黑块超过屏幕</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">PrintHeight</span> = $(<span class=\"variable language_\">window</span>).<span class=\"title function_\">height</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> black_length = $(<span class=\"string\">&quot;.black_block&quot;</span>).<span class=\"property\">length</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> black_top = $($(<span class=\"string\">&quot;.black_block&quot;</span>)[black_length - <span class=\"number\">1</span>]).<span class=\"title function_\">offset</span>().<span class=\"property\">top</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(black_top &gt; <span class=\"title class_\">PrintHeight</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(<span class=\"title class_\">GameTimer</span>);</span><br><span class=\"line\">    $(<span class=\"string\">&quot;.Game_Over&quot;</span>).<span class=\"title function_\">show</span>(<span class=\"number\">300</span>);</span><br><span class=\"line\">    $(<span class=\"string\">&quot;.score&quot;</span>).<span class=\"title function_\">text</span>(<span class=\"string\">&quot;您的分数是&quot;</span> + score);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成了这些，一个简单的游戏模型就有了。</p>\n<p><img src=\"/./images/bie-cai-bai-kuai-er-html-ban-de-di-yi-tian/1.webp\" alt=\"别踩白块儿\"></p>\n<p>在这个地方遇到了一个问题，是关于事件冒泡的。在获取黑块时，获取了整个页面的黑块，之后计分的时候，事件体执行了多次，导致积分不能正常计入，目前正在鼓捣。</p>\n"},{"title":"别踩白块儿HTML版的第二天","date":"2018-09-03T07:15:00.000Z","_content":"\n大清早开始鼓捣事件冒泡结果手一抖把昨天写的js文件删了……于是乎花了一上午重写js文件\n\n花了些时间完成了随机生成黑块的功能\n\n~~~JS\n// 利用子父关系获取黑块:获取最新生成的block_container，并获取位于第block_index位置的div标签\nvar FirstContainer = $(\".block_container\")[0];\nvar index_block = $(FirstContainer).children()[black_index];\n$(index_block).addClass(\"black_block\");\n$(index_block).removeClass(\"white_block\");\n// 自动添加div\n$(\"<div class='block_container'><div class='white_block'></div><div class='white_block'></div><div class='white_block'></div><div class='white_block'></div></div>\").prependTo(\".GameFream\");  \n~~~\n\n需要提的一点是，关于children()方法返回的并不是一个DOM，因此需要用$()将它转换成一个jQuery对象。\n\n因为代码量不大，所以直接用了switch-case写了一个对应时间修改速度的功能。另外，因为算法本身的问题，游戏没有办法进行太久，只能设置了一个1.5W分的通关分数。\n\n~~~js\nif(score > 15000){\n    clearTimeout(GameTimer);\n    $(\".Success\").show(300);\n    return false;\n} else {\n    switch (score) {\n        case 2000:TimerSecond = 900;break;\n        case 4000:TimerSecond = 800;break;\n        case 6000:TimerSecond = 700;break;\n        case 8000:TimerSecond = 600;break;\n        case 10000:TimerSecond = 500;break;\n        case 12000:TimerSecond = 400;break;\n        case 14000:TimerSecond = 300;break;\n    }\n    clearTimeout(GameTimer);\n    setTimeout(Game,TimerSecond);\n}\n~~~\n\n在单击白块的模块中出现了一个问题导致，每次单击第二个开始往后的`black_block`都会直接导致游戏结束。参考了百度发现似乎是因为样式改变了之后动态绑定的事件没有更改，于是使用了`hasClass()`方法做了一次判断。\n\n~~~js\n// 单击白块\n$(\".white_block\").click(function() {\n    if($(this).hasClass(\"white_block\")){\n        clearTimeout(GameTimer);\n        $(\".Game_Over\").show(300);\n        $(\".score\").text(\"您的分数是\" + score);\n    }\n})\n~~~\n\n关于昨天留下的事件冒泡的问题\n\n因为所有黑块都是随机生成的，因此使用`$(\".black_block\")`会获取到不止一个元素，另外又不知道用户单击的是哪一个，所以在样式更改时是使用了`this`关键字的，但分数部分却没有办法避免，一旦页面中出现了多个相同的黑块，分数就会增加100*黑块数量。\n\n一开始我以为是事件冒泡，但是查阅了发现，这种现象并不是事件冒泡，使用`return false`或者`event.stoppropagation()`是没有办法阻止的，之后我尝试使用了`one()`方法，然而一样，单击事件被执行了多次，作为事件类部方法，每次都对应不同的元素，`one()`方法一样被执行了多次。其中我发现如果抛出异常，后面的部分就不会执行了，试图抛出一个自定义异常来阻断事件的执行，不过好在后面解决了。\n\n解决方法：使用`off()`方法，在执行前先解绑绑定的所有元素\n~~~js\n // 单击黑块\n$(\".black_block\").click(function() {\n    $(\".black_block\").off('click').click(function() {\n        $(this).addClass(\"finish_block\");\n        $(this).removeClass(\"black_block\");\n        score += 100;\n    });\n})\n~~~\n\n该方法可以解除指定元素上的所有指定事件，这样便使分数的累加正常了。\n\n![游戏测试](./images/bie-cai-bai-kuai-er-html-ban-de-di-er-tian/2.webp)\n\n到这里，整个游戏的模型算是勉强写好了= =接下来润色一下界面和完成后端的编写就可以挂到服务器上啦。\n","source":"_posts/别踩白块儿HTML版的第二天.md","raw":"---\ntitle: 别踩白块儿HTML版的第二天\ndate: 2018.09.03 15:15\ntags:\n  - 前端\ncategories:\n  - 程序员的幸福：让代码变成强有力的工具\n---\n\n大清早开始鼓捣事件冒泡结果手一抖把昨天写的js文件删了……于是乎花了一上午重写js文件\n\n花了些时间完成了随机生成黑块的功能\n\n~~~JS\n// 利用子父关系获取黑块:获取最新生成的block_container，并获取位于第block_index位置的div标签\nvar FirstContainer = $(\".block_container\")[0];\nvar index_block = $(FirstContainer).children()[black_index];\n$(index_block).addClass(\"black_block\");\n$(index_block).removeClass(\"white_block\");\n// 自动添加div\n$(\"<div class='block_container'><div class='white_block'></div><div class='white_block'></div><div class='white_block'></div><div class='white_block'></div></div>\").prependTo(\".GameFream\");  \n~~~\n\n需要提的一点是，关于children()方法返回的并不是一个DOM，因此需要用$()将它转换成一个jQuery对象。\n\n因为代码量不大，所以直接用了switch-case写了一个对应时间修改速度的功能。另外，因为算法本身的问题，游戏没有办法进行太久，只能设置了一个1.5W分的通关分数。\n\n~~~js\nif(score > 15000){\n    clearTimeout(GameTimer);\n    $(\".Success\").show(300);\n    return false;\n} else {\n    switch (score) {\n        case 2000:TimerSecond = 900;break;\n        case 4000:TimerSecond = 800;break;\n        case 6000:TimerSecond = 700;break;\n        case 8000:TimerSecond = 600;break;\n        case 10000:TimerSecond = 500;break;\n        case 12000:TimerSecond = 400;break;\n        case 14000:TimerSecond = 300;break;\n    }\n    clearTimeout(GameTimer);\n    setTimeout(Game,TimerSecond);\n}\n~~~\n\n在单击白块的模块中出现了一个问题导致，每次单击第二个开始往后的`black_block`都会直接导致游戏结束。参考了百度发现似乎是因为样式改变了之后动态绑定的事件没有更改，于是使用了`hasClass()`方法做了一次判断。\n\n~~~js\n// 单击白块\n$(\".white_block\").click(function() {\n    if($(this).hasClass(\"white_block\")){\n        clearTimeout(GameTimer);\n        $(\".Game_Over\").show(300);\n        $(\".score\").text(\"您的分数是\" + score);\n    }\n})\n~~~\n\n关于昨天留下的事件冒泡的问题\n\n因为所有黑块都是随机生成的，因此使用`$(\".black_block\")`会获取到不止一个元素，另外又不知道用户单击的是哪一个，所以在样式更改时是使用了`this`关键字的，但分数部分却没有办法避免，一旦页面中出现了多个相同的黑块，分数就会增加100*黑块数量。\n\n一开始我以为是事件冒泡，但是查阅了发现，这种现象并不是事件冒泡，使用`return false`或者`event.stoppropagation()`是没有办法阻止的，之后我尝试使用了`one()`方法，然而一样，单击事件被执行了多次，作为事件类部方法，每次都对应不同的元素，`one()`方法一样被执行了多次。其中我发现如果抛出异常，后面的部分就不会执行了，试图抛出一个自定义异常来阻断事件的执行，不过好在后面解决了。\n\n解决方法：使用`off()`方法，在执行前先解绑绑定的所有元素\n~~~js\n // 单击黑块\n$(\".black_block\").click(function() {\n    $(\".black_block\").off('click').click(function() {\n        $(this).addClass(\"finish_block\");\n        $(this).removeClass(\"black_block\");\n        score += 100;\n    });\n})\n~~~\n\n该方法可以解除指定元素上的所有指定事件，这样便使分数的累加正常了。\n\n![游戏测试](./images/bie-cai-bai-kuai-er-html-ban-de-di-er-tian/2.webp)\n\n到这里，整个游戏的模型算是勉强写好了= =接下来润色一下界面和完成后端的编写就可以挂到服务器上啦。\n","slug":"别踩白块儿HTML版的第二天","published":1,"updated":"2022-05-03T09:31:34.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mduk0023r2veh0ez4jnb","content":"<p>大清早开始鼓捣事件冒泡结果手一抖把昨天写的js文件删了……于是乎花了一上午重写js文件</p>\n<p>花了些时间完成了随机生成黑块的功能</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 利用子父关系获取黑块:获取最新生成的block_container，并获取位于第block_index位置的div标签</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">FirstContainer</span> = $(<span class=\"string\">&quot;.block_container&quot;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> index_block = $(<span class=\"title class_\">FirstContainer</span>).<span class=\"title function_\">children</span>()[black_index];</span><br><span class=\"line\">$(index_block).<span class=\"title function_\">addClass</span>(<span class=\"string\">&quot;black_block&quot;</span>);</span><br><span class=\"line\">$(index_block).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&quot;white_block&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 自动添加div</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;&lt;div class=&#x27;block_container&#x27;&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;/div&gt;&quot;</span>).<span class=\"title function_\">prependTo</span>(<span class=\"string\">&quot;.GameFream&quot;</span>);  </span><br></pre></td></tr></table></figure>\n\n<p>需要提的一点是，关于children()方法返回的并不是一个DOM，因此需要用$()将它转换成一个jQuery对象。</p>\n<p>因为代码量不大，所以直接用了switch-case写了一个对应时间修改速度的功能。另外，因为算法本身的问题，游戏没有办法进行太久，只能设置了一个1.5W分的通关分数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(score &gt; <span class=\"number\">15000</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(<span class=\"title class_\">GameTimer</span>);</span><br><span class=\"line\">    $(<span class=\"string\">&quot;.Success&quot;</span>).<span class=\"title function_\">show</span>(<span class=\"number\">300</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (score) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">900</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">4000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">800</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">6000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">700</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">8000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">600</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">10000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">500</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">12000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">400</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">14000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">300</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(<span class=\"title class_\">GameTimer</span>);</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"title class_\">Game</span>,<span class=\"title class_\">TimerSecond</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在单击白块的模块中出现了一个问题导致，每次单击第二个开始往后的<code>black_block</code>都会直接导致游戏结束。参考了百度发现似乎是因为样式改变了之后动态绑定的事件没有更改，于是使用了<code>hasClass()</code>方法做了一次判断。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 单击白块</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;.white_block&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>($(<span class=\"variable language_\">this</span>).<span class=\"title function_\">hasClass</span>(<span class=\"string\">&quot;white_block&quot;</span>))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(<span class=\"title class_\">GameTimer</span>);</span><br><span class=\"line\">        $(<span class=\"string\">&quot;.Game_Over&quot;</span>).<span class=\"title function_\">show</span>(<span class=\"number\">300</span>);</span><br><span class=\"line\">        $(<span class=\"string\">&quot;.score&quot;</span>).<span class=\"title function_\">text</span>(<span class=\"string\">&quot;您的分数是&quot;</span> + score);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>关于昨天留下的事件冒泡的问题</p>\n<p>因为所有黑块都是随机生成的，因此使用<code>$(&quot;.black_block&quot;)</code>会获取到不止一个元素，另外又不知道用户单击的是哪一个，所以在样式更改时是使用了<code>this</code>关键字的，但分数部分却没有办法避免，一旦页面中出现了多个相同的黑块，分数就会增加100*黑块数量。</p>\n<p>一开始我以为是事件冒泡，但是查阅了发现，这种现象并不是事件冒泡，使用<code>return false</code>或者<code>event.stoppropagation()</code>是没有办法阻止的，之后我尝试使用了<code>one()</code>方法，然而一样，单击事件被执行了多次，作为事件类部方法，每次都对应不同的元素，<code>one()</code>方法一样被执行了多次。其中我发现如果抛出异常，后面的部分就不会执行了，试图抛出一个自定义异常来阻断事件的执行，不过好在后面解决了。</p>\n<p>解决方法：使用<code>off()</code>方法，在执行前先解绑绑定的所有元素</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 单击黑块</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;.black_block&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;.black_block&quot;</span>).<span class=\"title function_\">off</span>(<span class=\"string\">&#x27;click&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        $(<span class=\"variable language_\">this</span>).<span class=\"title function_\">addClass</span>(<span class=\"string\">&quot;finish_block&quot;</span>);</span><br><span class=\"line\">        $(<span class=\"variable language_\">this</span>).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&quot;black_block&quot;</span>);</span><br><span class=\"line\">        score += <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>该方法可以解除指定元素上的所有指定事件，这样便使分数的累加正常了。</p>\n<p><img src=\"/./images/bie-cai-bai-kuai-er-html-ban-de-di-er-tian/2.webp\" alt=\"游戏测试\"></p>\n<p>到这里，整个游戏的模型算是勉强写好了&#x3D; &#x3D;接下来润色一下界面和完成后端的编写就可以挂到服务器上啦。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<p>大清早开始鼓捣事件冒泡结果手一抖把昨天写的js文件删了……于是乎花了一上午重写js文件</p>\n<p>花了些时间完成了随机生成黑块的功能</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 利用子父关系获取黑块:获取最新生成的block_container，并获取位于第block_index位置的div标签</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"title class_\">FirstContainer</span> = $(<span class=\"string\">&quot;.block_container&quot;</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> index_block = $(<span class=\"title class_\">FirstContainer</span>).<span class=\"title function_\">children</span>()[black_index];</span><br><span class=\"line\">$(index_block).<span class=\"title function_\">addClass</span>(<span class=\"string\">&quot;black_block&quot;</span>);</span><br><span class=\"line\">$(index_block).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&quot;white_block&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 自动添加div</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;&lt;div class=&#x27;block_container&#x27;&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;white_block&#x27;&gt;&lt;/div&gt;&lt;/div&gt;&quot;</span>).<span class=\"title function_\">prependTo</span>(<span class=\"string\">&quot;.GameFream&quot;</span>);  </span><br></pre></td></tr></table></figure>\n\n<p>需要提的一点是，关于children()方法返回的并不是一个DOM，因此需要用$()将它转换成一个jQuery对象。</p>\n<p>因为代码量不大，所以直接用了switch-case写了一个对应时间修改速度的功能。另外，因为算法本身的问题，游戏没有办法进行太久，只能设置了一个1.5W分的通关分数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(score &gt; <span class=\"number\">15000</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(<span class=\"title class_\">GameTimer</span>);</span><br><span class=\"line\">    $(<span class=\"string\">&quot;.Success&quot;</span>).<span class=\"title function_\">show</span>(<span class=\"number\">300</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (score) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">900</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">4000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">800</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">6000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">700</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">8000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">600</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">10000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">500</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">12000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">400</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">14000</span>:<span class=\"title class_\">TimerSecond</span> = <span class=\"number\">300</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(<span class=\"title class_\">GameTimer</span>);</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"title class_\">Game</span>,<span class=\"title class_\">TimerSecond</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在单击白块的模块中出现了一个问题导致，每次单击第二个开始往后的<code>black_block</code>都会直接导致游戏结束。参考了百度发现似乎是因为样式改变了之后动态绑定的事件没有更改，于是使用了<code>hasClass()</code>方法做了一次判断。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 单击白块</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;.white_block&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>($(<span class=\"variable language_\">this</span>).<span class=\"title function_\">hasClass</span>(<span class=\"string\">&quot;white_block&quot;</span>))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(<span class=\"title class_\">GameTimer</span>);</span><br><span class=\"line\">        $(<span class=\"string\">&quot;.Game_Over&quot;</span>).<span class=\"title function_\">show</span>(<span class=\"number\">300</span>);</span><br><span class=\"line\">        $(<span class=\"string\">&quot;.score&quot;</span>).<span class=\"title function_\">text</span>(<span class=\"string\">&quot;您的分数是&quot;</span> + score);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>关于昨天留下的事件冒泡的问题</p>\n<p>因为所有黑块都是随机生成的，因此使用<code>$(&quot;.black_block&quot;)</code>会获取到不止一个元素，另外又不知道用户单击的是哪一个，所以在样式更改时是使用了<code>this</code>关键字的，但分数部分却没有办法避免，一旦页面中出现了多个相同的黑块，分数就会增加100*黑块数量。</p>\n<p>一开始我以为是事件冒泡，但是查阅了发现，这种现象并不是事件冒泡，使用<code>return false</code>或者<code>event.stoppropagation()</code>是没有办法阻止的，之后我尝试使用了<code>one()</code>方法，然而一样，单击事件被执行了多次，作为事件类部方法，每次都对应不同的元素，<code>one()</code>方法一样被执行了多次。其中我发现如果抛出异常，后面的部分就不会执行了，试图抛出一个自定义异常来阻断事件的执行，不过好在后面解决了。</p>\n<p>解决方法：使用<code>off()</code>方法，在执行前先解绑绑定的所有元素</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 单击黑块</span></span><br><span class=\"line\">$(<span class=\"string\">&quot;.black_block&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    $(<span class=\"string\">&quot;.black_block&quot;</span>).<span class=\"title function_\">off</span>(<span class=\"string\">&#x27;click&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        $(<span class=\"variable language_\">this</span>).<span class=\"title function_\">addClass</span>(<span class=\"string\">&quot;finish_block&quot;</span>);</span><br><span class=\"line\">        $(<span class=\"variable language_\">this</span>).<span class=\"title function_\">removeClass</span>(<span class=\"string\">&quot;black_block&quot;</span>);</span><br><span class=\"line\">        score += <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>该方法可以解除指定元素上的所有指定事件，这样便使分数的累加正常了。</p>\n<p><img src=\"/./images/bie-cai-bai-kuai-er-html-ban-de-di-er-tian/2.webp\" alt=\"游戏测试\"></p>\n<p>到这里，整个游戏的模型算是勉强写好了&#x3D; &#x3D;接下来润色一下界面和完成后端的编写就可以挂到服务器上啦。</p>\n"},{"title":"别踩白块儿总结","date":"2018-09-04T15:02:00.000Z","_content":"\n今天写完了所谓的“后端”部分，前面说简单其实写起来还是遇到了不少问题。\n\n又遇到了php时的插入数据库时的？？？问题，修改了云服务器mysql的my.ini文件。\n\n遇到了页面刷新后会执行缓存里的内容，不得已修改了页面的写法。\n\n下面说重点吧\n\n之前我一直觉得简单的后端我没有问题的，但是今天写完之后，发现了一个叫做`SQL`注入的骚东西，利用url传参轻而易举的修改了数据库里的内容，一下子就觉得不好了。\n\n![修改过的积分页面](./images/bie-cai-bai-kuai-er-zong-jie/1.png)\n\n\n大概在这之后，会想要沉下心去学好后端了，之后再考虑服务器的事情了。不然感觉一直停留在玩玩的层面上没有进步。\n\n其实我自己的想法是，这次的尝试将是我学习javaweb途中一个重要的里程碑，一方面它是我自己完全从0开始尝试做出来的；另一方面它又毫不留情的暴露了我最大的软弱。所以到此，整个云服务器的体验就这样了，学习更多的东西了再做更好的内容吧。\n","source":"_posts/别踩白块儿总结.md","raw":"---\ntitle: 别踩白块儿总结\ndate: 2018.09.04 23:02\ntags:\n  - 前端\ncategories:\n  - 程序员的幸福：让代码变成强有力的工具\n---\n\n今天写完了所谓的“后端”部分，前面说简单其实写起来还是遇到了不少问题。\n\n又遇到了php时的插入数据库时的？？？问题，修改了云服务器mysql的my.ini文件。\n\n遇到了页面刷新后会执行缓存里的内容，不得已修改了页面的写法。\n\n下面说重点吧\n\n之前我一直觉得简单的后端我没有问题的，但是今天写完之后，发现了一个叫做`SQL`注入的骚东西，利用url传参轻而易举的修改了数据库里的内容，一下子就觉得不好了。\n\n![修改过的积分页面](./images/bie-cai-bai-kuai-er-zong-jie/1.png)\n\n\n大概在这之后，会想要沉下心去学好后端了，之后再考虑服务器的事情了。不然感觉一直停留在玩玩的层面上没有进步。\n\n其实我自己的想法是，这次的尝试将是我学习javaweb途中一个重要的里程碑，一方面它是我自己完全从0开始尝试做出来的；另一方面它又毫不留情的暴露了我最大的软弱。所以到此，整个云服务器的体验就这样了，学习更多的东西了再做更好的内容吧。\n","slug":"别踩白块儿总结","published":1,"updated":"2022-05-03T09:29:26.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdul0028r2ve509x6c13","content":"<p>今天写完了所谓的“后端”部分，前面说简单其实写起来还是遇到了不少问题。</p>\n<p>又遇到了php时的插入数据库时的？？？问题，修改了云服务器mysql的my.ini文件。</p>\n<p>遇到了页面刷新后会执行缓存里的内容，不得已修改了页面的写法。</p>\n<p>下面说重点吧</p>\n<p>之前我一直觉得简单的后端我没有问题的，但是今天写完之后，发现了一个叫做<code>SQL</code>注入的骚东西，利用url传参轻而易举的修改了数据库里的内容，一下子就觉得不好了。</p>\n<p><img src=\"/./images/bie-cai-bai-kuai-er-zong-jie/1.png\" alt=\"修改过的积分页面\"></p>\n<p>大概在这之后，会想要沉下心去学好后端了，之后再考虑服务器的事情了。不然感觉一直停留在玩玩的层面上没有进步。</p>\n<p>其实我自己的想法是，这次的尝试将是我学习javaweb途中一个重要的里程碑，一方面它是我自己完全从0开始尝试做出来的；另一方面它又毫不留情的暴露了我最大的软弱。所以到此，整个云服务器的体验就这样了，学习更多的东西了再做更好的内容吧。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<p>今天写完了所谓的“后端”部分，前面说简单其实写起来还是遇到了不少问题。</p>\n<p>又遇到了php时的插入数据库时的？？？问题，修改了云服务器mysql的my.ini文件。</p>\n<p>遇到了页面刷新后会执行缓存里的内容，不得已修改了页面的写法。</p>\n<p>下面说重点吧</p>\n<p>之前我一直觉得简单的后端我没有问题的，但是今天写完之后，发现了一个叫做<code>SQL</code>注入的骚东西，利用url传参轻而易举的修改了数据库里的内容，一下子就觉得不好了。</p>\n<p><img src=\"/./images/bie-cai-bai-kuai-er-zong-jie/1.png\" alt=\"修改过的积分页面\"></p>\n<p>大概在这之后，会想要沉下心去学好后端了，之后再考虑服务器的事情了。不然感觉一直停留在玩玩的层面上没有进步。</p>\n<p>其实我自己的想法是，这次的尝试将是我学习javaweb途中一个重要的里程碑，一方面它是我自己完全从0开始尝试做出来的；另一方面它又毫不留情的暴露了我最大的软弱。所以到此，整个云服务器的体验就这样了，学习更多的东西了再做更好的内容吧。</p>\n"},{"_content":"# 在Rails上搭建React服务端渲染瞎谈.md\n\n本文主要提供了一种在 `Rails` 里 `React` 搭建服务端渲染SPA的思路，主要涉及的技术栈如下：\n\n**ruby**:\n- [Rails 5.x ](https://ruby-china.github.io/rails-guides/)\n- [webpacker](https://github.com/rails/webpacker)\n- [react-rails](https://github.com/reactjs/react-rails)\n\n**JavaScript**\n- [React](https://react.docschina.org/docs/getting-started.html)\n- [React-Router](https://reactrouter.com/web)\n- [React-Redux](https://github.com/reduxjs/react-redux)\n\n\n## 1. 在 Rails 中搭建基本的SPA单页应用\n\n我们将基于 `React` 搭建一个 `DEMO` ，它包含了两个页面 `home` 和 `about`，可以来回切换 。\n\n撇开 `React` 不看，我们首先需要构建一个基础的 `MVC` 标准结构，在 `Rails` 里使用相关脚手架可以很快实现：\n\n```shell\nrails _5.2.4_ new my_blog --webpack=react\n\nrails g controller blogs index\n```\n\n使用 `rails s` 启动项目，可以访问 `/blogs/index` 页面看到 `Rails` 生成的页面。\n\n接下来我们需要添加 `react-rails` 扩展：\n\n```ruby\n# add to Gemfile.lock\ngem 'react-rails'\n```\n\n并执行安装：\n\n```shell\nbundle install\nrails g react:install\n```\n\n此时打开 `app/javascript` 目录，可以查看到项目目录下多了 `components` 目录，以及 `packs` 目录里增加了对应的入口文件。\n\n接下来，我们会把前面生成的 `/blogs/index` 作为入口页，渲染一个 `SPA` 标准单页应用。\n\n为了实现一个可用的 `SPA` 应用，我们可能有一些需要用到的库：\n\n```shell\nyarn add react-router-dom\n```\n\n为了引入 `JavaScript` 渲染脚本，我们需要在页面里进行一些配置，打开 `app/views/layouts/application.html.erb` 并在 `<head></head>` 标签中添加：\n\n```html\n<%= javascript_pack_tag 'application', 'data-turbolinks-track': 'reload' %>\n```\n\n它相当于现代前端在空白的 `index.html` 页面上添加 `<script src='./app.js'></script>` 。\n\n接下来我们编写一个 `React` 应用，在 `app/javascript/components` 目录下创建前端工程目录，如果你很熟练 `React` 则不必刻意与我的结构一样，但起码你应该能够很快的找到它：\n\n```shell\n- app\n    - javascript\n        - components\n            - routes\n            - app.jsx\n        - pages\n            - home\n                - index.jsx\n                - index.scss\n          - about\n              - index.jsx\n              - index.scss\n```\n\n如果你不熟练 `React` 与 `react-router-dom` ，你可以点击文章顶部的链接翻阅它们的文档。\n\n以下是我编写的 `React` 应用的所有代码，它很简单：\n\n```jsx\n# app/javascript/components/pages/home/index.jsx\nimport React from 'react';\n\nexport default () => <h1>Home</h1>\n\n# app/javascript/components/pages/home/about.jsx\nimport React from 'react';\n\nexport default () => <h1>About me</h1>\n\n# app/javascript/components/routes/index.jsx\nimport React from 'react';\nimport {BrowserRouter, Switch, Link, Route} from 'react-router-dom';\n\nimport Home from '../pages/home';\nimport About from '../pages/about';\n\nexport default () => {\n    return (\n        <BrowserRouter>\n            <ul>\n                <Link to='/'>home</Link>\n        \t\t<br/>\n                <Link to='/about'>about</Link>\n            </ul>\n            <Switch>\n                <Route path='/' exact component={Home}/>\n                <Route path='/about' component={About}/>\n            </Switch>\n        </BrowserRouter>\n    )\n}\n```\n\n编写完成以后，我们需要把根组件渲染在页面上，这一步有点类似于 `React.render(<App />, rootEle)` 的操作。\n\n修改 `app/views/index.html.erb` ，添加 `React` 组件：\n\n```ruby\n<%= react_component 'routes' %>\n```\n\n此处的参数 `routes` 会自动寻找 `app/javascript/components` 目录下的 `routes` 组件，其规则与 `JavaScript` 相同，它可以使 `routes/index.jsx` 或者 `routes.jsx` 。\n\n到这里我们已经在 `Rails` 中实现了一个基本的 `SPA` 应用了，刷新页面可以看到有两个链接，点击能够来回切换不同的页面。\n\n美中不足的是此时刷新浏览器可能会得到 `404` 错误，这是因为在 `react-router` 里定义的路由与 `Rails Router` 里定义的不相同，当刷新浏览器，首先会请求的是 `Rails` 服务器，因此我们可以在 `config/routes.rb` 里添加对应配置，不用太复杂，只要能使对应的请求进入到挂载了 `routes` 根组件的页面里，就可以渲染对应的页面。\n\n```ruby\nRails.application.routes.draw do\n  root 'blogs#index'\n  get '*path', to: 'blogs#index'\nend\n```\n\n## 2. 使用预渲染解决首屏白屏问题\n\n当页面越来越大，结构越来越复杂时，`SPA` 可能会遇到首屏白屏的问题。这是因为复杂页面结构导致 `JavaScript` 文件的体积越来越大，且渲染流程更复杂。\n\n我们可以使用服务端预渲染来解决首屏白屏的问题，这很简单：\n\n```ruby\n<%= react_component 'routes', {}, { prerender: true } %>\n```\n\n添加 `prerender` 参数可开启预渲染。接下来的每一次用户请求，`react-rails` 都会直接将 `React` 组件预先渲染成 `HTML` 文本，这样可以节省大量的客户端渲染时间。\n\n到这里为止，我们在传统的 `Rails MVC` 架构上，增加了在页面里使用 `React` 的技巧，它可以使我们更灵活的构建页面， `React` 不是什么高深莫测的东西，只是帮助你构建 `HTML` 的工具，其它方面的 `Rails` 没有发生任何变化。\n\n因而你很容易发现，我们依然在使用 `Rails Router` 进行页面的管理。\n\n在这样一种方案下，预渲染可以很有效的解决白屏问题。\n\n为了更快的进行服务端预渲染，`CRuby/MRI Ruby` 用户可以添加 `mini_racer` 以获得更好的渲染效率：\n\n```ruby\n# Gemfile.lock\ngem 'mini_racer'\n```\n\n安装后重新启动服务，观察日志可以发现 `Controller` 层的耗时明显得到了优化。\n\n需要注意一点，由于页面在被服务端被渲染，因而渲染脚本 `application.js` 不需要在页面渲染前加载了，我们可以将其位置进行调整：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>MyBlog</title>\n    <%= csrf_meta_tags %>\n    <%= csp_meta_tag %>\n\n    <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>\n    <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>\n  </head>\n\n  <body>\n    <%= yield %>\n    <%= javascript_pack_tag 'application', 'data-turbolinks-track': 'reload' %>\n  </body>\n</html>\n```\n\n以防止脚本阻塞页面的加载。\n\n最后，由于渲染过程调整到了服务端，需要注意几点：\n\n- 在服务端无法识别 `window`，`document` 等对象，因此需要在指定的生命周期（如 `componentDidMount`）里使用 `DOM/BOM` 。部分直接操作 `DOM` 的库如部分 `JQuery` 的插件直接引入 `React` 会导致异常，目前只能在入口页（`layout.html.erb`）上引入。\n- ~~在服务端无法正常处理 `CSS` 样式，不要在 `React` 组件里直接引入 `CSS` 文件~~。\n- 由于 `style-loader` 会在样式导入时自动使用 `DOM` 操作进行样式注入，参考上一条，在服务端渲染场景下，`style-loader` 将无法正常工作。\n\n`React` 合成事件的绑定与 `Turbolinks` 换页的机制之间存在某种矛盾关系，在页面里使用 `Turbolinks` 将需要更加小心。\n\n你可能需要在 `React` 组件卸载的时候注销掉对应的事件，不过幸好这也是 `React` 开发中常涉及到的习惯，因而无需花费过多的心智。\n\n另一种可能是你希望在页面里使用 `react-router`，则此时仅仅开启 `prerender: true` 就不满足我们的需求了。\n\n## 3. 基于React-Rails的服务端渲染方案\n\n当在应用中使用 `react-router` 时，我们需要调整应用架构。\n\n主要问题在于 `BrowserRouter` 不能很好的处理服务端渲染的场景，这一点在 `react-router` 文档中也有提到。通常当你在一个使用了 `BrowserRouter` 的组件上开启 `prerender: true`，不出意外的话你会得到一个错误。\n\n由于整个应用依然是 `SPA` ，且我们开启服务端渲染的目的也只是解决首屏问题，因而首先要明确一点：**初次打开页面时并不需要渲染整个应用**。\n\n我们将对 `app/javascript/components/routes/index.jsx` 进行调整： \n\n```jsx\nimport React from 'react';\nimport {BrowserRouter, StaticRouter, Switch, Link, Route} from 'react-router-dom';\n\nimport Home from '../pages/home';\nimport About from '../pages/about';\n\nexport default props => {\n    return (\n        <StaticRouter location={props.path}>\n            <ul>\n                <Link to='/'>home</Link>\n                <br/>\n                <Link to='/about'>about</Link>\n            </ul>\n            <Switch>\n                <Route path='/' exact component={Home}/>\n                <Route path='/about' component={About}/>\n            </Switch>\n        </StaticRouter>\n    )\n}\n\n```\n\n此处我们把 `BrowserRouter` 替换为 `StaticRouter` ，它的作用是匹配渲染 `Router` 里的某个路由，它需要一个参数来确认需要渲染的是那一条路由，因此我们需要传递一个 `location` 给它。\n\n`location` 并不是一定要从 `props` 中获取，但这样做我们只需要在入口页上添加一个属性既可，相对来说更加的动态和方便：\n```html\n# 位于app/views/blogs/index.html.erb的入口页\n<%= react_component 'routes', {path: request.path}, {prerender: true} %>\n```\n\n此时在浏览器里输入对应的路径可以进入到期望得到的 `React` 页面。\n\n由于 `react-rails` 预渲染实际使用 `ReactDOMServer.renderToString()` 方法，这是一个 `React` 官方提供的用于服务端渲染的库。其特点是可以在 将 `React` 组件解析成静态的 `HTML` 内容。该方法是无法将 `React` 中使用的合成事件转化成静态内容的。\n\n我们调整应用，在任意位置添加一个点击事件，可以发现我们的应用并没有出现上述描述的情况，点击事件是可用的。这是因为  `react-rails` 的 `prerender` 其实是按照 **同构渲染** 的思路进行设计的。\n\n现代前端 **同构渲染** 解决方案的核心，是利用 `React` 服务端渲染 `API` 完成首屏渲染，然后再次请求服务器拉取客户端渲染代码进行二次渲染。这样做既可以快速渲染出首屏，也能在后续保证用户的体验。\n\n来看一下它在 `Rails` 里的具体工作流程：\n\n1. 用户访问任意页面至 `Rails` 服务器，`Rails Router` 进行处理与分发到对应 `Controller#action` 最终找到目标模板页准备渲染页面。\n2. 在目标模板页中确认需要渲染的页面并执行服务器渲染。\n3. 浏览器呈现服务器返回的静态页面。\n4. 浏览器再次请求服务器获取渲染脚本 `application.js` 。\n5. 浏览器下载 `application.js` 并自动执行完成客户端二次渲染。\n\n整个流程看起来复杂了不少，不过前面提到，`react-rails` 已经为我们做好了基本工作。\n\n回到应用里，点击 `Router` 会发现页面跳转无法正常工作，这是因为 `StaticRouter` 并不合适用在客户端上，二次渲染我们要使用之前的 `BrowserRouter` ，我们只需要对 `app/javascript/components/routes/index.jsx` 文件进行一些改造：\n\n```jsx\nimport React from 'react';\nimport {BrowserRouter, StaticRouter, Switch, Link, Route} from 'react-router-dom';\n\nimport Home from '../pages/home';\nimport About from '../pages/about';\n\nconst Router = props => {\n    if (typeof window === \"undefined\") {\n        return <StaticRouter location={props.location}>\n            {props.children}\n        </StaticRouter>\n    } else {\n        return <BrowserRouter>\n            {props.children}\n        </BrowserRouter>\n    }\n}\n\nexport default props => {\n    return (\n        <Router location={props.path}>\n            <ul>\n                <Link to='/'>home</Link>\n                <br/>\n                <Link to='/about'>about</Link>\n            </ul>\n            <Switch>\n                <Route path='/' exact component={Home}/>\n                <Route path='/about' component={About}/>\n            </Switch>\n        </Router>\n    )\n}\n```\n\n在新的代码里，我们添加了一个自定义的 `Router` 组件，该组件根据渲染场景动态的使用不同的 `React-Router API` ，可以注意我们是如何判断当前渲染场景的\n\n```javascript\ntypof window === \"undefined\"\n```\n\n正如前面所说，服务端没有 `window` 对象。\n\n此时再刷新浏览器，可以发现路由的跳转已经正常工作。\n\n到这里为止，我们已经实现了服务端渲染的大部分内容。\n\n不过还没结束，我们还有最后一个问题需要解决：**首屏渲染时的数据从哪儿获取？**\n\n暂时注释掉 `app/views/layouts/javascript.html.erb` 里，`body` 标签里的二次渲染脚本引入代码：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>MyBlog</title>\n    <%= csrf_meta_tags %>\n    <%= csp_meta_tag %>\n\n    <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>\n    <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>\n  </head>\n\n  <body>\n    <%= yield %>\n    <%#= javascript_pack_tag 'application', 'data-turbolinks-track': 'reload' %>\n  </body>\n</html>\n```\n\n然后刷新页面，`右击 -> 查看源代码` 可以看到虽然页面预渲染了，但实际渲染的是空的模板页，如果你的组件设计是在 `componentDidMount` 生命周期里进行异步请求拉取数据，则首屏渲染的时候不会拉取任何数据。\n\n对于一部分应用来说，这样也许无伤大雅，但对于另一部分应用，这个设计可能是一个缺陷。\n\n> 举个实际的例子，当你正在用 `React` 开发自己的博客系统，为了提高自己的知名度，你希望你的每一篇文章都能在搜索引擎里被搜索到，这将要求你的博客系统能够对动态数据进行基本的 `SEO` 。\n\n解决该问题的方法并不难，我们只需要在预渲染期间把数据注入到组件里既可。且由于 `react-rails` 本身是定义在 `Ruby` 环境里的，它对于将数据注入到组件里有着天然的优势。\n\n就像 `path` 一样，我们可以把数据注入到组件里：\n\n```html\n<%= react_component 'routes', {path: request.path, blogs: @blogs}, {prerender: true} %>\n```\n\n此时会把数据注入到 `routes` 组件中，但我们需要使用的组件实际是 `pages` 路径下的页面，可以使用 `StaticRouter` 提供的 `context` 来实现：\n\n```jsx\nimport React from 'react';\nimport {BrowserRouter, StaticRouter, Switch, Link, Route} from 'react-router-dom';\n\n...\n\nconst Router = props => {\n    if (typeof window === \"undefined\") {\n        return <StaticRouter location={props.location} context={props.context}>\n            {props.children}\n        </StaticRouter>\n    } else {\n        ...\n    }\n}\n\nexport default props => {\n    return (\n        <Router location={props.path} context={{blogs: props.blogs}}>\n            ...\n        </Router>\n    )\n}\n\n```\n\n上面的代码将入口页传入的 `blogs Props` 一层一层的最终传递给了 `StaticeRouter` 的 `context` 属性，然后我们可以在组件里访问：\n\n```jsx\nimport React from 'react';\n\nexport default props => {\n    console.log(props.staticContext)\n\n    return <>\n        ......\n    </>;\n}\n\n```\n\n通过 `props.staticContext` 既可获取到对应的数据。\n\n> 解开入口页注释掉的渲染脚本外部链接，然后刷新页面，会发现该语句打印了两次，第一次是我们注入的数据，第二次是undefined。这也是服务端渲染与客户端渲染的差异之一。\n>\n> 但请注意 **不要通过 `props.staticContext` 来判断当前的渲染环境**，因为我们无法保证该变量里到底存储了什么，如果注入的数据本身就是 `false`，`null`之类的数据，那么 `if (props.staticContext) {}` 也许会得到错误的判断结果。\n>\n> 推荐的做法依然是 `if (typeof window !== \"undefined\") {}` 。\n\n而后我们可以直接使用该值来作为服务端渲染时的初始状态：\n\n```jsx\nimport React from 'react';\n\nexport default class extends React.Component {\n    constructor(props) {\n        super(props);\n        if (typeof window !== \"undefined\") {\n            this.state = {\n                blogs: []\n            }\n        } else {\n            this.state = {\n                blogs: props.staticContext.blogs\n            }\n        }\n    }\n    \n    componentDidMount() {\n        axios.get('...').then(res => {\n            this.setState({\n                blogs: res.data.blogs\n            })\n        })\n    }\n\n    render() {\n        return <>\n            ......\n        </>;\n    }\n}\n\n```\n\n我们在初始化状态时根据渲染环境的区别分别给了不同的初始值，当服务端渲染时，直接使用注入的数据作为初始状态进行预渲染。当客户端渲染时，组件挂载后从服务器拉取数据。\n\n不难发现一个问题，并不是所有的入口页都需要注入数据，也不能保证所有的页面注入的数据结构都是 `{ blogs: [] }` ，因此最后的最后，我们需要统一服务端渲染时数据注入的格式，因为我们既不希望重复的入口页写多份，也不喜欢把数据弄的乱七八糟：\n\n**入口页**\n```html\n<%= react_component 'routes', {path: request.path, context: @data}, {prerender: true} %>\n```\n\n**`Route` 组件**\n\n```jsx\nimport React from 'react';\nimport {BrowserRouter, StaticRouter, Switch, Link, Route} from 'react-router-dom';\n\nconst Router = props => {\n    if (typeof window === \"undefined\") {\n        return <StaticRouter location={props.location} context={props.context}>\n            {props.children}\n        </StaticRouter>\n    } else {\n        return <BrowserRouter>\n            {props.children}\n        </BrowserRouter>\n    }\n}\n\nexport default props => {\n    return (\n        <Router location={props.path} context={props.context}>\n            ......\n        </Router>\n    )\n}\n```\n\n在对参数进行调整后，我们可以在 `Controller` 层动态的构造需要注入的数据，而不用关心渲染的模板页细节。\n\n> 事实由于组件是相同的，预渲染注入的数据与二次渲染的数据结构是一致的，因而我们可以利用 `Rails` 的自定义渲染特性来共用 `Controller` 层实现代码的精简。\n\n到这里，我们就实现了一个完整的服务端渲染`React`应用。它能够快速的响应用户请求渲染首屏，同时也能支持 `SEO` ，并且在页面完成渲染后，它还保留了 `SPA` 良好的用户体验。让我们回过头来看看我们做了哪些事情：\n\n1. 开启服务端预渲染选项，在这个过程里我们需要替换更高性能的 `NodeJS RunTime` ，同时还要调整脚本加载的位置，使之不要阻塞首屏渲染。\n2. 根据渲染环境使用不同的 `Router` ，其中服务端渲染需要传递 `path` 属性给 `StaticRouter` 。\n3. 预渲染的数据注入，在 `Controller` 层动态构建注入数据，通过 `context` 方式传入具体页面用作初始化。\n\n## 4. 最后说两句\n同构渲染是目前最流行的前端解决方案之一，但在实践的过程中我们不难发现任然有几个问题需要解决：\n\n1. 同构渲染的实践并不轻松，我们需要围绕渲染流程做许多准备工作。\n2. 当一部分组件需要在服务端渲染时，开发人员的职责会变得更混乱——注入数据的部分到底应该由服务端开发人员编写？还是前端开发人员编写？\n\n对此我的看法是，我们应该更加理性的对待不同的需求，毕竟不是所有的 `SPA` 都需要服务端渲染的。\n\n> 如果觉得本文对您有帮助，请给我一个赞~\n> 如果您对本文有不同的理解，可以在评论区留言告诉我~","source":"_posts/在Rails上搭建React服务端渲染瞎谈.md","raw":"# 在Rails上搭建React服务端渲染瞎谈.md\n\n本文主要提供了一种在 `Rails` 里 `React` 搭建服务端渲染SPA的思路，主要涉及的技术栈如下：\n\n**ruby**:\n- [Rails 5.x ](https://ruby-china.github.io/rails-guides/)\n- [webpacker](https://github.com/rails/webpacker)\n- [react-rails](https://github.com/reactjs/react-rails)\n\n**JavaScript**\n- [React](https://react.docschina.org/docs/getting-started.html)\n- [React-Router](https://reactrouter.com/web)\n- [React-Redux](https://github.com/reduxjs/react-redux)\n\n\n## 1. 在 Rails 中搭建基本的SPA单页应用\n\n我们将基于 `React` 搭建一个 `DEMO` ，它包含了两个页面 `home` 和 `about`，可以来回切换 。\n\n撇开 `React` 不看，我们首先需要构建一个基础的 `MVC` 标准结构，在 `Rails` 里使用相关脚手架可以很快实现：\n\n```shell\nrails _5.2.4_ new my_blog --webpack=react\n\nrails g controller blogs index\n```\n\n使用 `rails s` 启动项目，可以访问 `/blogs/index` 页面看到 `Rails` 生成的页面。\n\n接下来我们需要添加 `react-rails` 扩展：\n\n```ruby\n# add to Gemfile.lock\ngem 'react-rails'\n```\n\n并执行安装：\n\n```shell\nbundle install\nrails g react:install\n```\n\n此时打开 `app/javascript` 目录，可以查看到项目目录下多了 `components` 目录，以及 `packs` 目录里增加了对应的入口文件。\n\n接下来，我们会把前面生成的 `/blogs/index` 作为入口页，渲染一个 `SPA` 标准单页应用。\n\n为了实现一个可用的 `SPA` 应用，我们可能有一些需要用到的库：\n\n```shell\nyarn add react-router-dom\n```\n\n为了引入 `JavaScript` 渲染脚本，我们需要在页面里进行一些配置，打开 `app/views/layouts/application.html.erb` 并在 `<head></head>` 标签中添加：\n\n```html\n<%= javascript_pack_tag 'application', 'data-turbolinks-track': 'reload' %>\n```\n\n它相当于现代前端在空白的 `index.html` 页面上添加 `<script src='./app.js'></script>` 。\n\n接下来我们编写一个 `React` 应用，在 `app/javascript/components` 目录下创建前端工程目录，如果你很熟练 `React` 则不必刻意与我的结构一样，但起码你应该能够很快的找到它：\n\n```shell\n- app\n    - javascript\n        - components\n            - routes\n            - app.jsx\n        - pages\n            - home\n                - index.jsx\n                - index.scss\n          - about\n              - index.jsx\n              - index.scss\n```\n\n如果你不熟练 `React` 与 `react-router-dom` ，你可以点击文章顶部的链接翻阅它们的文档。\n\n以下是我编写的 `React` 应用的所有代码，它很简单：\n\n```jsx\n# app/javascript/components/pages/home/index.jsx\nimport React from 'react';\n\nexport default () => <h1>Home</h1>\n\n# app/javascript/components/pages/home/about.jsx\nimport React from 'react';\n\nexport default () => <h1>About me</h1>\n\n# app/javascript/components/routes/index.jsx\nimport React from 'react';\nimport {BrowserRouter, Switch, Link, Route} from 'react-router-dom';\n\nimport Home from '../pages/home';\nimport About from '../pages/about';\n\nexport default () => {\n    return (\n        <BrowserRouter>\n            <ul>\n                <Link to='/'>home</Link>\n        \t\t<br/>\n                <Link to='/about'>about</Link>\n            </ul>\n            <Switch>\n                <Route path='/' exact component={Home}/>\n                <Route path='/about' component={About}/>\n            </Switch>\n        </BrowserRouter>\n    )\n}\n```\n\n编写完成以后，我们需要把根组件渲染在页面上，这一步有点类似于 `React.render(<App />, rootEle)` 的操作。\n\n修改 `app/views/index.html.erb` ，添加 `React` 组件：\n\n```ruby\n<%= react_component 'routes' %>\n```\n\n此处的参数 `routes` 会自动寻找 `app/javascript/components` 目录下的 `routes` 组件，其规则与 `JavaScript` 相同，它可以使 `routes/index.jsx` 或者 `routes.jsx` 。\n\n到这里我们已经在 `Rails` 中实现了一个基本的 `SPA` 应用了，刷新页面可以看到有两个链接，点击能够来回切换不同的页面。\n\n美中不足的是此时刷新浏览器可能会得到 `404` 错误，这是因为在 `react-router` 里定义的路由与 `Rails Router` 里定义的不相同，当刷新浏览器，首先会请求的是 `Rails` 服务器，因此我们可以在 `config/routes.rb` 里添加对应配置，不用太复杂，只要能使对应的请求进入到挂载了 `routes` 根组件的页面里，就可以渲染对应的页面。\n\n```ruby\nRails.application.routes.draw do\n  root 'blogs#index'\n  get '*path', to: 'blogs#index'\nend\n```\n\n## 2. 使用预渲染解决首屏白屏问题\n\n当页面越来越大，结构越来越复杂时，`SPA` 可能会遇到首屏白屏的问题。这是因为复杂页面结构导致 `JavaScript` 文件的体积越来越大，且渲染流程更复杂。\n\n我们可以使用服务端预渲染来解决首屏白屏的问题，这很简单：\n\n```ruby\n<%= react_component 'routes', {}, { prerender: true } %>\n```\n\n添加 `prerender` 参数可开启预渲染。接下来的每一次用户请求，`react-rails` 都会直接将 `React` 组件预先渲染成 `HTML` 文本，这样可以节省大量的客户端渲染时间。\n\n到这里为止，我们在传统的 `Rails MVC` 架构上，增加了在页面里使用 `React` 的技巧，它可以使我们更灵活的构建页面， `React` 不是什么高深莫测的东西，只是帮助你构建 `HTML` 的工具，其它方面的 `Rails` 没有发生任何变化。\n\n因而你很容易发现，我们依然在使用 `Rails Router` 进行页面的管理。\n\n在这样一种方案下，预渲染可以很有效的解决白屏问题。\n\n为了更快的进行服务端预渲染，`CRuby/MRI Ruby` 用户可以添加 `mini_racer` 以获得更好的渲染效率：\n\n```ruby\n# Gemfile.lock\ngem 'mini_racer'\n```\n\n安装后重新启动服务，观察日志可以发现 `Controller` 层的耗时明显得到了优化。\n\n需要注意一点，由于页面在被服务端被渲染，因而渲染脚本 `application.js` 不需要在页面渲染前加载了，我们可以将其位置进行调整：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>MyBlog</title>\n    <%= csrf_meta_tags %>\n    <%= csp_meta_tag %>\n\n    <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>\n    <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>\n  </head>\n\n  <body>\n    <%= yield %>\n    <%= javascript_pack_tag 'application', 'data-turbolinks-track': 'reload' %>\n  </body>\n</html>\n```\n\n以防止脚本阻塞页面的加载。\n\n最后，由于渲染过程调整到了服务端，需要注意几点：\n\n- 在服务端无法识别 `window`，`document` 等对象，因此需要在指定的生命周期（如 `componentDidMount`）里使用 `DOM/BOM` 。部分直接操作 `DOM` 的库如部分 `JQuery` 的插件直接引入 `React` 会导致异常，目前只能在入口页（`layout.html.erb`）上引入。\n- ~~在服务端无法正常处理 `CSS` 样式，不要在 `React` 组件里直接引入 `CSS` 文件~~。\n- 由于 `style-loader` 会在样式导入时自动使用 `DOM` 操作进行样式注入，参考上一条，在服务端渲染场景下，`style-loader` 将无法正常工作。\n\n`React` 合成事件的绑定与 `Turbolinks` 换页的机制之间存在某种矛盾关系，在页面里使用 `Turbolinks` 将需要更加小心。\n\n你可能需要在 `React` 组件卸载的时候注销掉对应的事件，不过幸好这也是 `React` 开发中常涉及到的习惯，因而无需花费过多的心智。\n\n另一种可能是你希望在页面里使用 `react-router`，则此时仅仅开启 `prerender: true` 就不满足我们的需求了。\n\n## 3. 基于React-Rails的服务端渲染方案\n\n当在应用中使用 `react-router` 时，我们需要调整应用架构。\n\n主要问题在于 `BrowserRouter` 不能很好的处理服务端渲染的场景，这一点在 `react-router` 文档中也有提到。通常当你在一个使用了 `BrowserRouter` 的组件上开启 `prerender: true`，不出意外的话你会得到一个错误。\n\n由于整个应用依然是 `SPA` ，且我们开启服务端渲染的目的也只是解决首屏问题，因而首先要明确一点：**初次打开页面时并不需要渲染整个应用**。\n\n我们将对 `app/javascript/components/routes/index.jsx` 进行调整： \n\n```jsx\nimport React from 'react';\nimport {BrowserRouter, StaticRouter, Switch, Link, Route} from 'react-router-dom';\n\nimport Home from '../pages/home';\nimport About from '../pages/about';\n\nexport default props => {\n    return (\n        <StaticRouter location={props.path}>\n            <ul>\n                <Link to='/'>home</Link>\n                <br/>\n                <Link to='/about'>about</Link>\n            </ul>\n            <Switch>\n                <Route path='/' exact component={Home}/>\n                <Route path='/about' component={About}/>\n            </Switch>\n        </StaticRouter>\n    )\n}\n\n```\n\n此处我们把 `BrowserRouter` 替换为 `StaticRouter` ，它的作用是匹配渲染 `Router` 里的某个路由，它需要一个参数来确认需要渲染的是那一条路由，因此我们需要传递一个 `location` 给它。\n\n`location` 并不是一定要从 `props` 中获取，但这样做我们只需要在入口页上添加一个属性既可，相对来说更加的动态和方便：\n```html\n# 位于app/views/blogs/index.html.erb的入口页\n<%= react_component 'routes', {path: request.path}, {prerender: true} %>\n```\n\n此时在浏览器里输入对应的路径可以进入到期望得到的 `React` 页面。\n\n由于 `react-rails` 预渲染实际使用 `ReactDOMServer.renderToString()` 方法，这是一个 `React` 官方提供的用于服务端渲染的库。其特点是可以在 将 `React` 组件解析成静态的 `HTML` 内容。该方法是无法将 `React` 中使用的合成事件转化成静态内容的。\n\n我们调整应用，在任意位置添加一个点击事件，可以发现我们的应用并没有出现上述描述的情况，点击事件是可用的。这是因为  `react-rails` 的 `prerender` 其实是按照 **同构渲染** 的思路进行设计的。\n\n现代前端 **同构渲染** 解决方案的核心，是利用 `React` 服务端渲染 `API` 完成首屏渲染，然后再次请求服务器拉取客户端渲染代码进行二次渲染。这样做既可以快速渲染出首屏，也能在后续保证用户的体验。\n\n来看一下它在 `Rails` 里的具体工作流程：\n\n1. 用户访问任意页面至 `Rails` 服务器，`Rails Router` 进行处理与分发到对应 `Controller#action` 最终找到目标模板页准备渲染页面。\n2. 在目标模板页中确认需要渲染的页面并执行服务器渲染。\n3. 浏览器呈现服务器返回的静态页面。\n4. 浏览器再次请求服务器获取渲染脚本 `application.js` 。\n5. 浏览器下载 `application.js` 并自动执行完成客户端二次渲染。\n\n整个流程看起来复杂了不少，不过前面提到，`react-rails` 已经为我们做好了基本工作。\n\n回到应用里，点击 `Router` 会发现页面跳转无法正常工作，这是因为 `StaticRouter` 并不合适用在客户端上，二次渲染我们要使用之前的 `BrowserRouter` ，我们只需要对 `app/javascript/components/routes/index.jsx` 文件进行一些改造：\n\n```jsx\nimport React from 'react';\nimport {BrowserRouter, StaticRouter, Switch, Link, Route} from 'react-router-dom';\n\nimport Home from '../pages/home';\nimport About from '../pages/about';\n\nconst Router = props => {\n    if (typeof window === \"undefined\") {\n        return <StaticRouter location={props.location}>\n            {props.children}\n        </StaticRouter>\n    } else {\n        return <BrowserRouter>\n            {props.children}\n        </BrowserRouter>\n    }\n}\n\nexport default props => {\n    return (\n        <Router location={props.path}>\n            <ul>\n                <Link to='/'>home</Link>\n                <br/>\n                <Link to='/about'>about</Link>\n            </ul>\n            <Switch>\n                <Route path='/' exact component={Home}/>\n                <Route path='/about' component={About}/>\n            </Switch>\n        </Router>\n    )\n}\n```\n\n在新的代码里，我们添加了一个自定义的 `Router` 组件，该组件根据渲染场景动态的使用不同的 `React-Router API` ，可以注意我们是如何判断当前渲染场景的\n\n```javascript\ntypof window === \"undefined\"\n```\n\n正如前面所说，服务端没有 `window` 对象。\n\n此时再刷新浏览器，可以发现路由的跳转已经正常工作。\n\n到这里为止，我们已经实现了服务端渲染的大部分内容。\n\n不过还没结束，我们还有最后一个问题需要解决：**首屏渲染时的数据从哪儿获取？**\n\n暂时注释掉 `app/views/layouts/javascript.html.erb` 里，`body` 标签里的二次渲染脚本引入代码：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>MyBlog</title>\n    <%= csrf_meta_tags %>\n    <%= csp_meta_tag %>\n\n    <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>\n    <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>\n  </head>\n\n  <body>\n    <%= yield %>\n    <%#= javascript_pack_tag 'application', 'data-turbolinks-track': 'reload' %>\n  </body>\n</html>\n```\n\n然后刷新页面，`右击 -> 查看源代码` 可以看到虽然页面预渲染了，但实际渲染的是空的模板页，如果你的组件设计是在 `componentDidMount` 生命周期里进行异步请求拉取数据，则首屏渲染的时候不会拉取任何数据。\n\n对于一部分应用来说，这样也许无伤大雅，但对于另一部分应用，这个设计可能是一个缺陷。\n\n> 举个实际的例子，当你正在用 `React` 开发自己的博客系统，为了提高自己的知名度，你希望你的每一篇文章都能在搜索引擎里被搜索到，这将要求你的博客系统能够对动态数据进行基本的 `SEO` 。\n\n解决该问题的方法并不难，我们只需要在预渲染期间把数据注入到组件里既可。且由于 `react-rails` 本身是定义在 `Ruby` 环境里的，它对于将数据注入到组件里有着天然的优势。\n\n就像 `path` 一样，我们可以把数据注入到组件里：\n\n```html\n<%= react_component 'routes', {path: request.path, blogs: @blogs}, {prerender: true} %>\n```\n\n此时会把数据注入到 `routes` 组件中，但我们需要使用的组件实际是 `pages` 路径下的页面，可以使用 `StaticRouter` 提供的 `context` 来实现：\n\n```jsx\nimport React from 'react';\nimport {BrowserRouter, StaticRouter, Switch, Link, Route} from 'react-router-dom';\n\n...\n\nconst Router = props => {\n    if (typeof window === \"undefined\") {\n        return <StaticRouter location={props.location} context={props.context}>\n            {props.children}\n        </StaticRouter>\n    } else {\n        ...\n    }\n}\n\nexport default props => {\n    return (\n        <Router location={props.path} context={{blogs: props.blogs}}>\n            ...\n        </Router>\n    )\n}\n\n```\n\n上面的代码将入口页传入的 `blogs Props` 一层一层的最终传递给了 `StaticeRouter` 的 `context` 属性，然后我们可以在组件里访问：\n\n```jsx\nimport React from 'react';\n\nexport default props => {\n    console.log(props.staticContext)\n\n    return <>\n        ......\n    </>;\n}\n\n```\n\n通过 `props.staticContext` 既可获取到对应的数据。\n\n> 解开入口页注释掉的渲染脚本外部链接，然后刷新页面，会发现该语句打印了两次，第一次是我们注入的数据，第二次是undefined。这也是服务端渲染与客户端渲染的差异之一。\n>\n> 但请注意 **不要通过 `props.staticContext` 来判断当前的渲染环境**，因为我们无法保证该变量里到底存储了什么，如果注入的数据本身就是 `false`，`null`之类的数据，那么 `if (props.staticContext) {}` 也许会得到错误的判断结果。\n>\n> 推荐的做法依然是 `if (typeof window !== \"undefined\") {}` 。\n\n而后我们可以直接使用该值来作为服务端渲染时的初始状态：\n\n```jsx\nimport React from 'react';\n\nexport default class extends React.Component {\n    constructor(props) {\n        super(props);\n        if (typeof window !== \"undefined\") {\n            this.state = {\n                blogs: []\n            }\n        } else {\n            this.state = {\n                blogs: props.staticContext.blogs\n            }\n        }\n    }\n    \n    componentDidMount() {\n        axios.get('...').then(res => {\n            this.setState({\n                blogs: res.data.blogs\n            })\n        })\n    }\n\n    render() {\n        return <>\n            ......\n        </>;\n    }\n}\n\n```\n\n我们在初始化状态时根据渲染环境的区别分别给了不同的初始值，当服务端渲染时，直接使用注入的数据作为初始状态进行预渲染。当客户端渲染时，组件挂载后从服务器拉取数据。\n\n不难发现一个问题，并不是所有的入口页都需要注入数据，也不能保证所有的页面注入的数据结构都是 `{ blogs: [] }` ，因此最后的最后，我们需要统一服务端渲染时数据注入的格式，因为我们既不希望重复的入口页写多份，也不喜欢把数据弄的乱七八糟：\n\n**入口页**\n```html\n<%= react_component 'routes', {path: request.path, context: @data}, {prerender: true} %>\n```\n\n**`Route` 组件**\n\n```jsx\nimport React from 'react';\nimport {BrowserRouter, StaticRouter, Switch, Link, Route} from 'react-router-dom';\n\nconst Router = props => {\n    if (typeof window === \"undefined\") {\n        return <StaticRouter location={props.location} context={props.context}>\n            {props.children}\n        </StaticRouter>\n    } else {\n        return <BrowserRouter>\n            {props.children}\n        </BrowserRouter>\n    }\n}\n\nexport default props => {\n    return (\n        <Router location={props.path} context={props.context}>\n            ......\n        </Router>\n    )\n}\n```\n\n在对参数进行调整后，我们可以在 `Controller` 层动态的构造需要注入的数据，而不用关心渲染的模板页细节。\n\n> 事实由于组件是相同的，预渲染注入的数据与二次渲染的数据结构是一致的，因而我们可以利用 `Rails` 的自定义渲染特性来共用 `Controller` 层实现代码的精简。\n\n到这里，我们就实现了一个完整的服务端渲染`React`应用。它能够快速的响应用户请求渲染首屏，同时也能支持 `SEO` ，并且在页面完成渲染后，它还保留了 `SPA` 良好的用户体验。让我们回过头来看看我们做了哪些事情：\n\n1. 开启服务端预渲染选项，在这个过程里我们需要替换更高性能的 `NodeJS RunTime` ，同时还要调整脚本加载的位置，使之不要阻塞首屏渲染。\n2. 根据渲染环境使用不同的 `Router` ，其中服务端渲染需要传递 `path` 属性给 `StaticRouter` 。\n3. 预渲染的数据注入，在 `Controller` 层动态构建注入数据，通过 `context` 方式传入具体页面用作初始化。\n\n## 4. 最后说两句\n同构渲染是目前最流行的前端解决方案之一，但在实践的过程中我们不难发现任然有几个问题需要解决：\n\n1. 同构渲染的实践并不轻松，我们需要围绕渲染流程做许多准备工作。\n2. 当一部分组件需要在服务端渲染时，开发人员的职责会变得更混乱——注入数据的部分到底应该由服务端开发人员编写？还是前端开发人员编写？\n\n对此我的看法是，我们应该更加理性的对待不同的需求，毕竟不是所有的 `SPA` 都需要服务端渲染的。\n\n> 如果觉得本文对您有帮助，请给我一个赞~\n> 如果您对本文有不同的理解，可以在评论区留言告诉我~","slug":"在Rails上搭建React服务端渲染瞎谈","published":1,"date":"2022-05-03T08:46:25.152Z","updated":"2022-05-03T08:46:25.152Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdul002ar2ved1kob8y4","content":"<h1 id=\"在Rails上搭建React服务端渲染瞎谈-md\"><a href=\"#在Rails上搭建React服务端渲染瞎谈-md\" class=\"headerlink\" title=\"在Rails上搭建React服务端渲染瞎谈.md\"></a>在Rails上搭建React服务端渲染瞎谈.md</h1><p>本文主要提供了一种在 <code>Rails</code> 里 <code>React</code> 搭建服务端渲染SPA的思路，主要涉及的技术栈如下：</p>\n<p><strong>ruby</strong>:</p>\n<ul>\n<li><a href=\"https://ruby-china.github.io/rails-guides/\">Rails 5.x </a></li>\n<li><a href=\"https://github.com/rails/webpacker\">webpacker</a></li>\n<li><a href=\"https://github.com/reactjs/react-rails\">react-rails</a></li>\n</ul>\n<p><strong>JavaScript</strong></p>\n<ul>\n<li><a href=\"https://react.docschina.org/docs/getting-started.html\">React</a></li>\n<li><a href=\"https://reactrouter.com/web\">React-Router</a></li>\n<li><a href=\"https://github.com/reduxjs/react-redux\">React-Redux</a></li>\n</ul>\n<h2 id=\"1-在-Rails-中搭建基本的SPA单页应用\"><a href=\"#1-在-Rails-中搭建基本的SPA单页应用\" class=\"headerlink\" title=\"1. 在 Rails 中搭建基本的SPA单页应用\"></a>1. 在 Rails 中搭建基本的SPA单页应用</h2><p>我们将基于 <code>React</code> 搭建一个 <code>DEMO</code> ，它包含了两个页面 <code>home</code> 和 <code>about</code>，可以来回切换 。</p>\n<p>撇开 <code>React</code> 不看，我们首先需要构建一个基础的 <code>MVC</code> 标准结构，在 <code>Rails</code> 里使用相关脚手架可以很快实现：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rails _5.2.4_ new my_blog --webpack=react</span><br><span class=\"line\"></span><br><span class=\"line\">rails g controller blogs index</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>rails s</code> 启动项目，可以访问 <code>/blogs/index</code> 页面看到 <code>Rails</code> 生成的页面。</p>\n<p>接下来我们需要添加 <code>react-rails</code> 扩展：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># add to Gemfile.lock</span></span><br><span class=\"line\">gem <span class=\"string\">&#x27;react-rails&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>并执行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bundle install</span><br><span class=\"line\">rails g react:install</span><br></pre></td></tr></table></figure>\n\n<p>此时打开 <code>app/javascript</code> 目录，可以查看到项目目录下多了 <code>components</code> 目录，以及 <code>packs</code> 目录里增加了对应的入口文件。</p>\n<p>接下来，我们会把前面生成的 <code>/blogs/index</code> 作为入口页，渲染一个 <code>SPA</code> 标准单页应用。</p>\n<p>为了实现一个可用的 <code>SPA</code> 应用，我们可能有一些需要用到的库：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add react-router-dom</span><br></pre></td></tr></table></figure>\n\n<p>为了引入 <code>JavaScript</code> 渲染脚本，我们需要在页面里进行一些配置，打开 <code>app/views/layouts/application.html.erb</code> 并在 <code>&lt;head&gt;&lt;/head&gt;</code> 标签中添加：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%= javascript_pack_tag &#x27;application&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>它相当于现代前端在空白的 <code>index.html</code> 页面上添加 <code>&lt;script src=&#39;./app.js&#39;&gt;&lt;/script&gt;</code> 。</p>\n<p>接下来我们编写一个 <code>React</code> 应用，在 <code>app/javascript/components</code> 目录下创建前端工程目录，如果你很熟练 <code>React</code> 则不必刻意与我的结构一样，但起码你应该能够很快的找到它：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- app</span><br><span class=\"line\">    - javascript</span><br><span class=\"line\">        - components</span><br><span class=\"line\">            - routes</span><br><span class=\"line\">            - app.jsx</span><br><span class=\"line\">        - pages</span><br><span class=\"line\">            - home</span><br><span class=\"line\">                - index.jsx</span><br><span class=\"line\">                - index.scss</span><br><span class=\"line\">          - about</span><br><span class=\"line\">              - index.jsx</span><br><span class=\"line\">              - index.scss</span><br></pre></td></tr></table></figure>\n\n<p>如果你不熟练 <code>React</code> 与 <code>react-router-dom</code> ，你可以点击文章顶部的链接翻阅它们的文档。</p>\n<p>以下是我编写的 <code>React</code> 应用的所有代码，它很简单：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># app/javascript/components/pages/home/index.<span class=\"property\">jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"># app/javascript/components/pages/home/about.<span class=\"property\">jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>About me<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"># app/javascript/components/routes/index.<span class=\"property\">jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">BrowserRouter</span>, <span class=\"title class_\">Switch</span>, <span class=\"title class_\">Link</span>, <span class=\"title class_\">Route</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-router-dom&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Home</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../pages/home&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">About</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../pages/about&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&#x27;/&#x27;</span>&gt;</span>home<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        \t\t<span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&#x27;/about&#x27;</span>&gt;</span>about<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&#x27;/&#x27;</span> <span class=\"attr\">exact</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&#x27;/about&#x27;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;About&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写完成以后，我们需要把根组件渲染在页面上，这一步有点类似于 <code>React.render(&lt;App /&gt;, rootEle)</code> 的操作。</p>\n<p>修改 <code>app/views/index.html.erb</code> ，添加 <code>React</code> 组件：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%= react_component <span class=\"string\">&#x27;routes&#x27;</span> %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>此处的参数 <code>routes</code> 会自动寻找 <code>app/javascript/components</code> 目录下的 <code>routes</code> 组件，其规则与 <code>JavaScript</code> 相同，它可以使 <code>routes/index.jsx</code> 或者 <code>routes.jsx</code> 。</p>\n<p>到这里我们已经在 <code>Rails</code> 中实现了一个基本的 <code>SPA</code> 应用了，刷新页面可以看到有两个链接，点击能够来回切换不同的页面。</p>\n<p>美中不足的是此时刷新浏览器可能会得到 <code>404</code> 错误，这是因为在 <code>react-router</code> 里定义的路由与 <code>Rails Router</code> 里定义的不相同，当刷新浏览器，首先会请求的是 <code>Rails</code> 服务器，因此我们可以在 <code>config/routes.rb</code> 里添加对应配置，不用太复杂，只要能使对应的请求进入到挂载了 <code>routes</code> 根组件的页面里，就可以渲染对应的页面。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rails.application.routes.draw <span class=\"keyword\">do</span></span><br><span class=\"line\">  root <span class=\"string\">&#x27;blogs#index&#x27;</span></span><br><span class=\"line\">  get <span class=\"string\">&#x27;*path&#x27;</span>, <span class=\"symbol\">to:</span> <span class=\"string\">&#x27;blogs#index&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-使用预渲染解决首屏白屏问题\"><a href=\"#2-使用预渲染解决首屏白屏问题\" class=\"headerlink\" title=\"2. 使用预渲染解决首屏白屏问题\"></a>2. 使用预渲染解决首屏白屏问题</h2><p>当页面越来越大，结构越来越复杂时，<code>SPA</code> 可能会遇到首屏白屏的问题。这是因为复杂页面结构导致 <code>JavaScript</code> 文件的体积越来越大，且渲染流程更复杂。</p>\n<p>我们可以使用服务端预渲染来解决首屏白屏的问题，这很简单：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%= react_component <span class=\"string\">&#x27;routes&#x27;</span>, &#123;&#125;, &#123; <span class=\"symbol\">prerender:</span> <span class=\"literal\">true</span> &#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>添加 <code>prerender</code> 参数可开启预渲染。接下来的每一次用户请求，<code>react-rails</code> 都会直接将 <code>React</code> 组件预先渲染成 <code>HTML</code> 文本，这样可以节省大量的客户端渲染时间。</p>\n<p>到这里为止，我们在传统的 <code>Rails MVC</code> 架构上，增加了在页面里使用 <code>React</code> 的技巧，它可以使我们更灵活的构建页面， <code>React</code> 不是什么高深莫测的东西，只是帮助你构建 <code>HTML</code> 的工具，其它方面的 <code>Rails</code> 没有发生任何变化。</p>\n<p>因而你很容易发现，我们依然在使用 <code>Rails Router</code> 进行页面的管理。</p>\n<p>在这样一种方案下，预渲染可以很有效的解决白屏问题。</p>\n<p>为了更快的进行服务端预渲染，<code>CRuby/MRI Ruby</code> 用户可以添加 <code>mini_racer</code> 以获得更好的渲染效率：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Gemfile.lock</span></span><br><span class=\"line\">gem <span class=\"string\">&#x27;mini_racer&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>安装后重新启动服务，观察日志可以发现 <code>Controller</code> 层的耗时明显得到了优化。</p>\n<p>需要注意一点，由于页面在被服务端被渲染，因而渲染脚本 <code>application.js</code> 不需要在页面渲染前加载了，我们可以将其位置进行调整：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>MyBlog<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    &lt;%= csrf_meta_tags %&gt;</span><br><span class=\"line\">    &lt;%= csp_meta_tag %&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;%= stylesheet_link_tag    &#x27;application&#x27;, media: &#x27;all&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br><span class=\"line\">    &lt;%= javascript_include_tag &#x27;application&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    &lt;%= yield %&gt;</span><br><span class=\"line\">    &lt;%= javascript_pack_tag &#x27;application&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>以防止脚本阻塞页面的加载。</p>\n<p>最后，由于渲染过程调整到了服务端，需要注意几点：</p>\n<ul>\n<li>在服务端无法识别 <code>window</code>，<code>document</code> 等对象，因此需要在指定的生命周期（如 <code>componentDidMount</code>）里使用 <code>DOM/BOM</code> 。部分直接操作 <code>DOM</code> 的库如部分 <code>JQuery</code> 的插件直接引入 <code>React</code> 会导致异常，目前只能在入口页（<code>layout.html.erb</code>）上引入。</li>\n<li><del>在服务端无法正常处理 <code>CSS</code> 样式，不要在 <code>React</code> 组件里直接引入 <code>CSS</code> 文件</del>。</li>\n<li>由于 <code>style-loader</code> 会在样式导入时自动使用 <code>DOM</code> 操作进行样式注入，参考上一条，在服务端渲染场景下，<code>style-loader</code> 将无法正常工作。</li>\n</ul>\n<p><code>React</code> 合成事件的绑定与 <code>Turbolinks</code> 换页的机制之间存在某种矛盾关系，在页面里使用 <code>Turbolinks</code> 将需要更加小心。</p>\n<p>你可能需要在 <code>React</code> 组件卸载的时候注销掉对应的事件，不过幸好这也是 <code>React</code> 开发中常涉及到的习惯，因而无需花费过多的心智。</p>\n<p>另一种可能是你希望在页面里使用 <code>react-router</code>，则此时仅仅开启 <code>prerender: true</code> 就不满足我们的需求了。</p>\n<h2 id=\"3-基于React-Rails的服务端渲染方案\"><a href=\"#3-基于React-Rails的服务端渲染方案\" class=\"headerlink\" title=\"3. 基于React-Rails的服务端渲染方案\"></a>3. 基于React-Rails的服务端渲染方案</h2><p>当在应用中使用 <code>react-router</code> 时，我们需要调整应用架构。</p>\n<p>主要问题在于 <code>BrowserRouter</code> 不能很好的处理服务端渲染的场景，这一点在 <code>react-router</code> 文档中也有提到。通常当你在一个使用了 <code>BrowserRouter</code> 的组件上开启 <code>prerender: true</code>，不出意外的话你会得到一个错误。</p>\n<p>由于整个应用依然是 <code>SPA</code> ，且我们开启服务端渲染的目的也只是解决首屏问题，因而首先要明确一点：<strong>初次打开页面时并不需要渲染整个应用</strong>。</p>\n<p>我们将对 <code>app/javascript/components/routes/index.jsx</code> 进行调整： </p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">BrowserRouter</span>, <span class=\"title class_\">StaticRouter</span>, <span class=\"title class_\">Switch</span>, <span class=\"title class_\">Link</span>, <span class=\"title class_\">Route</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-router-dom&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Home</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../pages/home&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">About</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../pages/about&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">StaticRouter</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.path&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&#x27;/&#x27;</span>&gt;</span>home<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&#x27;/about&#x27;</span>&gt;</span>about<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&#x27;/&#x27;</span> <span class=\"attr\">exact</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&#x27;/about&#x27;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;About&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">StaticRouter</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>此处我们把 <code>BrowserRouter</code> 替换为 <code>StaticRouter</code> ，它的作用是匹配渲染 <code>Router</code> 里的某个路由，它需要一个参数来确认需要渲染的是那一条路由，因此我们需要传递一个 <code>location</code> 给它。</p>\n<p><code>location</code> 并不是一定要从 <code>props</code> 中获取，但这样做我们只需要在入口页上添加一个属性既可，相对来说更加的动态和方便：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 位于app/views/blogs/index.html.erb的入口页</span><br><span class=\"line\">&lt;%= react_component &#x27;routes&#x27;, &#123;path: request.path&#125;, &#123;prerender: true&#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>此时在浏览器里输入对应的路径可以进入到期望得到的 <code>React</code> 页面。</p>\n<p>由于 <code>react-rails</code> 预渲染实际使用 <code>ReactDOMServer.renderToString()</code> 方法，这是一个 <code>React</code> 官方提供的用于服务端渲染的库。其特点是可以在 将 <code>React</code> 组件解析成静态的 <code>HTML</code> 内容。该方法是无法将 <code>React</code> 中使用的合成事件转化成静态内容的。</p>\n<p>我们调整应用，在任意位置添加一个点击事件，可以发现我们的应用并没有出现上述描述的情况，点击事件是可用的。这是因为  <code>react-rails</code> 的 <code>prerender</code> 其实是按照 <strong>同构渲染</strong> 的思路进行设计的。</p>\n<p>现代前端 <strong>同构渲染</strong> 解决方案的核心，是利用 <code>React</code> 服务端渲染 <code>API</code> 完成首屏渲染，然后再次请求服务器拉取客户端渲染代码进行二次渲染。这样做既可以快速渲染出首屏，也能在后续保证用户的体验。</p>\n<p>来看一下它在 <code>Rails</code> 里的具体工作流程：</p>\n<ol>\n<li>用户访问任意页面至 <code>Rails</code> 服务器，<code>Rails Router</code> 进行处理与分发到对应 <code>Controller#action</code> 最终找到目标模板页准备渲染页面。</li>\n<li>在目标模板页中确认需要渲染的页面并执行服务器渲染。</li>\n<li>浏览器呈现服务器返回的静态页面。</li>\n<li>浏览器再次请求服务器获取渲染脚本 <code>application.js</code> 。</li>\n<li>浏览器下载 <code>application.js</code> 并自动执行完成客户端二次渲染。</li>\n</ol>\n<p>整个流程看起来复杂了不少，不过前面提到，<code>react-rails</code> 已经为我们做好了基本工作。</p>\n<p>回到应用里，点击 <code>Router</code> 会发现页面跳转无法正常工作，这是因为 <code>StaticRouter</code> 并不合适用在客户端上，二次渲染我们要使用之前的 <code>BrowserRouter</code> ，我们只需要对 <code>app/javascript/components/routes/index.jsx</code> 文件进行一些改造：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">BrowserRouter</span>, <span class=\"title class_\">StaticRouter</span>, <span class=\"title class_\">Switch</span>, <span class=\"title class_\">Link</span>, <span class=\"title class_\">Route</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-router-dom&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Home</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../pages/home&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">About</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../pages/about&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Router</span> = props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">window</span> === <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">StaticRouter</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.location&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;props.children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">StaticRouter</span>&gt;</span></span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;props.children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.path&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&#x27;/&#x27;</span>&gt;</span>home<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&#x27;/about&#x27;</span>&gt;</span>about<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&#x27;/&#x27;</span> <span class=\"attr\">exact</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&#x27;/about&#x27;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;About&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在新的代码里，我们添加了一个自定义的 <code>Router</code> 组件，该组件根据渲染场景动态的使用不同的 <code>React-Router API</code> ，可以注意我们是如何判断当前渲染场景的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typof <span class=\"variable language_\">window</span> === <span class=\"string\">&quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>正如前面所说，服务端没有 <code>window</code> 对象。</p>\n<p>此时再刷新浏览器，可以发现路由的跳转已经正常工作。</p>\n<p>到这里为止，我们已经实现了服务端渲染的大部分内容。</p>\n<p>不过还没结束，我们还有最后一个问题需要解决：<strong>首屏渲染时的数据从哪儿获取？</strong></p>\n<p>暂时注释掉 <code>app/views/layouts/javascript.html.erb</code> 里，<code>body</code> 标签里的二次渲染脚本引入代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>MyBlog<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    &lt;%= csrf_meta_tags %&gt;</span><br><span class=\"line\">    &lt;%= csp_meta_tag %&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;%= stylesheet_link_tag    &#x27;application&#x27;, media: &#x27;all&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br><span class=\"line\">    &lt;%= javascript_include_tag &#x27;application&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    &lt;%= yield %&gt;</span><br><span class=\"line\">    &lt;%#= javascript_pack_tag &#x27;application&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后刷新页面，<code>右击 -&gt; 查看源代码</code> 可以看到虽然页面预渲染了，但实际渲染的是空的模板页，如果你的组件设计是在 <code>componentDidMount</code> 生命周期里进行异步请求拉取数据，则首屏渲染的时候不会拉取任何数据。</p>\n<p>对于一部分应用来说，这样也许无伤大雅，但对于另一部分应用，这个设计可能是一个缺陷。</p>\n<blockquote>\n<p>举个实际的例子，当你正在用 <code>React</code> 开发自己的博客系统，为了提高自己的知名度，你希望你的每一篇文章都能在搜索引擎里被搜索到，这将要求你的博客系统能够对动态数据进行基本的 <code>SEO</code> 。</p>\n</blockquote>\n<p>解决该问题的方法并不难，我们只需要在预渲染期间把数据注入到组件里既可。且由于 <code>react-rails</code> 本身是定义在 <code>Ruby</code> 环境里的，它对于将数据注入到组件里有着天然的优势。</p>\n<p>就像 <code>path</code> 一样，我们可以把数据注入到组件里：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%= react_component &#x27;routes&#x27;, &#123;path: request.path, blogs: @blogs&#125;, &#123;prerender: true&#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>此时会把数据注入到 <code>routes</code> 组件中，但我们需要使用的组件实际是 <code>pages</code> 路径下的页面，可以使用 <code>StaticRouter</code> 提供的 <code>context</code> 来实现：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">BrowserRouter</span>, <span class=\"title class_\">StaticRouter</span>, <span class=\"title class_\">Switch</span>, <span class=\"title class_\">Link</span>, <span class=\"title class_\">Route</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-router-dom&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Router</span> = props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">window</span> === <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">StaticRouter</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.location&#125;</span> <span class=\"attr\">context</span>=<span class=\"string\">&#123;props.context&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;props.children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">StaticRouter</span>&gt;</span></span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.path&#125;</span> <span class=\"attr\">context</span>=<span class=\"string\">&#123;&#123;blogs:</span> <span class=\"attr\">props.blogs</span>&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            ...</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码将入口页传入的 <code>blogs Props</code> 一层一层的最终传递给了 <code>StaticeRouter</code> 的 <code>context</code> 属性，然后我们可以在组件里访问：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(props.<span class=\"property\">staticContext</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        ......</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>通过 <code>props.staticContext</code> 既可获取到对应的数据。</p>\n<blockquote>\n<p>解开入口页注释掉的渲染脚本外部链接，然后刷新页面，会发现该语句打印了两次，第一次是我们注入的数据，第二次是undefined。这也是服务端渲染与客户端渲染的差异之一。</p>\n<p>但请注意 <strong>不要通过 <code>props.staticContext</code> 来判断当前的渲染环境</strong>，因为我们无法保证该变量里到底存储了什么，如果注入的数据本身就是 <code>false</code>，<code>null</code>之类的数据，那么 <code>if (props.staticContext) &#123;&#125;</code> 也许会得到错误的判断结果。</p>\n<p>推荐的做法依然是 <code>if (typeof window !== &quot;undefined&quot;) &#123;&#125;</code> 。</p>\n</blockquote>\n<p>而后我们可以直接使用该值来作为服务端渲染时的初始状态：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">extends</span> <span class=\"title class_\">React</span>.<span class=\"property\">Component</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(props);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">window</span> !== <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">                <span class=\"attr\">blogs</span>: []</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">                <span class=\"attr\">blogs</span>: props.<span class=\"property\">staticContext</span>.<span class=\"property\">blogs</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"title function_\">componentDidMount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        axios.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;...&#x27;</span>).<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123;</span><br><span class=\"line\">                <span class=\"attr\">blogs</span>: res.<span class=\"property\">data</span>.<span class=\"property\">blogs</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            ......</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们在初始化状态时根据渲染环境的区别分别给了不同的初始值，当服务端渲染时，直接使用注入的数据作为初始状态进行预渲染。当客户端渲染时，组件挂载后从服务器拉取数据。</p>\n<p>不难发现一个问题，并不是所有的入口页都需要注入数据，也不能保证所有的页面注入的数据结构都是 <code>&#123; blogs: [] &#125;</code> ，因此最后的最后，我们需要统一服务端渲染时数据注入的格式，因为我们既不希望重复的入口页写多份，也不喜欢把数据弄的乱七八糟：</p>\n<p><strong>入口页</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%= react_component &#x27;routes&#x27;, &#123;path: request.path, context: @data&#125;, &#123;prerender: true&#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>Route</code> 组件</strong></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">BrowserRouter</span>, <span class=\"title class_\">StaticRouter</span>, <span class=\"title class_\">Switch</span>, <span class=\"title class_\">Link</span>, <span class=\"title class_\">Route</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-router-dom&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Router</span> = props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">window</span> === <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">StaticRouter</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.location&#125;</span> <span class=\"attr\">context</span>=<span class=\"string\">&#123;props.context&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;props.children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">StaticRouter</span>&gt;</span></span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;props.children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.path&#125;</span> <span class=\"attr\">context</span>=<span class=\"string\">&#123;props.context&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            ......</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在对参数进行调整后，我们可以在 <code>Controller</code> 层动态的构造需要注入的数据，而不用关心渲染的模板页细节。</p>\n<blockquote>\n<p>事实由于组件是相同的，预渲染注入的数据与二次渲染的数据结构是一致的，因而我们可以利用 <code>Rails</code> 的自定义渲染特性来共用 <code>Controller</code> 层实现代码的精简。</p>\n</blockquote>\n<p>到这里，我们就实现了一个完整的服务端渲染<code>React</code>应用。它能够快速的响应用户请求渲染首屏，同时也能支持 <code>SEO</code> ，并且在页面完成渲染后，它还保留了 <code>SPA</code> 良好的用户体验。让我们回过头来看看我们做了哪些事情：</p>\n<ol>\n<li>开启服务端预渲染选项，在这个过程里我们需要替换更高性能的 <code>NodeJS RunTime</code> ，同时还要调整脚本加载的位置，使之不要阻塞首屏渲染。</li>\n<li>根据渲染环境使用不同的 <code>Router</code> ，其中服务端渲染需要传递 <code>path</code> 属性给 <code>StaticRouter</code> 。</li>\n<li>预渲染的数据注入，在 <code>Controller</code> 层动态构建注入数据，通过 <code>context</code> 方式传入具体页面用作初始化。</li>\n</ol>\n<h2 id=\"4-最后说两句\"><a href=\"#4-最后说两句\" class=\"headerlink\" title=\"4. 最后说两句\"></a>4. 最后说两句</h2><p>同构渲染是目前最流行的前端解决方案之一，但在实践的过程中我们不难发现任然有几个问题需要解决：</p>\n<ol>\n<li>同构渲染的实践并不轻松，我们需要围绕渲染流程做许多准备工作。</li>\n<li>当一部分组件需要在服务端渲染时，开发人员的职责会变得更混乱——注入数据的部分到底应该由服务端开发人员编写？还是前端开发人员编写？</li>\n</ol>\n<p>对此我的看法是，我们应该更加理性的对待不同的需求，毕竟不是所有的 <code>SPA</code> 都需要服务端渲染的。</p>\n<blockquote>\n<p>如果觉得本文对您有帮助，请给我一个赞~<br>如果您对本文有不同的理解，可以在评论区留言告诉我~</p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"在Rails上搭建React服务端渲染瞎谈-md\"><a href=\"#在Rails上搭建React服务端渲染瞎谈-md\" class=\"headerlink\" title=\"在Rails上搭建React服务端渲染瞎谈.md\"></a>在Rails上搭建React服务端渲染瞎谈.md</h1><p>本文主要提供了一种在 <code>Rails</code> 里 <code>React</code> 搭建服务端渲染SPA的思路，主要涉及的技术栈如下：</p>\n<p><strong>ruby</strong>:</p>\n<ul>\n<li><a href=\"https://ruby-china.github.io/rails-guides/\">Rails 5.x </a></li>\n<li><a href=\"https://github.com/rails/webpacker\">webpacker</a></li>\n<li><a href=\"https://github.com/reactjs/react-rails\">react-rails</a></li>\n</ul>\n<p><strong>JavaScript</strong></p>\n<ul>\n<li><a href=\"https://react.docschina.org/docs/getting-started.html\">React</a></li>\n<li><a href=\"https://reactrouter.com/web\">React-Router</a></li>\n<li><a href=\"https://github.com/reduxjs/react-redux\">React-Redux</a></li>\n</ul>\n<h2 id=\"1-在-Rails-中搭建基本的SPA单页应用\"><a href=\"#1-在-Rails-中搭建基本的SPA单页应用\" class=\"headerlink\" title=\"1. 在 Rails 中搭建基本的SPA单页应用\"></a>1. 在 Rails 中搭建基本的SPA单页应用</h2><p>我们将基于 <code>React</code> 搭建一个 <code>DEMO</code> ，它包含了两个页面 <code>home</code> 和 <code>about</code>，可以来回切换 。</p>\n<p>撇开 <code>React</code> 不看，我们首先需要构建一个基础的 <code>MVC</code> 标准结构，在 <code>Rails</code> 里使用相关脚手架可以很快实现：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rails _5.2.4_ new my_blog --webpack=react</span><br><span class=\"line\"></span><br><span class=\"line\">rails g controller blogs index</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>rails s</code> 启动项目，可以访问 <code>/blogs/index</code> 页面看到 <code>Rails</code> 生成的页面。</p>\n<p>接下来我们需要添加 <code>react-rails</code> 扩展：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># add to Gemfile.lock</span></span><br><span class=\"line\">gem <span class=\"string\">&#x27;react-rails&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>并执行安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bundle install</span><br><span class=\"line\">rails g react:install</span><br></pre></td></tr></table></figure>\n\n<p>此时打开 <code>app/javascript</code> 目录，可以查看到项目目录下多了 <code>components</code> 目录，以及 <code>packs</code> 目录里增加了对应的入口文件。</p>\n<p>接下来，我们会把前面生成的 <code>/blogs/index</code> 作为入口页，渲染一个 <code>SPA</code> 标准单页应用。</p>\n<p>为了实现一个可用的 <code>SPA</code> 应用，我们可能有一些需要用到的库：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add react-router-dom</span><br></pre></td></tr></table></figure>\n\n<p>为了引入 <code>JavaScript</code> 渲染脚本，我们需要在页面里进行一些配置，打开 <code>app/views/layouts/application.html.erb</code> 并在 <code>&lt;head&gt;&lt;/head&gt;</code> 标签中添加：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%= javascript_pack_tag &#x27;application&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>它相当于现代前端在空白的 <code>index.html</code> 页面上添加 <code>&lt;script src=&#39;./app.js&#39;&gt;&lt;/script&gt;</code> 。</p>\n<p>接下来我们编写一个 <code>React</code> 应用，在 <code>app/javascript/components</code> 目录下创建前端工程目录，如果你很熟练 <code>React</code> 则不必刻意与我的结构一样，但起码你应该能够很快的找到它：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- app</span><br><span class=\"line\">    - javascript</span><br><span class=\"line\">        - components</span><br><span class=\"line\">            - routes</span><br><span class=\"line\">            - app.jsx</span><br><span class=\"line\">        - pages</span><br><span class=\"line\">            - home</span><br><span class=\"line\">                - index.jsx</span><br><span class=\"line\">                - index.scss</span><br><span class=\"line\">          - about</span><br><span class=\"line\">              - index.jsx</span><br><span class=\"line\">              - index.scss</span><br></pre></td></tr></table></figure>\n\n<p>如果你不熟练 <code>React</code> 与 <code>react-router-dom</code> ，你可以点击文章顶部的链接翻阅它们的文档。</p>\n<p>以下是我编写的 <code>React</code> 应用的所有代码，它很简单：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># app/javascript/components/pages/home/index.<span class=\"property\">jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"># app/javascript/components/pages/home/about.<span class=\"property\">jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>About me<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"># app/javascript/components/routes/index.<span class=\"property\">jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">BrowserRouter</span>, <span class=\"title class_\">Switch</span>, <span class=\"title class_\">Link</span>, <span class=\"title class_\">Route</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-router-dom&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Home</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../pages/home&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">About</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../pages/about&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&#x27;/&#x27;</span>&gt;</span>home<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        \t\t<span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&#x27;/about&#x27;</span>&gt;</span>about<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&#x27;/&#x27;</span> <span class=\"attr\">exact</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&#x27;/about&#x27;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;About&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写完成以后，我们需要把根组件渲染在页面上，这一步有点类似于 <code>React.render(&lt;App /&gt;, rootEle)</code> 的操作。</p>\n<p>修改 <code>app/views/index.html.erb</code> ，添加 <code>React</code> 组件：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%= react_component <span class=\"string\">&#x27;routes&#x27;</span> %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>此处的参数 <code>routes</code> 会自动寻找 <code>app/javascript/components</code> 目录下的 <code>routes</code> 组件，其规则与 <code>JavaScript</code> 相同，它可以使 <code>routes/index.jsx</code> 或者 <code>routes.jsx</code> 。</p>\n<p>到这里我们已经在 <code>Rails</code> 中实现了一个基本的 <code>SPA</code> 应用了，刷新页面可以看到有两个链接，点击能够来回切换不同的页面。</p>\n<p>美中不足的是此时刷新浏览器可能会得到 <code>404</code> 错误，这是因为在 <code>react-router</code> 里定义的路由与 <code>Rails Router</code> 里定义的不相同，当刷新浏览器，首先会请求的是 <code>Rails</code> 服务器，因此我们可以在 <code>config/routes.rb</code> 里添加对应配置，不用太复杂，只要能使对应的请求进入到挂载了 <code>routes</code> 根组件的页面里，就可以渲染对应的页面。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rails.application.routes.draw <span class=\"keyword\">do</span></span><br><span class=\"line\">  root <span class=\"string\">&#x27;blogs#index&#x27;</span></span><br><span class=\"line\">  get <span class=\"string\">&#x27;*path&#x27;</span>, <span class=\"symbol\">to:</span> <span class=\"string\">&#x27;blogs#index&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-使用预渲染解决首屏白屏问题\"><a href=\"#2-使用预渲染解决首屏白屏问题\" class=\"headerlink\" title=\"2. 使用预渲染解决首屏白屏问题\"></a>2. 使用预渲染解决首屏白屏问题</h2><p>当页面越来越大，结构越来越复杂时，<code>SPA</code> 可能会遇到首屏白屏的问题。这是因为复杂页面结构导致 <code>JavaScript</code> 文件的体积越来越大，且渲染流程更复杂。</p>\n<p>我们可以使用服务端预渲染来解决首屏白屏的问题，这很简单：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%= react_component <span class=\"string\">&#x27;routes&#x27;</span>, &#123;&#125;, &#123; <span class=\"symbol\">prerender:</span> <span class=\"literal\">true</span> &#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>添加 <code>prerender</code> 参数可开启预渲染。接下来的每一次用户请求，<code>react-rails</code> 都会直接将 <code>React</code> 组件预先渲染成 <code>HTML</code> 文本，这样可以节省大量的客户端渲染时间。</p>\n<p>到这里为止，我们在传统的 <code>Rails MVC</code> 架构上，增加了在页面里使用 <code>React</code> 的技巧，它可以使我们更灵活的构建页面， <code>React</code> 不是什么高深莫测的东西，只是帮助你构建 <code>HTML</code> 的工具，其它方面的 <code>Rails</code> 没有发生任何变化。</p>\n<p>因而你很容易发现，我们依然在使用 <code>Rails Router</code> 进行页面的管理。</p>\n<p>在这样一种方案下，预渲染可以很有效的解决白屏问题。</p>\n<p>为了更快的进行服务端预渲染，<code>CRuby/MRI Ruby</code> 用户可以添加 <code>mini_racer</code> 以获得更好的渲染效率：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Gemfile.lock</span></span><br><span class=\"line\">gem <span class=\"string\">&#x27;mini_racer&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>安装后重新启动服务，观察日志可以发现 <code>Controller</code> 层的耗时明显得到了优化。</p>\n<p>需要注意一点，由于页面在被服务端被渲染，因而渲染脚本 <code>application.js</code> 不需要在页面渲染前加载了，我们可以将其位置进行调整：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>MyBlog<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    &lt;%= csrf_meta_tags %&gt;</span><br><span class=\"line\">    &lt;%= csp_meta_tag %&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;%= stylesheet_link_tag    &#x27;application&#x27;, media: &#x27;all&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br><span class=\"line\">    &lt;%= javascript_include_tag &#x27;application&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    &lt;%= yield %&gt;</span><br><span class=\"line\">    &lt;%= javascript_pack_tag &#x27;application&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>以防止脚本阻塞页面的加载。</p>\n<p>最后，由于渲染过程调整到了服务端，需要注意几点：</p>\n<ul>\n<li>在服务端无法识别 <code>window</code>，<code>document</code> 等对象，因此需要在指定的生命周期（如 <code>componentDidMount</code>）里使用 <code>DOM/BOM</code> 。部分直接操作 <code>DOM</code> 的库如部分 <code>JQuery</code> 的插件直接引入 <code>React</code> 会导致异常，目前只能在入口页（<code>layout.html.erb</code>）上引入。</li>\n<li><del>在服务端无法正常处理 <code>CSS</code> 样式，不要在 <code>React</code> 组件里直接引入 <code>CSS</code> 文件</del>。</li>\n<li>由于 <code>style-loader</code> 会在样式导入时自动使用 <code>DOM</code> 操作进行样式注入，参考上一条，在服务端渲染场景下，<code>style-loader</code> 将无法正常工作。</li>\n</ul>\n<p><code>React</code> 合成事件的绑定与 <code>Turbolinks</code> 换页的机制之间存在某种矛盾关系，在页面里使用 <code>Turbolinks</code> 将需要更加小心。</p>\n<p>你可能需要在 <code>React</code> 组件卸载的时候注销掉对应的事件，不过幸好这也是 <code>React</code> 开发中常涉及到的习惯，因而无需花费过多的心智。</p>\n<p>另一种可能是你希望在页面里使用 <code>react-router</code>，则此时仅仅开启 <code>prerender: true</code> 就不满足我们的需求了。</p>\n<h2 id=\"3-基于React-Rails的服务端渲染方案\"><a href=\"#3-基于React-Rails的服务端渲染方案\" class=\"headerlink\" title=\"3. 基于React-Rails的服务端渲染方案\"></a>3. 基于React-Rails的服务端渲染方案</h2><p>当在应用中使用 <code>react-router</code> 时，我们需要调整应用架构。</p>\n<p>主要问题在于 <code>BrowserRouter</code> 不能很好的处理服务端渲染的场景，这一点在 <code>react-router</code> 文档中也有提到。通常当你在一个使用了 <code>BrowserRouter</code> 的组件上开启 <code>prerender: true</code>，不出意外的话你会得到一个错误。</p>\n<p>由于整个应用依然是 <code>SPA</code> ，且我们开启服务端渲染的目的也只是解决首屏问题，因而首先要明确一点：<strong>初次打开页面时并不需要渲染整个应用</strong>。</p>\n<p>我们将对 <code>app/javascript/components/routes/index.jsx</code> 进行调整： </p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">BrowserRouter</span>, <span class=\"title class_\">StaticRouter</span>, <span class=\"title class_\">Switch</span>, <span class=\"title class_\">Link</span>, <span class=\"title class_\">Route</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-router-dom&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Home</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../pages/home&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">About</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../pages/about&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">StaticRouter</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.path&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&#x27;/&#x27;</span>&gt;</span>home<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&#x27;/about&#x27;</span>&gt;</span>about<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&#x27;/&#x27;</span> <span class=\"attr\">exact</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&#x27;/about&#x27;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;About&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">StaticRouter</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>此处我们把 <code>BrowserRouter</code> 替换为 <code>StaticRouter</code> ，它的作用是匹配渲染 <code>Router</code> 里的某个路由，它需要一个参数来确认需要渲染的是那一条路由，因此我们需要传递一个 <code>location</code> 给它。</p>\n<p><code>location</code> 并不是一定要从 <code>props</code> 中获取，但这样做我们只需要在入口页上添加一个属性既可，相对来说更加的动态和方便：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 位于app/views/blogs/index.html.erb的入口页</span><br><span class=\"line\">&lt;%= react_component &#x27;routes&#x27;, &#123;path: request.path&#125;, &#123;prerender: true&#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>此时在浏览器里输入对应的路径可以进入到期望得到的 <code>React</code> 页面。</p>\n<p>由于 <code>react-rails</code> 预渲染实际使用 <code>ReactDOMServer.renderToString()</code> 方法，这是一个 <code>React</code> 官方提供的用于服务端渲染的库。其特点是可以在 将 <code>React</code> 组件解析成静态的 <code>HTML</code> 内容。该方法是无法将 <code>React</code> 中使用的合成事件转化成静态内容的。</p>\n<p>我们调整应用，在任意位置添加一个点击事件，可以发现我们的应用并没有出现上述描述的情况，点击事件是可用的。这是因为  <code>react-rails</code> 的 <code>prerender</code> 其实是按照 <strong>同构渲染</strong> 的思路进行设计的。</p>\n<p>现代前端 <strong>同构渲染</strong> 解决方案的核心，是利用 <code>React</code> 服务端渲染 <code>API</code> 完成首屏渲染，然后再次请求服务器拉取客户端渲染代码进行二次渲染。这样做既可以快速渲染出首屏，也能在后续保证用户的体验。</p>\n<p>来看一下它在 <code>Rails</code> 里的具体工作流程：</p>\n<ol>\n<li>用户访问任意页面至 <code>Rails</code> 服务器，<code>Rails Router</code> 进行处理与分发到对应 <code>Controller#action</code> 最终找到目标模板页准备渲染页面。</li>\n<li>在目标模板页中确认需要渲染的页面并执行服务器渲染。</li>\n<li>浏览器呈现服务器返回的静态页面。</li>\n<li>浏览器再次请求服务器获取渲染脚本 <code>application.js</code> 。</li>\n<li>浏览器下载 <code>application.js</code> 并自动执行完成客户端二次渲染。</li>\n</ol>\n<p>整个流程看起来复杂了不少，不过前面提到，<code>react-rails</code> 已经为我们做好了基本工作。</p>\n<p>回到应用里，点击 <code>Router</code> 会发现页面跳转无法正常工作，这是因为 <code>StaticRouter</code> 并不合适用在客户端上，二次渲染我们要使用之前的 <code>BrowserRouter</code> ，我们只需要对 <code>app/javascript/components/routes/index.jsx</code> 文件进行一些改造：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">BrowserRouter</span>, <span class=\"title class_\">StaticRouter</span>, <span class=\"title class_\">Switch</span>, <span class=\"title class_\">Link</span>, <span class=\"title class_\">Route</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-router-dom&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Home</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../pages/home&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">About</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../pages/about&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Router</span> = props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">window</span> === <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">StaticRouter</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.location&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;props.children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">StaticRouter</span>&gt;</span></span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;props.children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.path&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&#x27;/&#x27;</span>&gt;</span>home<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">br</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Link</span> <span class=\"attr\">to</span>=<span class=\"string\">&#x27;/about&#x27;</span>&gt;</span>about<span class=\"tag\">&lt;/<span class=\"name\">Link</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&#x27;/&#x27;</span> <span class=\"attr\">exact</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">                <span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">path</span>=<span class=\"string\">&#x27;/about&#x27;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;About&#125;/</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            <span class=\"tag\">&lt;/<span class=\"name\">Switch</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在新的代码里，我们添加了一个自定义的 <code>Router</code> 组件，该组件根据渲染场景动态的使用不同的 <code>React-Router API</code> ，可以注意我们是如何判断当前渲染场景的</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typof <span class=\"variable language_\">window</span> === <span class=\"string\">&quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>正如前面所说，服务端没有 <code>window</code> 对象。</p>\n<p>此时再刷新浏览器，可以发现路由的跳转已经正常工作。</p>\n<p>到这里为止，我们已经实现了服务端渲染的大部分内容。</p>\n<p>不过还没结束，我们还有最后一个问题需要解决：<strong>首屏渲染时的数据从哪儿获取？</strong></p>\n<p>暂时注释掉 <code>app/views/layouts/javascript.html.erb</code> 里，<code>body</code> 标签里的二次渲染脚本引入代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>MyBlog<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    &lt;%= csrf_meta_tags %&gt;</span><br><span class=\"line\">    &lt;%= csp_meta_tag %&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;%= stylesheet_link_tag    &#x27;application&#x27;, media: &#x27;all&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br><span class=\"line\">    &lt;%= javascript_include_tag &#x27;application&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    &lt;%= yield %&gt;</span><br><span class=\"line\">    &lt;%#= javascript_pack_tag &#x27;application&#x27;, &#x27;data-turbolinks-track&#x27;: &#x27;reload&#x27; %&gt;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后刷新页面，<code>右击 -&gt; 查看源代码</code> 可以看到虽然页面预渲染了，但实际渲染的是空的模板页，如果你的组件设计是在 <code>componentDidMount</code> 生命周期里进行异步请求拉取数据，则首屏渲染的时候不会拉取任何数据。</p>\n<p>对于一部分应用来说，这样也许无伤大雅，但对于另一部分应用，这个设计可能是一个缺陷。</p>\n<blockquote>\n<p>举个实际的例子，当你正在用 <code>React</code> 开发自己的博客系统，为了提高自己的知名度，你希望你的每一篇文章都能在搜索引擎里被搜索到，这将要求你的博客系统能够对动态数据进行基本的 <code>SEO</code> 。</p>\n</blockquote>\n<p>解决该问题的方法并不难，我们只需要在预渲染期间把数据注入到组件里既可。且由于 <code>react-rails</code> 本身是定义在 <code>Ruby</code> 环境里的，它对于将数据注入到组件里有着天然的优势。</p>\n<p>就像 <code>path</code> 一样，我们可以把数据注入到组件里：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%= react_component &#x27;routes&#x27;, &#123;path: request.path, blogs: @blogs&#125;, &#123;prerender: true&#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p>此时会把数据注入到 <code>routes</code> 组件中，但我们需要使用的组件实际是 <code>pages</code> 路径下的页面，可以使用 <code>StaticRouter</code> 提供的 <code>context</code> 来实现：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">BrowserRouter</span>, <span class=\"title class_\">StaticRouter</span>, <span class=\"title class_\">Switch</span>, <span class=\"title class_\">Link</span>, <span class=\"title class_\">Route</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-router-dom&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Router</span> = props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">window</span> === <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">StaticRouter</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.location&#125;</span> <span class=\"attr\">context</span>=<span class=\"string\">&#123;props.context&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;props.children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">StaticRouter</span>&gt;</span></span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.path&#125;</span> <span class=\"attr\">context</span>=<span class=\"string\">&#123;&#123;blogs:</span> <span class=\"attr\">props.blogs</span>&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            ...</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码将入口页传入的 <code>blogs Props</code> 一层一层的最终传递给了 <code>StaticeRouter</code> 的 <code>context</code> 属性，然后我们可以在组件里访问：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(props.<span class=\"property\">staticContext</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        ......</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>通过 <code>props.staticContext</code> 既可获取到对应的数据。</p>\n<blockquote>\n<p>解开入口页注释掉的渲染脚本外部链接，然后刷新页面，会发现该语句打印了两次，第一次是我们注入的数据，第二次是undefined。这也是服务端渲染与客户端渲染的差异之一。</p>\n<p>但请注意 <strong>不要通过 <code>props.staticContext</code> 来判断当前的渲染环境</strong>，因为我们无法保证该变量里到底存储了什么，如果注入的数据本身就是 <code>false</code>，<code>null</code>之类的数据，那么 <code>if (props.staticContext) &#123;&#125;</code> 也许会得到错误的判断结果。</p>\n<p>推荐的做法依然是 <code>if (typeof window !== &quot;undefined&quot;) &#123;&#125;</code> 。</p>\n</blockquote>\n<p>而后我们可以直接使用该值来作为服务端渲染时的初始状态：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">extends</span> <span class=\"title class_\">React</span>.<span class=\"property\">Component</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">super</span>(props);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">window</span> !== <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">                <span class=\"attr\">blogs</span>: []</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">                <span class=\"attr\">blogs</span>: props.<span class=\"property\">staticContext</span>.<span class=\"property\">blogs</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"title function_\">componentDidMount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        axios.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;...&#x27;</span>).<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">this</span>.<span class=\"title function_\">setState</span>(&#123;</span><br><span class=\"line\">                <span class=\"attr\">blogs</span>: res.<span class=\"property\">data</span>.<span class=\"property\">blogs</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            ......</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们在初始化状态时根据渲染环境的区别分别给了不同的初始值，当服务端渲染时，直接使用注入的数据作为初始状态进行预渲染。当客户端渲染时，组件挂载后从服务器拉取数据。</p>\n<p>不难发现一个问题，并不是所有的入口页都需要注入数据，也不能保证所有的页面注入的数据结构都是 <code>&#123; blogs: [] &#125;</code> ，因此最后的最后，我们需要统一服务端渲染时数据注入的格式，因为我们既不希望重复的入口页写多份，也不喜欢把数据弄的乱七八糟：</p>\n<p><strong>入口页</strong></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%= react_component &#x27;routes&#x27;, &#123;path: request.path, context: @data&#125;, &#123;prerender: true&#125; %&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>Route</code> 组件</strong></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"title class_\">BrowserRouter</span>, <span class=\"title class_\">StaticRouter</span>, <span class=\"title class_\">Switch</span>, <span class=\"title class_\">Link</span>, <span class=\"title class_\">Route</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-router-dom&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">Router</span> = props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"variable language_\">window</span> === <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">StaticRouter</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.location&#125;</span> <span class=\"attr\">context</span>=<span class=\"string\">&#123;props.context&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;props.children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">StaticRouter</span>&gt;</span></span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            &#123;props.children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">BrowserRouter</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> props =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Router</span> <span class=\"attr\">location</span>=<span class=\"string\">&#123;props.path&#125;</span> <span class=\"attr\">context</span>=<span class=\"string\">&#123;props.context&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">            ......</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;/<span class=\"name\">Router</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在对参数进行调整后，我们可以在 <code>Controller</code> 层动态的构造需要注入的数据，而不用关心渲染的模板页细节。</p>\n<blockquote>\n<p>事实由于组件是相同的，预渲染注入的数据与二次渲染的数据结构是一致的，因而我们可以利用 <code>Rails</code> 的自定义渲染特性来共用 <code>Controller</code> 层实现代码的精简。</p>\n</blockquote>\n<p>到这里，我们就实现了一个完整的服务端渲染<code>React</code>应用。它能够快速的响应用户请求渲染首屏，同时也能支持 <code>SEO</code> ，并且在页面完成渲染后，它还保留了 <code>SPA</code> 良好的用户体验。让我们回过头来看看我们做了哪些事情：</p>\n<ol>\n<li>开启服务端预渲染选项，在这个过程里我们需要替换更高性能的 <code>NodeJS RunTime</code> ，同时还要调整脚本加载的位置，使之不要阻塞首屏渲染。</li>\n<li>根据渲染环境使用不同的 <code>Router</code> ，其中服务端渲染需要传递 <code>path</code> 属性给 <code>StaticRouter</code> 。</li>\n<li>预渲染的数据注入，在 <code>Controller</code> 层动态构建注入数据，通过 <code>context</code> 方式传入具体页面用作初始化。</li>\n</ol>\n<h2 id=\"4-最后说两句\"><a href=\"#4-最后说两句\" class=\"headerlink\" title=\"4. 最后说两句\"></a>4. 最后说两句</h2><p>同构渲染是目前最流行的前端解决方案之一，但在实践的过程中我们不难发现任然有几个问题需要解决：</p>\n<ol>\n<li>同构渲染的实践并不轻松，我们需要围绕渲染流程做许多准备工作。</li>\n<li>当一部分组件需要在服务端渲染时，开发人员的职责会变得更混乱——注入数据的部分到底应该由服务端开发人员编写？还是前端开发人员编写？</li>\n</ol>\n<p>对此我的看法是，我们应该更加理性的对待不同的需求，毕竟不是所有的 <code>SPA</code> 都需要服务端渲染的。</p>\n<blockquote>\n<p>如果觉得本文对您有帮助，请给我一个赞~<br>如果您对本文有不同的理解，可以在评论区留言告诉我~</p>\n</blockquote>\n"},{"_content":"# 0. 写在前面\n其实公司项目早在去年就做完第一版的微信支付了，但是由于种种原因并没有上线，一直拖到了今年。\n\n让人 *疼 的一件事情是，虽然基础功能都已经实现了，代码也有了，但是考虑微信支付更新了V3版本，以及反正产品还没有正式上微信支付，公司最终决定直接接入V3版本的微信支付，之前的代码基本上没法儿再用了。\n\n另外 `Ruby` 这个没人疼没人爱的孩子又着实可怜的不行，V2版本的微信支付还可以参考使用社区姜老师(`@jasl`)的 [微信支付GEM](https://github.com/jasl/wx_pay)，V3版本干脆就没有可以参考的 `Ruby` 代码了。\n\n好就好在V3开始的微信支付相对之前的V2要简单许多，以及相关的文档也比较完整，本文主要提供一些代码参考，以及分享一些接入途中遇到的坑。\n\n# 1. 需要准备什么？\n接入云服务通常来说都需要准备一系列的各种 `公钥 私钥 证书 APPID APPSECRET` 等乱七八糟的东西，此处进行简单的列举，详细的申请步骤可以参考 [《微信支付接入前准备》](https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_1.shtml) 一文，相对来说已经描述的比较清晰了。\n\n直接放代码：\n\n```ruby\n# 在申请微信支付时由平台分配的开发者ID\nAPPID = Rails.application.credentials[:wx_pay][:appid]\n\n# 在申请微信支付时的收款账号\nMCHID = Rails.application.credentials[:wx_pay][:mch_id]\n\n# 微信支付 API V3 平台公钥，将用在回调验签中\nAPI_V3_SECRET = Rails.application.credentials[:wx_pay][:api_v3_secret]\n\n# 微信支付相关接口域名\nDOMAIN = 'https://api.mch.weixin.qq.com'.freeze\n```\n\n以上几个参数是可以直接在后台拿到的（大概……），在后台进行支付申请的时候应该还有一组证书文件需要下载，下载后解压大概长这样：\n\n![图片](https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609125555-image.png)\n\n此时我们需要获取证书的序列号，该序列号会被用在签名里。\n\n如何查看证书序列号，可以查看 [《微信支付 - 如何查看证书序列号》](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay7_0.shtml#part-5) 一文，在终端中利用 `OpenSSL` 可以很轻松的拿到。\n\n如果你不方便使用终端，可以尝试使用如下的 `Ruby` 代码获取（其实也是一样的）：\n\n```ruby\nrequire 'openssl'\n\nputs OpenSSL::X509::Certificate.new(open(your_cert_file_path).read).serial.to_s(16)\n```\n\n> 注意此处 `OpenSSL::X509::Certificate#serial.to_s` 得到的是一个十进制的值，而微信支付方统一使用的是十六进制的，因此我们传递了参数将其转为16进制。\n\n由于证书会放在服务器上，该序列号是不会变更的，所以可以直接写入 `credentials` 里\n\n```ruby\nSERIAL_NO = Rails.application.credentials[:wx_pay][:serial_no]\n```\n\n至此，我们准备好了所有的参数。\n\n# 2. 签名\n\n云服务为了保证通讯的双方合法，通常会使用签名的方式来进行验证，我们请求任何一个微信支付方的接口时都需要进行签名并将签名置于请求头中。\n\n关于签名与验签的详细说明请翻阅微信支付文档：\n\n[《微信支付 - 签名生成》](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_0.shtml)\n\n[《微信支付 - 签名验证》](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml)\n\n其中签名用于向微信支付发起请求，验签用于验证支付回调是否来自于微信支付。\n\n以下是参考代码，我将签名与验证签名的两个方法封装在了同一个类中：\n\n```ruby\nrequire 'openssl'\nrequire 'base64'\n\nclass Signature\n\n  def initialize(private_key = open(your_apiclient_key.pem_path).read)\n    @private_key = private_key\n  end\n\n  def sign(*params)\n    str = params.push('').join(\"\\n\")\n    pkey = OpenSSL::PKey::RSA.new(@private_key)\n    digest = OpenSSL::Digest::SHA256.new\n    signature = pkey.sign(digest, str)\n    Base64.strict_encode64(signature)\n  end\n\n  def verify(params = [], sign)\n    str = params.push('').join(\"\\n\")\n    pkey = OpenSSL::PKey::RSA.new(@private_key)\n    digest = OpenSSL::Digest::SHA256.new\n    pkey.verify(digest, Base64.decode64(sign), str)\n  end\n\nend\n```\n\n此处的构造函数中传入了一个动态的证书是因为：\n\n**签名与验签需要使用不同的证书！**\n\n**签名与验签需要使用不同的证书！**\n\n**签名与验签需要使用不同的证书！**\n\n重要的事情我说了三遍了_(:з」∠)_，以下是 [微信支付 - 签名验证](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml) 的截图：\n\n![图片](https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609126710-image.png)\n\n# 3. 封装请求\n完成签名后我们可以开始尝试接入微信支付的相关API了，按照以往的惯例我们会把这些请求做一个简单的封装，例如统一下单接口（代码写的有点丑，别打我_(:з」∠)_）：\n\n```ruby\nclass Service\n\n  DOMAIN = 'https://api.mch.weixin.qq.com'.freeze\n  APPID = Rails.application.credentials[:wx_pay][:appid]\n  MCHID = Rails.application.credentials[:wx_pay][:mch_id]\n  SERIAL_NO = Rails.application.credentials[:wx_pay][:serial_no]\n\n  # * app支付接口\n  def self.transactions_app(order_info)\n  \n    # * 构造请求参数\n    method = 'POST'.freeze\n    url = '/v3/pay/transactions/app'.freeze\n    timestamp = order_info[:timestamp]\n    nonce_str = order_info[:nonce_str]\n\n    body = {\n      \"appid\": APPID,\n      \"mchid\": MCHID,\n      \"description\": order_info[:description],\n      \"out_trade_no\": order_info[:out_trade_no],\n      \"notify_url\": your_notify_url,\n      \"amount\": {\n        \"total\": order_info[:amount]\n      }\n    }\n\n    # 构造签名\n    signature = WeChat::Util::CodeV3.new.sign(method, url, timestamp, nonce_str, body.to_json)\n\n    # 构造请求头\n    authorization_str = 'WECHATPAY2-SHA256-RSA2048 ' + \"mchid=\\\"\" + MCHIDMCHID + \"\\\",\" + \"nonce_str=\\\"\" + nonce_str + \"\\\",\" + \"timestamp=\\\"\" + timestamp.to_s + \"\\\",\" + \"serial_no=\\\"\" + SERIAL_NO + \"\\\",\" + \"signature=\\\"\" + signature + \"\\\"\"\n\n    # 发送请求\n    response = RestClient.post(DOMAIN + url, body.to_json, headers = {\n      \"Content-Type\": 'application/json',\n      \"Accept\": 'application/json',\n      \"Authorization\": authorization_str\n    })\n    JSON.parse(response.body)\n  end\n\nend\n```\n\n# 4. 获取平台证书\n\n在一个完整的支付环节中，正确的向微信支付发送请求是第一步，第二步我们需要对响应进行验证以确保请求确实来自于微信支付方。\n\n无论是验证响应，还是后续的微信支付回调通知，都需要使用相同的方法对签名进行验证。虽然相关的算法在前面已经实现了，但由于用于验签的证书与签名所使用的的证书是不一样的，因此需要提前准备证书。\n\n微信支付平台证书是动态的，每隔一段时间会进行替换以确保安全性。因此需要通过接口拉取证书。\n\n[《微信支付 - 获取平台证书列表》](http://192.168.31.72:3000/docs/index.html#/Order/post_v5_orders_huawei_pay_purchases_verify)\n\n发送请求与前面的其他接口一样，只要按照文档进行签名等既可，没什么需要讲的。此处主要走一下拉取到证书后的流程。\n\n获取平台证书列表返回的响应中，平台证书是经过加密的，要获取证书首先需要进行解密操作。\n\n[《微信支付 - 证书和回调版本解密》](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_2.shtml)\n\n微信支付对证书加密使用的是 `AEAD_AES_256_GCM` 加密算法，虽然在 `Ruby` 文档中找到了对应的标准库方法，但其实现细节似乎与微信支付给出的参数有些区别导致没有解密成功。\n\n> 解释：\n> 在[标准库文档](https://ruby-doc.org/stdlib-3.0.0/libdoc/openssl/rdoc/OpenSSL/Cipher.html)中，找到了 `AES-128-GCM` 相关内容：\n> ![图片](https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609135747-image.png)\n> 但让人疑惑的是微信支付返回的参数中的并没有解密需要的 `auth_tag` 。\n> 如果有了解 `AEAD` 算法的朋友麻烦在评论区赐教解释一下_(:з」∠)_\n\n最终找到了一个 [AEAD - GEM](https://github.com/onelogin/aead)，引入到工程后发现不能正常工作，查阅相关 [issue](https://github.com/onelogin/aead/issues/8) 找到了末尾的建议：\n\n![图片](https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609136215-image.png)\n\n![图片](https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609136227-image.png)\n\n也就是说如果要使用该 `GEM` ，我们需要添加的是由 `shopify` 修改过的版本，查看 `repo` 发现后者是由 `shopify` `fork` 后修改过的版本，如果不放心的话可以把代码 `clone` 部署到私有云上……`Gemfile` 里指定自己的私有云 `repo` 地址既可。\n\n而后我们对证书进行解密既可：\n\n```ruby\nrequire 'aead'\n\ndef self.aead_decode(key, nonce, aad, cipher_text)\n  mode = AEAD::Cipher.new('AES-256-GCM')\n  cipher = mode.new(key)\n  cipher.decrypt(nonce, aad, cipher_text)\nend\n```\n\n证书虽然每隔一段时间会更新，但并不需要每次都需要拉取，根据 [《微信支付 - 平台证书更新指引》](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay5_0.shtml) 的建议，此处我们在每次进行验签前，先将本地已经存储的证书序列号与 微信响应/回调请求 中声明的证书序列号做对比，当本次响应/请求使用的证书与本地不符时，才拉取最新的证书并持久化到本地，最终实现惰性更新。以下是参考代码：\n\n```ruby\ndef fetch(serial)\n\n  # 1. 通过serial序列号查找本地是否存在响应的证书，如果有，将证书实例返回\n  ... \n  return OpenSSL::X509::Certificate.new(open(cert_file_name).read) if File.exists? cert_file_name\n\n  # 2. 本地不存在时，请求接口拉取当前最新的证书列表\n  cert_list = WeChat::Service.certificates\n  cert = cert_list[:body]['data'].select{|cert| cert['serial_no'] == serial }[0]\n\n  return false if cert.nil?\n\n  # 3. 对证书进行解密\n  plaintext = aead_decode(API_V3_SECRET,\n                          cert['encrypt_certificate']['nonce'],\n                          cert['encrypt_certificate']['associated_data'],\n                          Base64.decode64(cert['encrypt_certificate']['ciphertext']))\n\n  # 4. 将证书持久化到本地并返回证书实例\n  file = File.open(cert_file_name, 'a+')\n  file&.syswrite(plaintext)\n  OpenSSL::X509::Certificate.new open(cert_file_name).read\nend\n```\n\n# 5. 对回调请求、响应进行验签\n\n验证签名比较简单，根据 [《微信支付 - 签名验证》](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml) 的指引，我们需要对 响应/回调请求 进行如下验证：\n\n- 检验微信支付方使用的证书\n- 使用微信支付证书中的公钥验证签名\n- 解密响应报文，获取响应数据\n- 验证订单数据\n\n此处有一个不得不提的坑是在验证签名时应使用 **请求报文的原文** ，在 `Rails` 中可以通过如下方法获取：\n\n```ruby\nrequest.raw_post\n```\n\n以下使用异步回调通知进行示例（示例中删除了部分业务代码）：\n\n```ruby\n# frozen_string_literal: true\n\nrequire 'pay/wechat/wechat'\nrequire 'pay/wechat/util'\n\nclass WechatController < ApplicationController\n\n  # * 微信支付后的回调接口\n  def pay_notify\n\n    wechat_pay_serial = request.headers['Wechatpay-Serial']\n    wechat_timestamp = request.headers['Wechatpay-Timestamp']\n    wechat_pay_signature = request.headers['Wechatpay-Signature']\n    wechat_pay_nonce = request.headers['Wechatpay-Nonce']\n\n    # 获取请求体原文\n    body = request.raw_post\n\n    # 1. 验证微信平台证书与当前持有的证书是否相同\n    #    当微信平台证书序列号与本地证书序列号不相同时，应答错误信息，等待下一次回调\n    unless WeChat::Util::ResultVerify.new.serial_verify?(wechat_pay_serial)\n      raise ......\n    end\n\n    # 2. 验证回调签名\n    #    获取微信平台证书公钥并进行签名验证\n    wechat_pay_public_key = WeChat::Util::Certificate.get(wechat_pay_serial).public_key.to_pem\n    unless WeChat::Util::CodeV3.new(wechat_pay_public_key).verify([wechat_timestamp, wechat_pay_nonce, body], wechat_pay_signature)\n      return render json: ......, status: 400\n    end\n\n    # 3. 解密请求主体中的订单信息并验证\n    nonce = params[\"resource\"][\"nonce\"]\n    aad = params[\"resource\"][\"associated_data\"]\n    cipher_text = params[\"resource\"][\"ciphertext\"]\n\n    decode_str = WeChat::Util::Certificate.send(:aead_decode, WeChat::API_V3_SECRET, nonce, aad, Base64.decode64(cipher_text))\n\n    res = JSON.parse(decode_str)\n\n    order = Order.find_by_out_trade_no(res[\"out_trade_no\"])\n\n    unless order.total_fee == res[\"amount\"][\"total\"]\n      return render json: ..., status: 400\n    end\n\n    unless WeChat::ServiceV3::AppID == res['appid']\n      return render json: ..., status: 400\n    end\n\n    unless WeChat::ServiceV3::MchID == res['mchid']\n      return render json: ..., status: 400\n    end\n\n    # 发货处理\n    ...\n\n    render json: {'code': \"SUCCESS\", 'message': ''}\n\n  rescue ActiveRecord::StaleObjectError\n    return render json: ..., status: 400\n  rescue WeChat::Util::CertificateNotFound\n    return render json: ..., status: 400\n  rescue StandardError => e\n    logger.error \"#{e.full_message}\"\n    render json: ..., status: 500\n  end\n\nend\n```\n\n几乎就是纯面向过程编程……代码中有些诸如 `xx.send` 的东西大家就当没看见好了_(:з」∠)_（蒙混过关）……\n\n# 6. 结语\n\n至此我们就完成了基础的微信支付中所涉及到的大部分问题，个人感觉微信支付升级到V3之后确实要简单了不少。~~即便如此每次接入一个新的云服务的时候都感觉是被按在地上补密码学……~~\n\n对于文中的叙述有不同意见可以在评论区与我讨论，如果觉得这篇文章对您有用不妨给我一个赞~最后祝大家都能光速接入微信支付。\n","source":"_posts/在Rails中接入微信支付指北.md","raw":"# 0. 写在前面\n其实公司项目早在去年就做完第一版的微信支付了，但是由于种种原因并没有上线，一直拖到了今年。\n\n让人 *疼 的一件事情是，虽然基础功能都已经实现了，代码也有了，但是考虑微信支付更新了V3版本，以及反正产品还没有正式上微信支付，公司最终决定直接接入V3版本的微信支付，之前的代码基本上没法儿再用了。\n\n另外 `Ruby` 这个没人疼没人爱的孩子又着实可怜的不行，V2版本的微信支付还可以参考使用社区姜老师(`@jasl`)的 [微信支付GEM](https://github.com/jasl/wx_pay)，V3版本干脆就没有可以参考的 `Ruby` 代码了。\n\n好就好在V3开始的微信支付相对之前的V2要简单许多，以及相关的文档也比较完整，本文主要提供一些代码参考，以及分享一些接入途中遇到的坑。\n\n# 1. 需要准备什么？\n接入云服务通常来说都需要准备一系列的各种 `公钥 私钥 证书 APPID APPSECRET` 等乱七八糟的东西，此处进行简单的列举，详细的申请步骤可以参考 [《微信支付接入前准备》](https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_1.shtml) 一文，相对来说已经描述的比较清晰了。\n\n直接放代码：\n\n```ruby\n# 在申请微信支付时由平台分配的开发者ID\nAPPID = Rails.application.credentials[:wx_pay][:appid]\n\n# 在申请微信支付时的收款账号\nMCHID = Rails.application.credentials[:wx_pay][:mch_id]\n\n# 微信支付 API V3 平台公钥，将用在回调验签中\nAPI_V3_SECRET = Rails.application.credentials[:wx_pay][:api_v3_secret]\n\n# 微信支付相关接口域名\nDOMAIN = 'https://api.mch.weixin.qq.com'.freeze\n```\n\n以上几个参数是可以直接在后台拿到的（大概……），在后台进行支付申请的时候应该还有一组证书文件需要下载，下载后解压大概长这样：\n\n![图片](https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609125555-image.png)\n\n此时我们需要获取证书的序列号，该序列号会被用在签名里。\n\n如何查看证书序列号，可以查看 [《微信支付 - 如何查看证书序列号》](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay7_0.shtml#part-5) 一文，在终端中利用 `OpenSSL` 可以很轻松的拿到。\n\n如果你不方便使用终端，可以尝试使用如下的 `Ruby` 代码获取（其实也是一样的）：\n\n```ruby\nrequire 'openssl'\n\nputs OpenSSL::X509::Certificate.new(open(your_cert_file_path).read).serial.to_s(16)\n```\n\n> 注意此处 `OpenSSL::X509::Certificate#serial.to_s` 得到的是一个十进制的值，而微信支付方统一使用的是十六进制的，因此我们传递了参数将其转为16进制。\n\n由于证书会放在服务器上，该序列号是不会变更的，所以可以直接写入 `credentials` 里\n\n```ruby\nSERIAL_NO = Rails.application.credentials[:wx_pay][:serial_no]\n```\n\n至此，我们准备好了所有的参数。\n\n# 2. 签名\n\n云服务为了保证通讯的双方合法，通常会使用签名的方式来进行验证，我们请求任何一个微信支付方的接口时都需要进行签名并将签名置于请求头中。\n\n关于签名与验签的详细说明请翻阅微信支付文档：\n\n[《微信支付 - 签名生成》](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_0.shtml)\n\n[《微信支付 - 签名验证》](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml)\n\n其中签名用于向微信支付发起请求，验签用于验证支付回调是否来自于微信支付。\n\n以下是参考代码，我将签名与验证签名的两个方法封装在了同一个类中：\n\n```ruby\nrequire 'openssl'\nrequire 'base64'\n\nclass Signature\n\n  def initialize(private_key = open(your_apiclient_key.pem_path).read)\n    @private_key = private_key\n  end\n\n  def sign(*params)\n    str = params.push('').join(\"\\n\")\n    pkey = OpenSSL::PKey::RSA.new(@private_key)\n    digest = OpenSSL::Digest::SHA256.new\n    signature = pkey.sign(digest, str)\n    Base64.strict_encode64(signature)\n  end\n\n  def verify(params = [], sign)\n    str = params.push('').join(\"\\n\")\n    pkey = OpenSSL::PKey::RSA.new(@private_key)\n    digest = OpenSSL::Digest::SHA256.new\n    pkey.verify(digest, Base64.decode64(sign), str)\n  end\n\nend\n```\n\n此处的构造函数中传入了一个动态的证书是因为：\n\n**签名与验签需要使用不同的证书！**\n\n**签名与验签需要使用不同的证书！**\n\n**签名与验签需要使用不同的证书！**\n\n重要的事情我说了三遍了_(:з」∠)_，以下是 [微信支付 - 签名验证](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml) 的截图：\n\n![图片](https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609126710-image.png)\n\n# 3. 封装请求\n完成签名后我们可以开始尝试接入微信支付的相关API了，按照以往的惯例我们会把这些请求做一个简单的封装，例如统一下单接口（代码写的有点丑，别打我_(:з」∠)_）：\n\n```ruby\nclass Service\n\n  DOMAIN = 'https://api.mch.weixin.qq.com'.freeze\n  APPID = Rails.application.credentials[:wx_pay][:appid]\n  MCHID = Rails.application.credentials[:wx_pay][:mch_id]\n  SERIAL_NO = Rails.application.credentials[:wx_pay][:serial_no]\n\n  # * app支付接口\n  def self.transactions_app(order_info)\n  \n    # * 构造请求参数\n    method = 'POST'.freeze\n    url = '/v3/pay/transactions/app'.freeze\n    timestamp = order_info[:timestamp]\n    nonce_str = order_info[:nonce_str]\n\n    body = {\n      \"appid\": APPID,\n      \"mchid\": MCHID,\n      \"description\": order_info[:description],\n      \"out_trade_no\": order_info[:out_trade_no],\n      \"notify_url\": your_notify_url,\n      \"amount\": {\n        \"total\": order_info[:amount]\n      }\n    }\n\n    # 构造签名\n    signature = WeChat::Util::CodeV3.new.sign(method, url, timestamp, nonce_str, body.to_json)\n\n    # 构造请求头\n    authorization_str = 'WECHATPAY2-SHA256-RSA2048 ' + \"mchid=\\\"\" + MCHIDMCHID + \"\\\",\" + \"nonce_str=\\\"\" + nonce_str + \"\\\",\" + \"timestamp=\\\"\" + timestamp.to_s + \"\\\",\" + \"serial_no=\\\"\" + SERIAL_NO + \"\\\",\" + \"signature=\\\"\" + signature + \"\\\"\"\n\n    # 发送请求\n    response = RestClient.post(DOMAIN + url, body.to_json, headers = {\n      \"Content-Type\": 'application/json',\n      \"Accept\": 'application/json',\n      \"Authorization\": authorization_str\n    })\n    JSON.parse(response.body)\n  end\n\nend\n```\n\n# 4. 获取平台证书\n\n在一个完整的支付环节中，正确的向微信支付发送请求是第一步，第二步我们需要对响应进行验证以确保请求确实来自于微信支付方。\n\n无论是验证响应，还是后续的微信支付回调通知，都需要使用相同的方法对签名进行验证。虽然相关的算法在前面已经实现了，但由于用于验签的证书与签名所使用的的证书是不一样的，因此需要提前准备证书。\n\n微信支付平台证书是动态的，每隔一段时间会进行替换以确保安全性。因此需要通过接口拉取证书。\n\n[《微信支付 - 获取平台证书列表》](http://192.168.31.72:3000/docs/index.html#/Order/post_v5_orders_huawei_pay_purchases_verify)\n\n发送请求与前面的其他接口一样，只要按照文档进行签名等既可，没什么需要讲的。此处主要走一下拉取到证书后的流程。\n\n获取平台证书列表返回的响应中，平台证书是经过加密的，要获取证书首先需要进行解密操作。\n\n[《微信支付 - 证书和回调版本解密》](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_2.shtml)\n\n微信支付对证书加密使用的是 `AEAD_AES_256_GCM` 加密算法，虽然在 `Ruby` 文档中找到了对应的标准库方法，但其实现细节似乎与微信支付给出的参数有些区别导致没有解密成功。\n\n> 解释：\n> 在[标准库文档](https://ruby-doc.org/stdlib-3.0.0/libdoc/openssl/rdoc/OpenSSL/Cipher.html)中，找到了 `AES-128-GCM` 相关内容：\n> ![图片](https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609135747-image.png)\n> 但让人疑惑的是微信支付返回的参数中的并没有解密需要的 `auth_tag` 。\n> 如果有了解 `AEAD` 算法的朋友麻烦在评论区赐教解释一下_(:з」∠)_\n\n最终找到了一个 [AEAD - GEM](https://github.com/onelogin/aead)，引入到工程后发现不能正常工作，查阅相关 [issue](https://github.com/onelogin/aead/issues/8) 找到了末尾的建议：\n\n![图片](https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609136215-image.png)\n\n![图片](https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609136227-image.png)\n\n也就是说如果要使用该 `GEM` ，我们需要添加的是由 `shopify` 修改过的版本，查看 `repo` 发现后者是由 `shopify` `fork` 后修改过的版本，如果不放心的话可以把代码 `clone` 部署到私有云上……`Gemfile` 里指定自己的私有云 `repo` 地址既可。\n\n而后我们对证书进行解密既可：\n\n```ruby\nrequire 'aead'\n\ndef self.aead_decode(key, nonce, aad, cipher_text)\n  mode = AEAD::Cipher.new('AES-256-GCM')\n  cipher = mode.new(key)\n  cipher.decrypt(nonce, aad, cipher_text)\nend\n```\n\n证书虽然每隔一段时间会更新，但并不需要每次都需要拉取，根据 [《微信支付 - 平台证书更新指引》](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay5_0.shtml) 的建议，此处我们在每次进行验签前，先将本地已经存储的证书序列号与 微信响应/回调请求 中声明的证书序列号做对比，当本次响应/请求使用的证书与本地不符时，才拉取最新的证书并持久化到本地，最终实现惰性更新。以下是参考代码：\n\n```ruby\ndef fetch(serial)\n\n  # 1. 通过serial序列号查找本地是否存在响应的证书，如果有，将证书实例返回\n  ... \n  return OpenSSL::X509::Certificate.new(open(cert_file_name).read) if File.exists? cert_file_name\n\n  # 2. 本地不存在时，请求接口拉取当前最新的证书列表\n  cert_list = WeChat::Service.certificates\n  cert = cert_list[:body]['data'].select{|cert| cert['serial_no'] == serial }[0]\n\n  return false if cert.nil?\n\n  # 3. 对证书进行解密\n  plaintext = aead_decode(API_V3_SECRET,\n                          cert['encrypt_certificate']['nonce'],\n                          cert['encrypt_certificate']['associated_data'],\n                          Base64.decode64(cert['encrypt_certificate']['ciphertext']))\n\n  # 4. 将证书持久化到本地并返回证书实例\n  file = File.open(cert_file_name, 'a+')\n  file&.syswrite(plaintext)\n  OpenSSL::X509::Certificate.new open(cert_file_name).read\nend\n```\n\n# 5. 对回调请求、响应进行验签\n\n验证签名比较简单，根据 [《微信支付 - 签名验证》](https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml) 的指引，我们需要对 响应/回调请求 进行如下验证：\n\n- 检验微信支付方使用的证书\n- 使用微信支付证书中的公钥验证签名\n- 解密响应报文，获取响应数据\n- 验证订单数据\n\n此处有一个不得不提的坑是在验证签名时应使用 **请求报文的原文** ，在 `Rails` 中可以通过如下方法获取：\n\n```ruby\nrequest.raw_post\n```\n\n以下使用异步回调通知进行示例（示例中删除了部分业务代码）：\n\n```ruby\n# frozen_string_literal: true\n\nrequire 'pay/wechat/wechat'\nrequire 'pay/wechat/util'\n\nclass WechatController < ApplicationController\n\n  # * 微信支付后的回调接口\n  def pay_notify\n\n    wechat_pay_serial = request.headers['Wechatpay-Serial']\n    wechat_timestamp = request.headers['Wechatpay-Timestamp']\n    wechat_pay_signature = request.headers['Wechatpay-Signature']\n    wechat_pay_nonce = request.headers['Wechatpay-Nonce']\n\n    # 获取请求体原文\n    body = request.raw_post\n\n    # 1. 验证微信平台证书与当前持有的证书是否相同\n    #    当微信平台证书序列号与本地证书序列号不相同时，应答错误信息，等待下一次回调\n    unless WeChat::Util::ResultVerify.new.serial_verify?(wechat_pay_serial)\n      raise ......\n    end\n\n    # 2. 验证回调签名\n    #    获取微信平台证书公钥并进行签名验证\n    wechat_pay_public_key = WeChat::Util::Certificate.get(wechat_pay_serial).public_key.to_pem\n    unless WeChat::Util::CodeV3.new(wechat_pay_public_key).verify([wechat_timestamp, wechat_pay_nonce, body], wechat_pay_signature)\n      return render json: ......, status: 400\n    end\n\n    # 3. 解密请求主体中的订单信息并验证\n    nonce = params[\"resource\"][\"nonce\"]\n    aad = params[\"resource\"][\"associated_data\"]\n    cipher_text = params[\"resource\"][\"ciphertext\"]\n\n    decode_str = WeChat::Util::Certificate.send(:aead_decode, WeChat::API_V3_SECRET, nonce, aad, Base64.decode64(cipher_text))\n\n    res = JSON.parse(decode_str)\n\n    order = Order.find_by_out_trade_no(res[\"out_trade_no\"])\n\n    unless order.total_fee == res[\"amount\"][\"total\"]\n      return render json: ..., status: 400\n    end\n\n    unless WeChat::ServiceV3::AppID == res['appid']\n      return render json: ..., status: 400\n    end\n\n    unless WeChat::ServiceV3::MchID == res['mchid']\n      return render json: ..., status: 400\n    end\n\n    # 发货处理\n    ...\n\n    render json: {'code': \"SUCCESS\", 'message': ''}\n\n  rescue ActiveRecord::StaleObjectError\n    return render json: ..., status: 400\n  rescue WeChat::Util::CertificateNotFound\n    return render json: ..., status: 400\n  rescue StandardError => e\n    logger.error \"#{e.full_message}\"\n    render json: ..., status: 500\n  end\n\nend\n```\n\n几乎就是纯面向过程编程……代码中有些诸如 `xx.send` 的东西大家就当没看见好了_(:з」∠)_（蒙混过关）……\n\n# 6. 结语\n\n至此我们就完成了基础的微信支付中所涉及到的大部分问题，个人感觉微信支付升级到V3之后确实要简单了不少。~~即便如此每次接入一个新的云服务的时候都感觉是被按在地上补密码学……~~\n\n对于文中的叙述有不同意见可以在评论区与我讨论，如果觉得这篇文章对您有用不妨给我一个赞~最后祝大家都能光速接入微信支付。\n","slug":"在Rails中接入微信支付指北","published":1,"date":"2022-05-03T08:46:25.152Z","updated":"2022-05-03T08:46:25.152Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdum002er2vebe41g5zw","content":"<h1 id=\"0-写在前面\"><a href=\"#0-写在前面\" class=\"headerlink\" title=\"0. 写在前面\"></a>0. 写在前面</h1><p>其实公司项目早在去年就做完第一版的微信支付了，但是由于种种原因并没有上线，一直拖到了今年。</p>\n<p>让人 *疼 的一件事情是，虽然基础功能都已经实现了，代码也有了，但是考虑微信支付更新了V3版本，以及反正产品还没有正式上微信支付，公司最终决定直接接入V3版本的微信支付，之前的代码基本上没法儿再用了。</p>\n<p>另外 <code>Ruby</code> 这个没人疼没人爱的孩子又着实可怜的不行，V2版本的微信支付还可以参考使用社区姜老师(<code>@jasl</code>)的 <a href=\"https://github.com/jasl/wx_pay\">微信支付GEM</a>，V3版本干脆就没有可以参考的 <code>Ruby</code> 代码了。</p>\n<p>好就好在V3开始的微信支付相对之前的V2要简单许多，以及相关的文档也比较完整，本文主要提供一些代码参考，以及分享一些接入途中遇到的坑。</p>\n<h1 id=\"1-需要准备什么？\"><a href=\"#1-需要准备什么？\" class=\"headerlink\" title=\"1. 需要准备什么？\"></a>1. 需要准备什么？</h1><p>接入云服务通常来说都需要准备一系列的各种 <code>公钥 私钥 证书 APPID APPSECRET</code> 等乱七八糟的东西，此处进行简单的列举，详细的申请步骤可以参考 <a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_1.shtml\">《微信支付接入前准备》</a> 一文，相对来说已经描述的比较清晰了。</p>\n<p>直接放代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在申请微信支付时由平台分配的开发者ID</span></span><br><span class=\"line\"><span class=\"variable constant_\">APPID</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:appid</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在申请微信支付时的收款账号</span></span><br><span class=\"line\"><span class=\"variable constant_\">MCHID</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:mch_id</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 微信支付 API V3 平台公钥，将用在回调验签中</span></span><br><span class=\"line\"><span class=\"variable constant_\">API_V3_SECRET</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:api_v3_secret</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 微信支付相关接口域名</span></span><br><span class=\"line\"><span class=\"variable constant_\">DOMAIN</span> = <span class=\"string\">&#x27;https://api.mch.weixin.qq.com&#x27;</span>.freeze</span><br></pre></td></tr></table></figure>\n\n<p>以上几个参数是可以直接在后台拿到的（大概……），在后台进行支付申请的时候应该还有一组证书文件需要下载，下载后解压大概长这样：</p>\n<p><img src=\"https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609125555-image.png\" alt=\"图片\"></p>\n<p>此时我们需要获取证书的序列号，该序列号会被用在签名里。</p>\n<p>如何查看证书序列号，可以查看 <a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay7_0.shtml#part-5\">《微信支付 - 如何查看证书序列号》</a> 一文，在终端中利用 <code>OpenSSL</code> 可以很轻松的拿到。</p>\n<p>如果你不方便使用终端，可以尝试使用如下的 <code>Ruby</code> 代码获取（其实也是一样的）：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;openssl&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">puts <span class=\"title class_\">OpenSSL::X509::Certificate</span>.new(open(your_cert_file_path).read).serial.to_s(<span class=\"number\">16</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意此处 <code>OpenSSL::X509::Certificate#serial.to_s</code> 得到的是一个十进制的值，而微信支付方统一使用的是十六进制的，因此我们传递了参数将其转为16进制。</p>\n</blockquote>\n<p>由于证书会放在服务器上，该序列号是不会变更的，所以可以直接写入 <code>credentials</code> 里</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">SERIAL_NO</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:serial_no</span>]</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们准备好了所有的参数。</p>\n<h1 id=\"2-签名\"><a href=\"#2-签名\" class=\"headerlink\" title=\"2. 签名\"></a>2. 签名</h1><p>云服务为了保证通讯的双方合法，通常会使用签名的方式来进行验证，我们请求任何一个微信支付方的接口时都需要进行签名并将签名置于请求头中。</p>\n<p>关于签名与验签的详细说明请翻阅微信支付文档：</p>\n<p><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_0.shtml\">《微信支付 - 签名生成》</a></p>\n<p><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml\">《微信支付 - 签名验证》</a></p>\n<p>其中签名用于向微信支付发起请求，验签用于验证支付回调是否来自于微信支付。</p>\n<p>以下是参考代码，我将签名与验证签名的两个方法封装在了同一个类中：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;openssl&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;base64&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signature</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">initialize</span>(<span class=\"params\">private_key = open(your_apiclient_key.pem_path</span>).read)</span><br><span class=\"line\">    <span class=\"variable\">@private_key</span> = private_key</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">sign</span>(<span class=\"params\">*params</span>)</span><br><span class=\"line\">    str = params.push(<span class=\"string\">&#x27;&#x27;</span>).join(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">    pkey = <span class=\"title class_\">OpenSSL::PKey::RSA</span>.new(<span class=\"variable\">@private_key</span>)</span><br><span class=\"line\">    digest = OpenSSL::Digest::<span class=\"variable constant_\">SHA256</span>.new</span><br><span class=\"line\">    signature = pkey.sign(digest, str)</span><br><span class=\"line\">    Base64.strict_encode64(signature)</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">verify</span>(<span class=\"params\">params = [], sign</span>)</span><br><span class=\"line\">    str = params.push(<span class=\"string\">&#x27;&#x27;</span>).join(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">    pkey = <span class=\"title class_\">OpenSSL::PKey::RSA</span>.new(<span class=\"variable\">@private_key</span>)</span><br><span class=\"line\">    digest = OpenSSL::Digest::<span class=\"variable constant_\">SHA256</span>.new</span><br><span class=\"line\">    pkey.verify(digest, Base64.decode64(sign), str)</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>此处的构造函数中传入了一个动态的证书是因为：</p>\n<p><strong>签名与验签需要使用不同的证书！</strong></p>\n<p><strong>签名与验签需要使用不同的证书！</strong></p>\n<p><strong>签名与验签需要使用不同的证书！</strong></p>\n<p>重要的事情我说了三遍了_(:з」∠)_，以下是 <a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml\">微信支付 - 签名验证</a> 的截图：</p>\n<p><img src=\"https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609126710-image.png\" alt=\"图片\"></p>\n<h1 id=\"3-封装请求\"><a href=\"#3-封装请求\" class=\"headerlink\" title=\"3. 封装请求\"></a>3. 封装请求</h1><p>完成签名后我们可以开始尝试接入微信支付的相关API了，按照以往的惯例我们会把这些请求做一个简单的封装，例如统一下单接口（代码写的有点丑，别打我_(:з」∠)_）：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Service</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable constant_\">DOMAIN</span> = <span class=\"string\">&#x27;https://api.mch.weixin.qq.com&#x27;</span>.freeze</span><br><span class=\"line\">  <span class=\"variable constant_\">APPID</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:appid</span>]</span><br><span class=\"line\">  <span class=\"variable constant_\">MCHID</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:mch_id</span>]</span><br><span class=\"line\">  <span class=\"variable constant_\">SERIAL_NO</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:serial_no</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># * app支付接口</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">self</span>.transactions_app(order_info)</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\"># * 构造请求参数</span></span><br><span class=\"line\">    method = <span class=\"string\">&#x27;POST&#x27;</span>.freeze</span><br><span class=\"line\">    url = <span class=\"string\">&#x27;/v3/pay/transactions/app&#x27;</span>.freeze</span><br><span class=\"line\">    timestamp = order_info[<span class=\"symbol\">:timestamp</span>]</span><br><span class=\"line\">    nonce_str = order_info[<span class=\"symbol\">:nonce_str</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    body = &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;appid&quot;</span>: <span class=\"variable constant_\">APPID</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;mchid&quot;</span>: <span class=\"variable constant_\">MCHID</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;description&quot;</span>: order_info[<span class=\"symbol\">:description</span>],</span><br><span class=\"line\">      <span class=\"string\">&quot;out_trade_no&quot;</span>: order_info[<span class=\"symbol\">:out_trade_no</span>],</span><br><span class=\"line\">      <span class=\"string\">&quot;notify_url&quot;</span>: your_notify_url,</span><br><span class=\"line\">      <span class=\"string\">&quot;amount&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;total&quot;</span>: order_info[<span class=\"symbol\">:amount</span>]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 构造签名</span></span><br><span class=\"line\">    signature = WeChat::Util::CodeV3.new.sign(method, url, timestamp, nonce_str, body.to_json)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 构造请求头</span></span><br><span class=\"line\">    authorization_str = <span class=\"string\">&#x27;WECHATPAY2-SHA256-RSA2048 &#x27;</span> + <span class=\"string\">&quot;mchid=\\&quot;&quot;</span> + <span class=\"variable constant_\">MCHIDMCHID</span> + <span class=\"string\">&quot;\\&quot;,&quot;</span> + <span class=\"string\">&quot;nonce_str=\\&quot;&quot;</span> + nonce_str + <span class=\"string\">&quot;\\&quot;,&quot;</span> + <span class=\"string\">&quot;timestamp=\\&quot;&quot;</span> + timestamp.to_s + <span class=\"string\">&quot;\\&quot;,&quot;</span> + <span class=\"string\">&quot;serial_no=\\&quot;&quot;</span> + <span class=\"variable constant_\">SERIAL_NO</span> + <span class=\"string\">&quot;\\&quot;,&quot;</span> + <span class=\"string\">&quot;signature=\\&quot;&quot;</span> + signature + <span class=\"string\">&quot;\\&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 发送请求</span></span><br><span class=\"line\">    response = RestClient.post(<span class=\"variable constant_\">DOMAIN</span> + url, body.to_json, headers = &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;Content-Type&quot;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;Accept&quot;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;Authorization&quot;</span>: authorization_str</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"variable constant_\">JSON</span>.parse(response.body)</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-获取平台证书\"><a href=\"#4-获取平台证书\" class=\"headerlink\" title=\"4. 获取平台证书\"></a>4. 获取平台证书</h1><p>在一个完整的支付环节中，正确的向微信支付发送请求是第一步，第二步我们需要对响应进行验证以确保请求确实来自于微信支付方。</p>\n<p>无论是验证响应，还是后续的微信支付回调通知，都需要使用相同的方法对签名进行验证。虽然相关的算法在前面已经实现了，但由于用于验签的证书与签名所使用的的证书是不一样的，因此需要提前准备证书。</p>\n<p>微信支付平台证书是动态的，每隔一段时间会进行替换以确保安全性。因此需要通过接口拉取证书。</p>\n<p><a href=\"http://192.168.31.72:3000/docs/index.html#/Order/post_v5_orders_huawei_pay_purchases_verify\">《微信支付 - 获取平台证书列表》</a></p>\n<p>发送请求与前面的其他接口一样，只要按照文档进行签名等既可，没什么需要讲的。此处主要走一下拉取到证书后的流程。</p>\n<p>获取平台证书列表返回的响应中，平台证书是经过加密的，要获取证书首先需要进行解密操作。</p>\n<p><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_2.shtml\">《微信支付 - 证书和回调版本解密》</a></p>\n<p>微信支付对证书加密使用的是 <code>AEAD_AES_256_GCM</code> 加密算法，虽然在 <code>Ruby</code> 文档中找到了对应的标准库方法，但其实现细节似乎与微信支付给出的参数有些区别导致没有解密成功。</p>\n<blockquote>\n<p>解释：<br>在<a href=\"https://ruby-doc.org/stdlib-3.0.0/libdoc/openssl/rdoc/OpenSSL/Cipher.html\">标准库文档</a>中，找到了 <code>AES-128-GCM</code> 相关内容：<br><img src=\"https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609135747-image.png\" alt=\"图片\"><br>但让人疑惑的是微信支付返回的参数中的并没有解密需要的 <code>auth_tag</code> 。<br>如果有了解 <code>AEAD</code> 算法的朋友麻烦在评论区赐教解释一下_(:з」∠)_</p>\n</blockquote>\n<p>最终找到了一个 <a href=\"https://github.com/onelogin/aead\">AEAD - GEM</a>，引入到工程后发现不能正常工作，查阅相关 <a href=\"https://github.com/onelogin/aead/issues/8\">issue</a> 找到了末尾的建议：</p>\n<p><img src=\"https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609136215-image.png\" alt=\"图片\"></p>\n<p><img src=\"https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609136227-image.png\" alt=\"图片\"></p>\n<p>也就是说如果要使用该 <code>GEM</code> ，我们需要添加的是由 <code>shopify</code> 修改过的版本，查看 <code>repo</code> 发现后者是由 <code>shopify</code> <code>fork</code> 后修改过的版本，如果不放心的话可以把代码 <code>clone</code> 部署到私有云上……<code>Gemfile</code> 里指定自己的私有云 <code>repo</code> 地址既可。</p>\n<p>而后我们对证书进行解密既可：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;aead&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">self</span>.aead_decode(key, nonce, aad, cipher_text)</span><br><span class=\"line\">  mode = <span class=\"variable constant_\">AEAD</span><span class=\"symbol\">:</span><span class=\"symbol\">:Cipher</span>.new(<span class=\"string\">&#x27;AES-256-GCM&#x27;</span>)</span><br><span class=\"line\">  cipher = mode.new(key)</span><br><span class=\"line\">  cipher.decrypt(nonce, aad, cipher_text)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>证书虽然每隔一段时间会更新，但并不需要每次都需要拉取，根据 <a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay5_0.shtml\">《微信支付 - 平台证书更新指引》</a> 的建议，此处我们在每次进行验签前，先将本地已经存储的证书序列号与 微信响应&#x2F;回调请求 中声明的证书序列号做对比，当本次响应&#x2F;请求使用的证书与本地不符时，才拉取最新的证书并持久化到本地，最终实现惰性更新。以下是参考代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fetch</span>(<span class=\"params\">serial</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 1. 通过serial序列号查找本地是否存在响应的证书，如果有，将证书实例返回</span></span><br><span class=\"line\">  ... </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">OpenSSL::X509::Certificate</span>.new(open(cert_file_name).read) <span class=\"keyword\">if</span> File.exists? cert_file_name</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 2. 本地不存在时，请求接口拉取当前最新的证书列表</span></span><br><span class=\"line\">  cert_list = WeChat::Service.certificates</span><br><span class=\"line\">  cert = cert_list[<span class=\"symbol\">:body</span>][<span class=\"string\">&#x27;data&#x27;</span>].select&#123;|<span class=\"params\">cert</span>| cert[<span class=\"string\">&#x27;serial_no&#x27;</span>] == serial &#125;[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span> <span class=\"keyword\">if</span> cert.<span class=\"literal\">nil</span>?</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 3. 对证书进行解密</span></span><br><span class=\"line\">  plaintext = aead_decode(<span class=\"variable constant_\">API_V3_SECRET</span>,</span><br><span class=\"line\">                          cert[<span class=\"string\">&#x27;encrypt_certificate&#x27;</span>][<span class=\"string\">&#x27;nonce&#x27;</span>],</span><br><span class=\"line\">                          cert[<span class=\"string\">&#x27;encrypt_certificate&#x27;</span>][<span class=\"string\">&#x27;associated_data&#x27;</span>],</span><br><span class=\"line\">                          Base64.decode64(cert[<span class=\"string\">&#x27;encrypt_certificate&#x27;</span>][<span class=\"string\">&#x27;ciphertext&#x27;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 4. 将证书持久化到本地并返回证书实例</span></span><br><span class=\"line\">  file = File.open(cert_file_name, <span class=\"string\">&#x27;a+&#x27;</span>)</span><br><span class=\"line\">  file&amp;.syswrite(plaintext)</span><br><span class=\"line\">  <span class=\"title class_\">OpenSSL::X509::Certificate</span>.new open(cert_file_name).read</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-对回调请求、响应进行验签\"><a href=\"#5-对回调请求、响应进行验签\" class=\"headerlink\" title=\"5. 对回调请求、响应进行验签\"></a>5. 对回调请求、响应进行验签</h1><p>验证签名比较简单，根据 <a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml\">《微信支付 - 签名验证》</a> 的指引，我们需要对 响应&#x2F;回调请求 进行如下验证：</p>\n<ul>\n<li>检验微信支付方使用的证书</li>\n<li>使用微信支付证书中的公钥验证签名</li>\n<li>解密响应报文，获取响应数据</li>\n<li>验证订单数据</li>\n</ul>\n<p>此处有一个不得不提的坑是在验证签名时应使用 <strong>请求报文的原文</strong> ，在 <code>Rails</code> 中可以通过如下方法获取：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.raw_post</span><br></pre></td></tr></table></figure>\n\n<p>以下使用异步回调通知进行示例（示例中删除了部分业务代码）：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># frozen_string_literal: true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;pay/wechat/wechat&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;pay/wechat/util&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WechatController</span> &lt; <span class=\"title class_ inherited__\">ApplicationController</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># * 微信支付后的回调接口</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">pay_notify</span></span><br><span class=\"line\"></span><br><span class=\"line\">    wechat_pay_serial = request.headers[<span class=\"string\">&#x27;Wechatpay-Serial&#x27;</span>]</span><br><span class=\"line\">    wechat_timestamp = request.headers[<span class=\"string\">&#x27;Wechatpay-Timestamp&#x27;</span>]</span><br><span class=\"line\">    wechat_pay_signature = request.headers[<span class=\"string\">&#x27;Wechatpay-Signature&#x27;</span>]</span><br><span class=\"line\">    wechat_pay_nonce = request.headers[<span class=\"string\">&#x27;Wechatpay-Nonce&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 获取请求体原文</span></span><br><span class=\"line\">    body = request.raw_post</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 1. 验证微信平台证书与当前持有的证书是否相同</span></span><br><span class=\"line\">    <span class=\"comment\">#    当微信平台证书序列号与本地证书序列号不相同时，应答错误信息，等待下一次回调</span></span><br><span class=\"line\">    <span class=\"keyword\">unless</span> WeChat::Util::ResultVerify.new.serial_verify?(wechat_pay_serial)</span><br><span class=\"line\">      raise ......</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 2. 验证回调签名</span></span><br><span class=\"line\">    <span class=\"comment\">#    获取微信平台证书公钥并进行签名验证</span></span><br><span class=\"line\">    wechat_pay_public_key = WeChat::Util::Certificate.get(wechat_pay_serial).public_key.to_pem</span><br><span class=\"line\">    <span class=\"keyword\">unless</span> <span class=\"title class_\">WeChat::Util::CodeV3</span>.new(wechat_pay_public_key).verify([wechat_timestamp, wechat_pay_nonce, body], wechat_pay_signature)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> render <span class=\"symbol\">json:</span> ......, <span class=\"symbol\">status:</span> <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 3. 解密请求主体中的订单信息并验证</span></span><br><span class=\"line\">    nonce = params[<span class=\"string\">&quot;resource&quot;</span>][<span class=\"string\">&quot;nonce&quot;</span>]</span><br><span class=\"line\">    aad = params[<span class=\"string\">&quot;resource&quot;</span>][<span class=\"string\">&quot;associated_data&quot;</span>]</span><br><span class=\"line\">    cipher_text = params[<span class=\"string\">&quot;resource&quot;</span>][<span class=\"string\">&quot;ciphertext&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    decode_str = WeChat::Util::Certificate.send(<span class=\"symbol\">:aead_decode</span>, WeChat::<span class=\"variable constant_\">API_V3_SECRET</span>, nonce, aad, Base64.decode64(cipher_text))</span><br><span class=\"line\"></span><br><span class=\"line\">    res = <span class=\"variable constant_\">JSON</span>.parse(decode_str)</span><br><span class=\"line\"></span><br><span class=\"line\">    order = Order.find_by_out_trade_no(res[<span class=\"string\">&quot;out_trade_no&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unless</span> order.total_fee == res[<span class=\"string\">&quot;amount&quot;</span>][<span class=\"string\">&quot;total&quot;</span>]</span><br><span class=\"line\">      <span class=\"keyword\">return</span> render <span class=\"symbol\">json:</span> ..., <span class=\"symbol\">status:</span> <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unless</span> WeChat::ServiceV3::AppID == res[<span class=\"string\">&#x27;appid&#x27;</span>]</span><br><span class=\"line\">      <span class=\"keyword\">return</span> render <span class=\"symbol\">json:</span> ..., <span class=\"symbol\">status:</span> <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unless</span> WeChat::ServiceV3::MchID == res[<span class=\"string\">&#x27;mchid&#x27;</span>]</span><br><span class=\"line\">      <span class=\"keyword\">return</span> render <span class=\"symbol\">json:</span> ..., <span class=\"symbol\">status:</span> <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 发货处理</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    render <span class=\"symbol\">json:</span> &#123;<span class=\"string\">&#x27;code&#x27;</span>: <span class=\"string\">&quot;SUCCESS&quot;</span>, <span class=\"string\">&#x27;message&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">rescue</span> ActiveRecord::StaleObjectError</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render <span class=\"symbol\">json:</span> ..., <span class=\"symbol\">status:</span> <span class=\"number\">400</span></span><br><span class=\"line\">  <span class=\"keyword\">rescue</span> WeChat::Util::CertificateNotFound</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render <span class=\"symbol\">json:</span> ..., <span class=\"symbol\">status:</span> <span class=\"number\">400</span></span><br><span class=\"line\">  <span class=\"keyword\">rescue</span> StandardError =&gt; e</span><br><span class=\"line\">    logger.error <span class=\"string\">&quot;<span class=\"subst\">#&#123;e.full_message&#125;</span>&quot;</span></span><br><span class=\"line\">    render <span class=\"symbol\">json:</span> ..., <span class=\"symbol\">status:</span> <span class=\"number\">500</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>几乎就是纯面向过程编程……代码中有些诸如 <code>xx.send</code> 的东西大家就当没看见好了_(:з」∠)_（蒙混过关）……</p>\n<h1 id=\"6-结语\"><a href=\"#6-结语\" class=\"headerlink\" title=\"6. 结语\"></a>6. 结语</h1><p>至此我们就完成了基础的微信支付中所涉及到的大部分问题，个人感觉微信支付升级到V3之后确实要简单了不少。<del>即便如此每次接入一个新的云服务的时候都感觉是被按在地上补密码学……</del></p>\n<p>对于文中的叙述有不同意见可以在评论区与我讨论，如果觉得这篇文章对您有用不妨给我一个赞~最后祝大家都能光速接入微信支付。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"0-写在前面\"><a href=\"#0-写在前面\" class=\"headerlink\" title=\"0. 写在前面\"></a>0. 写在前面</h1><p>其实公司项目早在去年就做完第一版的微信支付了，但是由于种种原因并没有上线，一直拖到了今年。</p>\n<p>让人 *疼 的一件事情是，虽然基础功能都已经实现了，代码也有了，但是考虑微信支付更新了V3版本，以及反正产品还没有正式上微信支付，公司最终决定直接接入V3版本的微信支付，之前的代码基本上没法儿再用了。</p>\n<p>另外 <code>Ruby</code> 这个没人疼没人爱的孩子又着实可怜的不行，V2版本的微信支付还可以参考使用社区姜老师(<code>@jasl</code>)的 <a href=\"https://github.com/jasl/wx_pay\">微信支付GEM</a>，V3版本干脆就没有可以参考的 <code>Ruby</code> 代码了。</p>\n<p>好就好在V3开始的微信支付相对之前的V2要简单许多，以及相关的文档也比较完整，本文主要提供一些代码参考，以及分享一些接入途中遇到的坑。</p>\n<h1 id=\"1-需要准备什么？\"><a href=\"#1-需要准备什么？\" class=\"headerlink\" title=\"1. 需要准备什么？\"></a>1. 需要准备什么？</h1><p>接入云服务通常来说都需要准备一系列的各种 <code>公钥 私钥 证书 APPID APPSECRET</code> 等乱七八糟的东西，此处进行简单的列举，详细的申请步骤可以参考 <a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_1.shtml\">《微信支付接入前准备》</a> 一文，相对来说已经描述的比较清晰了。</p>\n<p>直接放代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在申请微信支付时由平台分配的开发者ID</span></span><br><span class=\"line\"><span class=\"variable constant_\">APPID</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:appid</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在申请微信支付时的收款账号</span></span><br><span class=\"line\"><span class=\"variable constant_\">MCHID</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:mch_id</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 微信支付 API V3 平台公钥，将用在回调验签中</span></span><br><span class=\"line\"><span class=\"variable constant_\">API_V3_SECRET</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:api_v3_secret</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 微信支付相关接口域名</span></span><br><span class=\"line\"><span class=\"variable constant_\">DOMAIN</span> = <span class=\"string\">&#x27;https://api.mch.weixin.qq.com&#x27;</span>.freeze</span><br></pre></td></tr></table></figure>\n\n<p>以上几个参数是可以直接在后台拿到的（大概……），在后台进行支付申请的时候应该还有一组证书文件需要下载，下载后解压大概长这样：</p>\n<p><img src=\"https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609125555-image.png\" alt=\"图片\"></p>\n<p>此时我们需要获取证书的序列号，该序列号会被用在签名里。</p>\n<p>如何查看证书序列号，可以查看 <a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay7_0.shtml#part-5\">《微信支付 - 如何查看证书序列号》</a> 一文，在终端中利用 <code>OpenSSL</code> 可以很轻松的拿到。</p>\n<p>如果你不方便使用终端，可以尝试使用如下的 <code>Ruby</code> 代码获取（其实也是一样的）：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;openssl&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">puts <span class=\"title class_\">OpenSSL::X509::Certificate</span>.new(open(your_cert_file_path).read).serial.to_s(<span class=\"number\">16</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意此处 <code>OpenSSL::X509::Certificate#serial.to_s</code> 得到的是一个十进制的值，而微信支付方统一使用的是十六进制的，因此我们传递了参数将其转为16进制。</p>\n</blockquote>\n<p>由于证书会放在服务器上，该序列号是不会变更的，所以可以直接写入 <code>credentials</code> 里</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">SERIAL_NO</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:serial_no</span>]</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们准备好了所有的参数。</p>\n<h1 id=\"2-签名\"><a href=\"#2-签名\" class=\"headerlink\" title=\"2. 签名\"></a>2. 签名</h1><p>云服务为了保证通讯的双方合法，通常会使用签名的方式来进行验证，我们请求任何一个微信支付方的接口时都需要进行签名并将签名置于请求头中。</p>\n<p>关于签名与验签的详细说明请翻阅微信支付文档：</p>\n<p><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_0.shtml\">《微信支付 - 签名生成》</a></p>\n<p><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml\">《微信支付 - 签名验证》</a></p>\n<p>其中签名用于向微信支付发起请求，验签用于验证支付回调是否来自于微信支付。</p>\n<p>以下是参考代码，我将签名与验证签名的两个方法封装在了同一个类中：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;openssl&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;base64&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Signature</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">initialize</span>(<span class=\"params\">private_key = open(your_apiclient_key.pem_path</span>).read)</span><br><span class=\"line\">    <span class=\"variable\">@private_key</span> = private_key</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">sign</span>(<span class=\"params\">*params</span>)</span><br><span class=\"line\">    str = params.push(<span class=\"string\">&#x27;&#x27;</span>).join(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">    pkey = <span class=\"title class_\">OpenSSL::PKey::RSA</span>.new(<span class=\"variable\">@private_key</span>)</span><br><span class=\"line\">    digest = OpenSSL::Digest::<span class=\"variable constant_\">SHA256</span>.new</span><br><span class=\"line\">    signature = pkey.sign(digest, str)</span><br><span class=\"line\">    Base64.strict_encode64(signature)</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">verify</span>(<span class=\"params\">params = [], sign</span>)</span><br><span class=\"line\">    str = params.push(<span class=\"string\">&#x27;&#x27;</span>).join(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">    pkey = <span class=\"title class_\">OpenSSL::PKey::RSA</span>.new(<span class=\"variable\">@private_key</span>)</span><br><span class=\"line\">    digest = OpenSSL::Digest::<span class=\"variable constant_\">SHA256</span>.new</span><br><span class=\"line\">    pkey.verify(digest, Base64.decode64(sign), str)</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>此处的构造函数中传入了一个动态的证书是因为：</p>\n<p><strong>签名与验签需要使用不同的证书！</strong></p>\n<p><strong>签名与验签需要使用不同的证书！</strong></p>\n<p><strong>签名与验签需要使用不同的证书！</strong></p>\n<p>重要的事情我说了三遍了_(:з」∠)_，以下是 <a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml\">微信支付 - 签名验证</a> 的截图：</p>\n<p><img src=\"https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609126710-image.png\" alt=\"图片\"></p>\n<h1 id=\"3-封装请求\"><a href=\"#3-封装请求\" class=\"headerlink\" title=\"3. 封装请求\"></a>3. 封装请求</h1><p>完成签名后我们可以开始尝试接入微信支付的相关API了，按照以往的惯例我们会把这些请求做一个简单的封装，例如统一下单接口（代码写的有点丑，别打我_(:з」∠)_）：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Service</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"variable constant_\">DOMAIN</span> = <span class=\"string\">&#x27;https://api.mch.weixin.qq.com&#x27;</span>.freeze</span><br><span class=\"line\">  <span class=\"variable constant_\">APPID</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:appid</span>]</span><br><span class=\"line\">  <span class=\"variable constant_\">MCHID</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:mch_id</span>]</span><br><span class=\"line\">  <span class=\"variable constant_\">SERIAL_NO</span> = Rails.application.credentials[<span class=\"symbol\">:wx_pay</span>][<span class=\"symbol\">:serial_no</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># * app支付接口</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">self</span>.transactions_app(order_info)</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\"># * 构造请求参数</span></span><br><span class=\"line\">    method = <span class=\"string\">&#x27;POST&#x27;</span>.freeze</span><br><span class=\"line\">    url = <span class=\"string\">&#x27;/v3/pay/transactions/app&#x27;</span>.freeze</span><br><span class=\"line\">    timestamp = order_info[<span class=\"symbol\">:timestamp</span>]</span><br><span class=\"line\">    nonce_str = order_info[<span class=\"symbol\">:nonce_str</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    body = &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;appid&quot;</span>: <span class=\"variable constant_\">APPID</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;mchid&quot;</span>: <span class=\"variable constant_\">MCHID</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;description&quot;</span>: order_info[<span class=\"symbol\">:description</span>],</span><br><span class=\"line\">      <span class=\"string\">&quot;out_trade_no&quot;</span>: order_info[<span class=\"symbol\">:out_trade_no</span>],</span><br><span class=\"line\">      <span class=\"string\">&quot;notify_url&quot;</span>: your_notify_url,</span><br><span class=\"line\">      <span class=\"string\">&quot;amount&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;total&quot;</span>: order_info[<span class=\"symbol\">:amount</span>]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 构造签名</span></span><br><span class=\"line\">    signature = WeChat::Util::CodeV3.new.sign(method, url, timestamp, nonce_str, body.to_json)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 构造请求头</span></span><br><span class=\"line\">    authorization_str = <span class=\"string\">&#x27;WECHATPAY2-SHA256-RSA2048 &#x27;</span> + <span class=\"string\">&quot;mchid=\\&quot;&quot;</span> + <span class=\"variable constant_\">MCHIDMCHID</span> + <span class=\"string\">&quot;\\&quot;,&quot;</span> + <span class=\"string\">&quot;nonce_str=\\&quot;&quot;</span> + nonce_str + <span class=\"string\">&quot;\\&quot;,&quot;</span> + <span class=\"string\">&quot;timestamp=\\&quot;&quot;</span> + timestamp.to_s + <span class=\"string\">&quot;\\&quot;,&quot;</span> + <span class=\"string\">&quot;serial_no=\\&quot;&quot;</span> + <span class=\"variable constant_\">SERIAL_NO</span> + <span class=\"string\">&quot;\\&quot;,&quot;</span> + <span class=\"string\">&quot;signature=\\&quot;&quot;</span> + signature + <span class=\"string\">&quot;\\&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 发送请求</span></span><br><span class=\"line\">    response = RestClient.post(<span class=\"variable constant_\">DOMAIN</span> + url, body.to_json, headers = &#123;</span><br><span class=\"line\">      <span class=\"string\">&quot;Content-Type&quot;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;Accept&quot;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;Authorization&quot;</span>: authorization_str</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"variable constant_\">JSON</span>.parse(response.body)</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-获取平台证书\"><a href=\"#4-获取平台证书\" class=\"headerlink\" title=\"4. 获取平台证书\"></a>4. 获取平台证书</h1><p>在一个完整的支付环节中，正确的向微信支付发送请求是第一步，第二步我们需要对响应进行验证以确保请求确实来自于微信支付方。</p>\n<p>无论是验证响应，还是后续的微信支付回调通知，都需要使用相同的方法对签名进行验证。虽然相关的算法在前面已经实现了，但由于用于验签的证书与签名所使用的的证书是不一样的，因此需要提前准备证书。</p>\n<p>微信支付平台证书是动态的，每隔一段时间会进行替换以确保安全性。因此需要通过接口拉取证书。</p>\n<p><a href=\"http://192.168.31.72:3000/docs/index.html#/Order/post_v5_orders_huawei_pay_purchases_verify\">《微信支付 - 获取平台证书列表》</a></p>\n<p>发送请求与前面的其他接口一样，只要按照文档进行签名等既可，没什么需要讲的。此处主要走一下拉取到证书后的流程。</p>\n<p>获取平台证书列表返回的响应中，平台证书是经过加密的，要获取证书首先需要进行解密操作。</p>\n<p><a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_2.shtml\">《微信支付 - 证书和回调版本解密》</a></p>\n<p>微信支付对证书加密使用的是 <code>AEAD_AES_256_GCM</code> 加密算法，虽然在 <code>Ruby</code> 文档中找到了对应的标准库方法，但其实现细节似乎与微信支付给出的参数有些区别导致没有解密成功。</p>\n<blockquote>\n<p>解释：<br>在<a href=\"https://ruby-doc.org/stdlib-3.0.0/libdoc/openssl/rdoc/OpenSSL/Cipher.html\">标准库文档</a>中，找到了 <code>AES-128-GCM</code> 相关内容：<br><img src=\"https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609135747-image.png\" alt=\"图片\"><br>但让人疑惑的是微信支付返回的参数中的并没有解密需要的 <code>auth_tag</code> 。<br>如果有了解 <code>AEAD</code> 算法的朋友麻烦在评论区赐教解释一下_(:з」∠)_</p>\n</blockquote>\n<p>最终找到了一个 <a href=\"https://github.com/onelogin/aead\">AEAD - GEM</a>，引入到工程后发现不能正常工作，查阅相关 <a href=\"https://github.com/onelogin/aead/issues/8\">issue</a> 找到了末尾的建议：</p>\n<p><img src=\"https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609136215-image.png\" alt=\"图片\"></p>\n<p><img src=\"https://assets-blog-xiongyuchi.oss-cn-beijing.aliyuncs.com/uploads/production/blog_photos/48/1609136227-image.png\" alt=\"图片\"></p>\n<p>也就是说如果要使用该 <code>GEM</code> ，我们需要添加的是由 <code>shopify</code> 修改过的版本，查看 <code>repo</code> 发现后者是由 <code>shopify</code> <code>fork</code> 后修改过的版本，如果不放心的话可以把代码 <code>clone</code> 部署到私有云上……<code>Gemfile</code> 里指定自己的私有云 <code>repo</code> 地址既可。</p>\n<p>而后我们对证书进行解密既可：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;aead&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">self</span>.aead_decode(key, nonce, aad, cipher_text)</span><br><span class=\"line\">  mode = <span class=\"variable constant_\">AEAD</span><span class=\"symbol\">:</span><span class=\"symbol\">:Cipher</span>.new(<span class=\"string\">&#x27;AES-256-GCM&#x27;</span>)</span><br><span class=\"line\">  cipher = mode.new(key)</span><br><span class=\"line\">  cipher.decrypt(nonce, aad, cipher_text)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>证书虽然每隔一段时间会更新，但并不需要每次都需要拉取，根据 <a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay5_0.shtml\">《微信支付 - 平台证书更新指引》</a> 的建议，此处我们在每次进行验签前，先将本地已经存储的证书序列号与 微信响应&#x2F;回调请求 中声明的证书序列号做对比，当本次响应&#x2F;请求使用的证书与本地不符时，才拉取最新的证书并持久化到本地，最终实现惰性更新。以下是参考代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fetch</span>(<span class=\"params\">serial</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 1. 通过serial序列号查找本地是否存在响应的证书，如果有，将证书实例返回</span></span><br><span class=\"line\">  ... </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">OpenSSL::X509::Certificate</span>.new(open(cert_file_name).read) <span class=\"keyword\">if</span> File.exists? cert_file_name</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 2. 本地不存在时，请求接口拉取当前最新的证书列表</span></span><br><span class=\"line\">  cert_list = WeChat::Service.certificates</span><br><span class=\"line\">  cert = cert_list[<span class=\"symbol\">:body</span>][<span class=\"string\">&#x27;data&#x27;</span>].select&#123;|<span class=\"params\">cert</span>| cert[<span class=\"string\">&#x27;serial_no&#x27;</span>] == serial &#125;[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span> <span class=\"keyword\">if</span> cert.<span class=\"literal\">nil</span>?</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 3. 对证书进行解密</span></span><br><span class=\"line\">  plaintext = aead_decode(<span class=\"variable constant_\">API_V3_SECRET</span>,</span><br><span class=\"line\">                          cert[<span class=\"string\">&#x27;encrypt_certificate&#x27;</span>][<span class=\"string\">&#x27;nonce&#x27;</span>],</span><br><span class=\"line\">                          cert[<span class=\"string\">&#x27;encrypt_certificate&#x27;</span>][<span class=\"string\">&#x27;associated_data&#x27;</span>],</span><br><span class=\"line\">                          Base64.decode64(cert[<span class=\"string\">&#x27;encrypt_certificate&#x27;</span>][<span class=\"string\">&#x27;ciphertext&#x27;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 4. 将证书持久化到本地并返回证书实例</span></span><br><span class=\"line\">  file = File.open(cert_file_name, <span class=\"string\">&#x27;a+&#x27;</span>)</span><br><span class=\"line\">  file&amp;.syswrite(plaintext)</span><br><span class=\"line\">  <span class=\"title class_\">OpenSSL::X509::Certificate</span>.new open(cert_file_name).read</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-对回调请求、响应进行验签\"><a href=\"#5-对回调请求、响应进行验签\" class=\"headerlink\" title=\"5. 对回调请求、响应进行验签\"></a>5. 对回调请求、响应进行验签</h1><p>验证签名比较简单，根据 <a href=\"https://pay.weixin.qq.com/wiki/doc/apiv3/wechatpay/wechatpay4_1.shtml\">《微信支付 - 签名验证》</a> 的指引，我们需要对 响应&#x2F;回调请求 进行如下验证：</p>\n<ul>\n<li>检验微信支付方使用的证书</li>\n<li>使用微信支付证书中的公钥验证签名</li>\n<li>解密响应报文，获取响应数据</li>\n<li>验证订单数据</li>\n</ul>\n<p>此处有一个不得不提的坑是在验证签名时应使用 <strong>请求报文的原文</strong> ，在 <code>Rails</code> 中可以通过如下方法获取：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.raw_post</span><br></pre></td></tr></table></figure>\n\n<p>以下使用异步回调通知进行示例（示例中删除了部分业务代码）：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># frozen_string_literal: true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;pay/wechat/wechat&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;pay/wechat/util&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WechatController</span> &lt; <span class=\"title class_ inherited__\">ApplicationController</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># * 微信支付后的回调接口</span></span><br><span class=\"line\">  <span class=\"keyword\">def</span> <span class=\"title function_\">pay_notify</span></span><br><span class=\"line\"></span><br><span class=\"line\">    wechat_pay_serial = request.headers[<span class=\"string\">&#x27;Wechatpay-Serial&#x27;</span>]</span><br><span class=\"line\">    wechat_timestamp = request.headers[<span class=\"string\">&#x27;Wechatpay-Timestamp&#x27;</span>]</span><br><span class=\"line\">    wechat_pay_signature = request.headers[<span class=\"string\">&#x27;Wechatpay-Signature&#x27;</span>]</span><br><span class=\"line\">    wechat_pay_nonce = request.headers[<span class=\"string\">&#x27;Wechatpay-Nonce&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 获取请求体原文</span></span><br><span class=\"line\">    body = request.raw_post</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 1. 验证微信平台证书与当前持有的证书是否相同</span></span><br><span class=\"line\">    <span class=\"comment\">#    当微信平台证书序列号与本地证书序列号不相同时，应答错误信息，等待下一次回调</span></span><br><span class=\"line\">    <span class=\"keyword\">unless</span> WeChat::Util::ResultVerify.new.serial_verify?(wechat_pay_serial)</span><br><span class=\"line\">      raise ......</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 2. 验证回调签名</span></span><br><span class=\"line\">    <span class=\"comment\">#    获取微信平台证书公钥并进行签名验证</span></span><br><span class=\"line\">    wechat_pay_public_key = WeChat::Util::Certificate.get(wechat_pay_serial).public_key.to_pem</span><br><span class=\"line\">    <span class=\"keyword\">unless</span> <span class=\"title class_\">WeChat::Util::CodeV3</span>.new(wechat_pay_public_key).verify([wechat_timestamp, wechat_pay_nonce, body], wechat_pay_signature)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> render <span class=\"symbol\">json:</span> ......, <span class=\"symbol\">status:</span> <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 3. 解密请求主体中的订单信息并验证</span></span><br><span class=\"line\">    nonce = params[<span class=\"string\">&quot;resource&quot;</span>][<span class=\"string\">&quot;nonce&quot;</span>]</span><br><span class=\"line\">    aad = params[<span class=\"string\">&quot;resource&quot;</span>][<span class=\"string\">&quot;associated_data&quot;</span>]</span><br><span class=\"line\">    cipher_text = params[<span class=\"string\">&quot;resource&quot;</span>][<span class=\"string\">&quot;ciphertext&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    decode_str = WeChat::Util::Certificate.send(<span class=\"symbol\">:aead_decode</span>, WeChat::<span class=\"variable constant_\">API_V3_SECRET</span>, nonce, aad, Base64.decode64(cipher_text))</span><br><span class=\"line\"></span><br><span class=\"line\">    res = <span class=\"variable constant_\">JSON</span>.parse(decode_str)</span><br><span class=\"line\"></span><br><span class=\"line\">    order = Order.find_by_out_trade_no(res[<span class=\"string\">&quot;out_trade_no&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unless</span> order.total_fee == res[<span class=\"string\">&quot;amount&quot;</span>][<span class=\"string\">&quot;total&quot;</span>]</span><br><span class=\"line\">      <span class=\"keyword\">return</span> render <span class=\"symbol\">json:</span> ..., <span class=\"symbol\">status:</span> <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unless</span> WeChat::ServiceV3::AppID == res[<span class=\"string\">&#x27;appid&#x27;</span>]</span><br><span class=\"line\">      <span class=\"keyword\">return</span> render <span class=\"symbol\">json:</span> ..., <span class=\"symbol\">status:</span> <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">unless</span> WeChat::ServiceV3::MchID == res[<span class=\"string\">&#x27;mchid&#x27;</span>]</span><br><span class=\"line\">      <span class=\"keyword\">return</span> render <span class=\"symbol\">json:</span> ..., <span class=\"symbol\">status:</span> <span class=\"number\">400</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 发货处理</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    render <span class=\"symbol\">json:</span> &#123;<span class=\"string\">&#x27;code&#x27;</span>: <span class=\"string\">&quot;SUCCESS&quot;</span>, <span class=\"string\">&#x27;message&#x27;</span>: <span class=\"string\">&#x27;&#x27;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">rescue</span> ActiveRecord::StaleObjectError</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render <span class=\"symbol\">json:</span> ..., <span class=\"symbol\">status:</span> <span class=\"number\">400</span></span><br><span class=\"line\">  <span class=\"keyword\">rescue</span> WeChat::Util::CertificateNotFound</span><br><span class=\"line\">    <span class=\"keyword\">return</span> render <span class=\"symbol\">json:</span> ..., <span class=\"symbol\">status:</span> <span class=\"number\">400</span></span><br><span class=\"line\">  <span class=\"keyword\">rescue</span> StandardError =&gt; e</span><br><span class=\"line\">    logger.error <span class=\"string\">&quot;<span class=\"subst\">#&#123;e.full_message&#125;</span>&quot;</span></span><br><span class=\"line\">    render <span class=\"symbol\">json:</span> ..., <span class=\"symbol\">status:</span> <span class=\"number\">500</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p>几乎就是纯面向过程编程……代码中有些诸如 <code>xx.send</code> 的东西大家就当没看见好了_(:з」∠)_（蒙混过关）……</p>\n<h1 id=\"6-结语\"><a href=\"#6-结语\" class=\"headerlink\" title=\"6. 结语\"></a>6. 结语</h1><p>至此我们就完成了基础的微信支付中所涉及到的大部分问题，个人感觉微信支付升级到V3之后确实要简单了不少。<del>即便如此每次接入一个新的云服务的时候都感觉是被按在地上补密码学……</del></p>\n<p>对于文中的叙述有不同意见可以在评论区与我讨论，如果觉得这篇文章对您有用不妨给我一个赞~最后祝大家都能光速接入微信支付。</p>\n"},{"_content":"# 在Rails里使用MongoDB\n\n## 1. 写在前面\n我逛`ruby china`的时候发现很多前辈12年左右就开始用`Rails + MongoDB`的组合了，但当我终于有一天要用到时候居然没有找到一篇教程= =！\n\n我本来以为就和之前把`PostgreSQL`替换成`MySQL`差不多，装个驱动，然后`database.yml`配置改一下就可以用了，结果发现`Active Record`居然没支持`MongoDB`……\n\n然后今天装服务器环境，下载比较慢，正好有点时间，遂写下这篇教程。\n\n## 2. 安装依赖\n依赖的话，就两个，一个是驱动，一个是`ORM`层，用来替换`Active Record`的。不过由于`MongoDB`是面向文档的数据库，所以这里更准确的名字叫`ODM`（对象文档映射）。\n\n版本的话自己对照文档找合适的即可。\n~~~ruby\ngem 'mongo', '~> 2.12', '>= 2.12.1'\ngem 'mongoid', '~> 7.1', '>= 7.1.2'\n~~~\n\n## 3. 生成配置文件 & 修改 ORM 配置\n安装完成之后需要生成`MongoDB`的配置文件：\n~~~ shell\nrails g mongoid:config\n~~~\n执行过之后你会在你的`config`目录下看到一个`mongoid.yml`文件，打开之后就按照属性名和注释修改即可。\n\n到这里其实已经可以使用了，当我们使用脚手架生成`rails g model XXX attr1:string attr2:integer`时会发现新生成的`model`文件是不太一样的，它大概就像下面这样：\n~~~ruby\nclass User\n  include Mongoid::Document\n  include Mongoid::Timestamps\n\n  field :uuid, type: String\n  field :account, type: String\n  field :user_name, type: String\n  field :password_hash, type: String\n  field :email, type: String\n  field :is_admin, type: Mongoid::Boolean\nend\n~~~\n不过实测当你运行`rails db:seed`等命令的时候，`Rails`还是会去找`Active Record`。因此你还需要在`config/appliction.rb`文件中添加如下代码：\n~~~ruby\nconfig.generators do |g|\n    g.orm :mongoid\nend\n~~~\n然后就可以正常使用了。\n\n## 4. 最后\n试用了两天`MongoDB`体验还是相当好的，`mongoid`几乎就和`Active Record`一样，所以应用层的代码几乎没有太大的变化。\n\n异常捕获需要根据实际情况替换成`Mongoid`模块下的异常。属性的话，`mongoid`似乎会把`_id`和`id`当成同一个东西，因此如果需要一个单独维护的`id`的话，建议还是起其它名字比较好。\n\n最后就是`MongoDB`到底是`NoSQL`，头一次在`Rails`里没有一条`migrate`文件，还真有点不习惯……","source":"_posts/在Rails里使用MongoDB.md","raw":"# 在Rails里使用MongoDB\n\n## 1. 写在前面\n我逛`ruby china`的时候发现很多前辈12年左右就开始用`Rails + MongoDB`的组合了，但当我终于有一天要用到时候居然没有找到一篇教程= =！\n\n我本来以为就和之前把`PostgreSQL`替换成`MySQL`差不多，装个驱动，然后`database.yml`配置改一下就可以用了，结果发现`Active Record`居然没支持`MongoDB`……\n\n然后今天装服务器环境，下载比较慢，正好有点时间，遂写下这篇教程。\n\n## 2. 安装依赖\n依赖的话，就两个，一个是驱动，一个是`ORM`层，用来替换`Active Record`的。不过由于`MongoDB`是面向文档的数据库，所以这里更准确的名字叫`ODM`（对象文档映射）。\n\n版本的话自己对照文档找合适的即可。\n~~~ruby\ngem 'mongo', '~> 2.12', '>= 2.12.1'\ngem 'mongoid', '~> 7.1', '>= 7.1.2'\n~~~\n\n## 3. 生成配置文件 & 修改 ORM 配置\n安装完成之后需要生成`MongoDB`的配置文件：\n~~~ shell\nrails g mongoid:config\n~~~\n执行过之后你会在你的`config`目录下看到一个`mongoid.yml`文件，打开之后就按照属性名和注释修改即可。\n\n到这里其实已经可以使用了，当我们使用脚手架生成`rails g model XXX attr1:string attr2:integer`时会发现新生成的`model`文件是不太一样的，它大概就像下面这样：\n~~~ruby\nclass User\n  include Mongoid::Document\n  include Mongoid::Timestamps\n\n  field :uuid, type: String\n  field :account, type: String\n  field :user_name, type: String\n  field :password_hash, type: String\n  field :email, type: String\n  field :is_admin, type: Mongoid::Boolean\nend\n~~~\n不过实测当你运行`rails db:seed`等命令的时候，`Rails`还是会去找`Active Record`。因此你还需要在`config/appliction.rb`文件中添加如下代码：\n~~~ruby\nconfig.generators do |g|\n    g.orm :mongoid\nend\n~~~\n然后就可以正常使用了。\n\n## 4. 最后\n试用了两天`MongoDB`体验还是相当好的，`mongoid`几乎就和`Active Record`一样，所以应用层的代码几乎没有太大的变化。\n\n异常捕获需要根据实际情况替换成`Mongoid`模块下的异常。属性的话，`mongoid`似乎会把`_id`和`id`当成同一个东西，因此如果需要一个单独维护的`id`的话，建议还是起其它名字比较好。\n\n最后就是`MongoDB`到底是`NoSQL`，头一次在`Rails`里没有一条`migrate`文件，还真有点不习惯……","slug":"在Rails里使用MongoDB","published":1,"date":"2022-05-03T08:46:25.152Z","updated":"2022-05-03T08:46:25.152Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdun002hr2ve4csi21t1","content":"<h1 id=\"在Rails里使用MongoDB\"><a href=\"#在Rails里使用MongoDB\" class=\"headerlink\" title=\"在Rails里使用MongoDB\"></a>在Rails里使用MongoDB</h1><h2 id=\"1-写在前面\"><a href=\"#1-写在前面\" class=\"headerlink\" title=\"1. 写在前面\"></a>1. 写在前面</h2><p>我逛<code>ruby china</code>的时候发现很多前辈12年左右就开始用<code>Rails + MongoDB</code>的组合了，但当我终于有一天要用到时候居然没有找到一篇教程&#x3D; &#x3D;！</p>\n<p>我本来以为就和之前把<code>PostgreSQL</code>替换成<code>MySQL</code>差不多，装个驱动，然后<code>database.yml</code>配置改一下就可以用了，结果发现<code>Active Record</code>居然没支持<code>MongoDB</code>……</p>\n<p>然后今天装服务器环境，下载比较慢，正好有点时间，遂写下这篇教程。</p>\n<h2 id=\"2-安装依赖\"><a href=\"#2-安装依赖\" class=\"headerlink\" title=\"2. 安装依赖\"></a>2. 安装依赖</h2><p>依赖的话，就两个，一个是驱动，一个是<code>ORM</code>层，用来替换<code>Active Record</code>的。不过由于<code>MongoDB</code>是面向文档的数据库，所以这里更准确的名字叫<code>ODM</code>（对象文档映射）。</p>\n<p>版本的话自己对照文档找合适的即可。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem <span class=\"string\">&#x27;mongo&#x27;</span>, <span class=\"string\">&#x27;~&gt; 2.12&#x27;</span>, <span class=\"string\">&#x27;&gt;= 2.12.1&#x27;</span></span><br><span class=\"line\">gem <span class=\"string\">&#x27;mongoid&#x27;</span>, <span class=\"string\">&#x27;~&gt; 7.1&#x27;</span>, <span class=\"string\">&#x27;&gt;= 7.1.2&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-生成配置文件-amp-修改-ORM-配置\"><a href=\"#3-生成配置文件-amp-修改-ORM-配置\" class=\"headerlink\" title=\"3. 生成配置文件 &amp; 修改 ORM 配置\"></a>3. 生成配置文件 &amp; 修改 ORM 配置</h2><p>安装完成之后需要生成<code>MongoDB</code>的配置文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rails g mongoid:config</span><br></pre></td></tr></table></figure>\n<p>执行过之后你会在你的<code>config</code>目录下看到一个<code>mongoid.yml</code>文件，打开之后就按照属性名和注释修改即可。</p>\n<p>到这里其实已经可以使用了，当我们使用脚手架生成<code>rails g model XXX attr1:string attr2:integer</code>时会发现新生成的<code>model</code>文件是不太一样的，它大概就像下面这样：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span></span><br><span class=\"line\">  <span class=\"keyword\">include</span> Mongoid::Document</span><br><span class=\"line\">  <span class=\"keyword\">include</span> Mongoid::Timestamps</span><br><span class=\"line\"></span><br><span class=\"line\">  field <span class=\"symbol\">:uuid</span>, <span class=\"symbol\">type:</span> String</span><br><span class=\"line\">  field <span class=\"symbol\">:account</span>, <span class=\"symbol\">type:</span> String</span><br><span class=\"line\">  field <span class=\"symbol\">:user_name</span>, <span class=\"symbol\">type:</span> String</span><br><span class=\"line\">  field <span class=\"symbol\">:password_hash</span>, <span class=\"symbol\">type:</span> String</span><br><span class=\"line\">  field <span class=\"symbol\">:email</span>, <span class=\"symbol\">type:</span> String</span><br><span class=\"line\">  field <span class=\"symbol\">:is_admin</span>, <span class=\"symbol\">type:</span> Mongoid::Boolean</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>不过实测当你运行<code>rails db:seed</code>等命令的时候，<code>Rails</code>还是会去找<code>Active Record</code>。因此你还需要在<code>config/appliction.rb</code>文件中添加如下代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.generators <span class=\"keyword\">do</span> |<span class=\"params\">g</span>|</span><br><span class=\"line\">    g.orm <span class=\"symbol\">:mongoid</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>然后就可以正常使用了。</p>\n<h2 id=\"4-最后\"><a href=\"#4-最后\" class=\"headerlink\" title=\"4. 最后\"></a>4. 最后</h2><p>试用了两天<code>MongoDB</code>体验还是相当好的，<code>mongoid</code>几乎就和<code>Active Record</code>一样，所以应用层的代码几乎没有太大的变化。</p>\n<p>异常捕获需要根据实际情况替换成<code>Mongoid</code>模块下的异常。属性的话，<code>mongoid</code>似乎会把<code>_id</code>和<code>id</code>当成同一个东西，因此如果需要一个单独维护的<code>id</code>的话，建议还是起其它名字比较好。</p>\n<p>最后就是<code>MongoDB</code>到底是<code>NoSQL</code>，头一次在<code>Rails</code>里没有一条<code>migrate</code>文件，还真有点不习惯……</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"在Rails里使用MongoDB\"><a href=\"#在Rails里使用MongoDB\" class=\"headerlink\" title=\"在Rails里使用MongoDB\"></a>在Rails里使用MongoDB</h1><h2 id=\"1-写在前面\"><a href=\"#1-写在前面\" class=\"headerlink\" title=\"1. 写在前面\"></a>1. 写在前面</h2><p>我逛<code>ruby china</code>的时候发现很多前辈12年左右就开始用<code>Rails + MongoDB</code>的组合了，但当我终于有一天要用到时候居然没有找到一篇教程&#x3D; &#x3D;！</p>\n<p>我本来以为就和之前把<code>PostgreSQL</code>替换成<code>MySQL</code>差不多，装个驱动，然后<code>database.yml</code>配置改一下就可以用了，结果发现<code>Active Record</code>居然没支持<code>MongoDB</code>……</p>\n<p>然后今天装服务器环境，下载比较慢，正好有点时间，遂写下这篇教程。</p>\n<h2 id=\"2-安装依赖\"><a href=\"#2-安装依赖\" class=\"headerlink\" title=\"2. 安装依赖\"></a>2. 安装依赖</h2><p>依赖的话，就两个，一个是驱动，一个是<code>ORM</code>层，用来替换<code>Active Record</code>的。不过由于<code>MongoDB</code>是面向文档的数据库，所以这里更准确的名字叫<code>ODM</code>（对象文档映射）。</p>\n<p>版本的话自己对照文档找合适的即可。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem <span class=\"string\">&#x27;mongo&#x27;</span>, <span class=\"string\">&#x27;~&gt; 2.12&#x27;</span>, <span class=\"string\">&#x27;&gt;= 2.12.1&#x27;</span></span><br><span class=\"line\">gem <span class=\"string\">&#x27;mongoid&#x27;</span>, <span class=\"string\">&#x27;~&gt; 7.1&#x27;</span>, <span class=\"string\">&#x27;&gt;= 7.1.2&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-生成配置文件-amp-修改-ORM-配置\"><a href=\"#3-生成配置文件-amp-修改-ORM-配置\" class=\"headerlink\" title=\"3. 生成配置文件 &amp; 修改 ORM 配置\"></a>3. 生成配置文件 &amp; 修改 ORM 配置</h2><p>安装完成之后需要生成<code>MongoDB</code>的配置文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rails g mongoid:config</span><br></pre></td></tr></table></figure>\n<p>执行过之后你会在你的<code>config</code>目录下看到一个<code>mongoid.yml</code>文件，打开之后就按照属性名和注释修改即可。</p>\n<p>到这里其实已经可以使用了，当我们使用脚手架生成<code>rails g model XXX attr1:string attr2:integer</code>时会发现新生成的<code>model</code>文件是不太一样的，它大概就像下面这样：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span></span><br><span class=\"line\">  <span class=\"keyword\">include</span> Mongoid::Document</span><br><span class=\"line\">  <span class=\"keyword\">include</span> Mongoid::Timestamps</span><br><span class=\"line\"></span><br><span class=\"line\">  field <span class=\"symbol\">:uuid</span>, <span class=\"symbol\">type:</span> String</span><br><span class=\"line\">  field <span class=\"symbol\">:account</span>, <span class=\"symbol\">type:</span> String</span><br><span class=\"line\">  field <span class=\"symbol\">:user_name</span>, <span class=\"symbol\">type:</span> String</span><br><span class=\"line\">  field <span class=\"symbol\">:password_hash</span>, <span class=\"symbol\">type:</span> String</span><br><span class=\"line\">  field <span class=\"symbol\">:email</span>, <span class=\"symbol\">type:</span> String</span><br><span class=\"line\">  field <span class=\"symbol\">:is_admin</span>, <span class=\"symbol\">type:</span> Mongoid::Boolean</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>不过实测当你运行<code>rails db:seed</code>等命令的时候，<code>Rails</code>还是会去找<code>Active Record</code>。因此你还需要在<code>config/appliction.rb</code>文件中添加如下代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.generators <span class=\"keyword\">do</span> |<span class=\"params\">g</span>|</span><br><span class=\"line\">    g.orm <span class=\"symbol\">:mongoid</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>然后就可以正常使用了。</p>\n<h2 id=\"4-最后\"><a href=\"#4-最后\" class=\"headerlink\" title=\"4. 最后\"></a>4. 最后</h2><p>试用了两天<code>MongoDB</code>体验还是相当好的，<code>mongoid</code>几乎就和<code>Active Record</code>一样，所以应用层的代码几乎没有太大的变化。</p>\n<p>异常捕获需要根据实际情况替换成<code>Mongoid</code>模块下的异常。属性的话，<code>mongoid</code>似乎会把<code>_id</code>和<code>id</code>当成同一个东西，因此如果需要一个单独维护的<code>id</code>的话，建议还是起其它名字比较好。</p>\n<p>最后就是<code>MongoDB</code>到底是<code>NoSQL</code>，头一次在<code>Rails</code>里没有一条<code>migrate</code>文件，还真有点不习惯……</p>\n"},{"title":"小强升职记: 一本被名字耽搁的时间管理宝典","date":"2020-06-17T11:13:41.000Z","_content":"\n## 1. 介绍\n最近读了《小强升职记》一书，不由得感慨：给书起一个好名字太重要！乍一听这名字不由想到什么《杜xx升职记》，瞬间不想读的欲望又增加了。\n\n《小强升职记》是一本以时间管理为主的小故事。整个故事围绕职场老鸟“老付”，和他的下属“小强”展开。小强是一个人间普通社畜，跟我们一样每天苦于应付各种琐碎的工作。而老付则是一个有着明确目标的职场前辈。故事主要讲述了小强在老付的帮助下，慢慢学会时间管理，并终于走向人生正规的故事。\n\n## 2. 启发\n\n### 2.1 为什么要管理自己的时间？\n为了更高效的完成工作任务和学习目标，最终实现自己的梦想。\n\n### 2.2 如何管理自己的时间？\n管理好自己的时间不是一件易事，我们应该先从发现问题开始，然后加以改善。\n\n#### 2.2.1 正视自己的时间观念\n正视自己的时间观念能够让我们发现自身的问题。\n\n**时间黑洞**\n\n持续两周每隔一个小时记录自己正在做的事情，然后分析多少时间是在集中精力处理事件，多少时间是在做无意义的事情，多少时间是在休息。\n\n一定要去做一定要去做一定要去做！重要的话说三遍。当我定期对工作进行总结的时候，很多时候我都不能精确的说出半个月内我在什么事情上花了多少时间。这一度使我在公司进行工作总结的时候非常被动，特别是当这半个月的事情非常琐碎的时候，我必须努力去回忆我做了什么。很多同学觉得自己记忆力很ok就不动笔，真的请千万不要这样做，写个便签占用不了多少时间的。\n\n**时间日志**\n\n持续两周每隔一小时计划下一个小时要做的事情，同时记录上一个小时自己做的事情。\n\n如果说记录自己做的事情是为了正视自己的时间管理能力，那么时间日志就是为了发现问题。\n\n计划一个小时完成的事情，结果花了两个小时；在精力最充沛的时间里做了最次要的事情；无法处理突发事件导致本该完成的事情没有完成……\n\n和上面一样，建议同学们一定要用文档或者纸笔去记录而不是用大脑来记录。每天对时间日志进行整理总结的时候就会发现存在很多处理事情方面的问题。\n\n#### 2.2.2 确定自己的价值观\n每一天开始工作或者学习之前，首先将今天要做的事情都列举出来，并根据重要级别排序。\n\n这里要提到一个很重要的东西就是你的价值观。不同的人看代问题的角度不同，因此他们眼中事件的重要级别也一定不同。如何确定一件事情是否重要，取决于你的价值观。\n\n对于软件开发工程师来说，保证软件的可用性要比保证公司垃圾篓的干净程度重要；反之对于保洁阿姨来说，公司的环境卫生才是最重要的事情。因此必须要确定自己的价值观，才能够依靠价值观来判断哪些事情是重要的，哪些事情不重要。\n\n#### 2.2.3 分类自己的事件\n当我们对自己的时间管理有了一个认知，也明白了哪些事情是重要的哪些事情是不重要的之后，我们应该如何高效的去处理这些事情呢？\n\n**四象限法则**\n\n对每一天要做的事情，按照重要程度与紧迫程度进行排序。你可以参考下面这张图：\n![四象限法则](/img/blog_imgs/xiao-qiang-sheng-zhi-ji-yi-ben-bei-ming-zi-dan-ge-de-shi-jian-guan-li-bao-dian/4.jpg)\n四象限法则将我们的事件分为4类：\n- 重要且紧急：立即去做。\n- 重要不紧急：有计划的执行。\n- 不重要但紧急：尽可能交给别人去做\n- 不重要也不紧急：不要做。\n\n对于重要且紧急的事情，我们需要立刻去完成，但同时我们还需要思考一个问题：为什么有那么多重要且紧急的事情呢？事实上稍加分析我们就不难发现，大部分重要且紧急的事件都是因为我们没有很好的完成重要但不紧急的事件，导致时间被浪费，最终不紧急的事件拖成了紧急的事件。因此我们需要牢记一点：**完成重要但不紧急的事件能够帮助我们减少重要且紧急的事件**。\n\n对于重要但不紧急的事件，我们应该有计划的，利用工作中最高效的事件有条不紊的去完成。\n\n至于不重要也不急迫的事情，我们应该尽可能的减少这类事件，或者仅仅是将其作为疲惫时用于缓冲的事件，千万不要在里面浪费太多的时间和精力。\n\n**猴子法则**\n\n不知道大家有没有发现上面没有提到不重要但紧急的事件，这一类事件我们可以尝试交给别人去做。在《小强升职记》中提到了一个概念叫做“猴子法则”，这个概念比较大且存在一些争议，此处不做进一步探讨。我们应该注意每一件被标记为不重要但紧急的事件是否真的应该由自己去做，比如工作的时候收到了一封邮件，一个电话，一封短信等。晚一点处理也许没什么，但立即处理却可能导致当前的思路被打断。\n\n**投资时间**\n\n将投资的五大原则用在时间管理上：\n- 找到杰出的公司：字面意思。\n- 少就是多：优先处理最重要最复杂的事情，而不是处理更多的不重要的事情。\n- 押大赌注于高概率事件：当我们能够肯定一件事情的回报值得付出时，应该不惜投入大量时间搞定这件事情。\n- 要有耐心：完成某件事情的回报或许不会立刻体现，我们需要事件来证明它。\n- 不要担心短期的价格波动：当认定一件事有价值时，就不要因为其它的因素干扰了自己的心情。\n\n#### 2.2.4 执行\n通过上面的方法，我们对自己所有的事件进行分类处理，之所以分类，是为了能够更高效的完成最重要的事情。\n\n**脑子里只装一件事**\n\n我们将事件记录在便签上之后，对所有需要进行的事件进行处理，它保证了我们能够专心的去处理眼前的事件而不用担心遗漏了什么。这也是 `GTD` 工作法中非常重要的一个观念：**通过记录的方式把头脑中的各种任务移出来**。\n\n**项目 & 行动**\n\n我们在事件列表里记录的事件，并不一定是清晰的可执行的，例如：\n- 开发一个个人项目\n- 做一个视频\n\n这些事件一个共同的特点是它们都无法直接执行。开发一个个人项目需要敲定项目的主题，技术栈，开发周期等，当功能和需求较多时甚至需要引入项目的工程化管理。做一个视频同样需要敲定视频的主题，创作内容，取材，剪辑，后期等过程。这些事件我们将其称之为项目。\n\n当我们将项目进行分解，则得到了行动，还是以开发一个个人项目举例子，我们将其拆解为：\n1. 查询资料确定几个可靠的项目主题\n2. 查询相关领域的专业书籍，了解该领域的知识\n3. 规划项目的需求，确定第一个迭代的功能点\n4. 调研功能的可行性，制定实施方案\n5. 确定本版本的功能点，规划迭代\n......\n\n当我们将项目拆解为行动之后，我们就可以只专注于当前行动，当前行动完成后再进入“下一步行动”，直到项目完成。\n\n#### 2.2.5 衣柜整理法\n衣柜整理法是对上述时间管理方法的整理，它分为五个水平流程：收集、处理、组织、回顾、行动。\n\n**收集**\n\n收集是指收集一切引起我们注意的事情。我们在工作或者学习的时候，或许会收到各种来自同事，朋友，家人的委托。对于这些事件，我们并不应该立即去处理，而是将其收集到事件清单里。等手头的工作结束后再统一的处理。\n\n**处理 & 组织**\n\n通过上述步骤，我们收集了若干事件，现在需要将其进行分类。一个要点是我们应该快速从清单的第一项开始对每一个事件进行标记，将其区分为“可以执行”和“不可执行”，直到清单的最后一项。\n\n我们将不可执行的事件分为如下三类：\n- 辣鸡：扔掉。\n- 将来也许可能做：记录到一个单独的清单里。\n- 参考资料：进行归档处理。\n\n将可以执行的事件又分为如下五类：\n- 2分钟之内可以搞定的事情：立即处理掉。\n- 需要多个步骤处理的事情：记录到项目清单。\n- 指派给别人的事情：立即指派。\n- 特定时间做的事情：加入日程表。\n- 待办事项：记录到代办事项清单。\n\n通过这样的操作，我们将事件分类到了3个清单里：项目清单，待办事项清单，将来也许会做清单。它们与我们记录的事件列表组成了 “3+1清单系统”。\n\n**回顾**\n\n对清单进行回顾有如下好处：\n- 站在更高的角度去看待问题。\n- 孵化那些曾经想做的事情（清理将来也许会做清单）。\n\n每天工作或学习前首先审视自己的清单，每周定期做回顾，把将来也许会做清单里可以做的事情取出来进行规划，没做成的事件删除；了解项目清单中的项目进度；清理待办事项清单，最后审视自己的目标。\n\n**行动**\n\n最后，如何审视自己的行动，我们需要提到“六个高度”的概念。\n\n六个高度教会我们站在六个高度来看到我们正在做的行动，让我们更快的确定自己是否处于正确的轨道上。它们分别是：\n1. 原则（五万米视角）：我的人生目标，实现自我价值，成为对社会有用的人。\n2. 愿景（四万米视角）：3-5年的展望，积累技术，成为独当一面的工程师；学会思考，成为一名有思想的产品经理。\n3. 目标（三万米视角）：1-2年的目标，开发一款产品级应用，精通一种编程语言。\n4. 责任（两万米视角）：我的身份对应的责任，技术，思想。\n5. 项目（一万米视角）：具体的项目。\n6. 行动：具体项目的实施细节。\n\n### 2.3 规划自己的人生\n如何规划自己的人生，首先我们需要目标。\n\n#### 2.3.1 正确的描述自己的目标\n描述目标的方式需要精确：\n我的目标是1年之内独立开发一款产品并上线，为此我需要从调研开始，清晰产品定位，设计产品的功能与内在哲学，同时需要提升技术来实现每一个功能模块。当项目迎来第一个外部用户时，目标即视为实现。\n\n精确的描述使我们认清目标的可行性。\n\n#### 2.3.2 分解目标\n分解目标之前，我们需要具备充足的条件和理有让保持自己每一次都能够信息百倍的去向着目标前进。\n\n**我为什么要实现我的目标？**\n\n1. 我渴望表现自己的想法。\n2. 我希望自己的技术和思维能够解决其他人的问题。\n3. 我希望增加自己在专业领域的创造力和执行力。\n\n**我为什么可以做到？**\n1. 我已经掌握了该项目的大部分技术。\n2. 我认为该项目能够解决我和大部分人对时间管理的需求。\n3. 我已基本了解了该方向的理论了知识。\n\n**打算多久实现这个目标**\n1年。\n\n接下来我们就可以开始分解目标了：\n写下实现目标的计划：\n1. 阅读项目主题相关领域的专业书籍，建立理论体系。\n2. 整理需求点，设计产品的功能\n3. 进行开发\n\n然后对每一项进行进一步的分解：\n1. 阅读项目主题相关领域的专业书籍，建立理论体系。\n  1. 阅读《小强升职记》并写书评。\n  2. 了解 `GTD` 理论。\n  3. 阅读 《番茄钟工作法》并写书评。\n2. 整理需求点，设计产品功能。\n  1. 假设自己就是用户，列举用户需求。\n  2. 调研每一个需求的可行性。\n  3. 规划该版本要实现的需求。\n  4. 规划迭代\n3. 开发\n  1. 确定技术栈\n  ……\n\n## 3. 最后\n以上是本书的一些总结，第一次写这种书评和笔记，确实发现自己的思路非常混乱，并且在写的时候又几乎把书重新翻了一遍- -!\n\n时间管理是一种自我投资，我认为未来会有越来越多的人（尤其是年轻人）意识到时间管理的重要性，这不是在玩某种梗文化，而是快节奏生活下最真实的需求。我也真切的希望这篇文章能够帮助到点进来的任何一个读者，如果你对时间管理有任何心得或者想法，欢迎在文章下方留言。同样也欢迎将我的文章分享给你的朋友们，你们的支持是我最大的动力，谢谢！。","source":"_posts/小强升职记-一本被名字耽搁的时间管理宝典.md","raw":"---\ntitle: '小强升职记: 一本被名字耽搁的时间管理宝典'\ndate: 2020-06-17 19:13:41\ntags:\n  - 读书笔记\n  - 时间管理\ncategories:\n  - 好书分享\n---\n\n## 1. 介绍\n最近读了《小强升职记》一书，不由得感慨：给书起一个好名字太重要！乍一听这名字不由想到什么《杜xx升职记》，瞬间不想读的欲望又增加了。\n\n《小强升职记》是一本以时间管理为主的小故事。整个故事围绕职场老鸟“老付”，和他的下属“小强”展开。小强是一个人间普通社畜，跟我们一样每天苦于应付各种琐碎的工作。而老付则是一个有着明确目标的职场前辈。故事主要讲述了小强在老付的帮助下，慢慢学会时间管理，并终于走向人生正规的故事。\n\n## 2. 启发\n\n### 2.1 为什么要管理自己的时间？\n为了更高效的完成工作任务和学习目标，最终实现自己的梦想。\n\n### 2.2 如何管理自己的时间？\n管理好自己的时间不是一件易事，我们应该先从发现问题开始，然后加以改善。\n\n#### 2.2.1 正视自己的时间观念\n正视自己的时间观念能够让我们发现自身的问题。\n\n**时间黑洞**\n\n持续两周每隔一个小时记录自己正在做的事情，然后分析多少时间是在集中精力处理事件，多少时间是在做无意义的事情，多少时间是在休息。\n\n一定要去做一定要去做一定要去做！重要的话说三遍。当我定期对工作进行总结的时候，很多时候我都不能精确的说出半个月内我在什么事情上花了多少时间。这一度使我在公司进行工作总结的时候非常被动，特别是当这半个月的事情非常琐碎的时候，我必须努力去回忆我做了什么。很多同学觉得自己记忆力很ok就不动笔，真的请千万不要这样做，写个便签占用不了多少时间的。\n\n**时间日志**\n\n持续两周每隔一小时计划下一个小时要做的事情，同时记录上一个小时自己做的事情。\n\n如果说记录自己做的事情是为了正视自己的时间管理能力，那么时间日志就是为了发现问题。\n\n计划一个小时完成的事情，结果花了两个小时；在精力最充沛的时间里做了最次要的事情；无法处理突发事件导致本该完成的事情没有完成……\n\n和上面一样，建议同学们一定要用文档或者纸笔去记录而不是用大脑来记录。每天对时间日志进行整理总结的时候就会发现存在很多处理事情方面的问题。\n\n#### 2.2.2 确定自己的价值观\n每一天开始工作或者学习之前，首先将今天要做的事情都列举出来，并根据重要级别排序。\n\n这里要提到一个很重要的东西就是你的价值观。不同的人看代问题的角度不同，因此他们眼中事件的重要级别也一定不同。如何确定一件事情是否重要，取决于你的价值观。\n\n对于软件开发工程师来说，保证软件的可用性要比保证公司垃圾篓的干净程度重要；反之对于保洁阿姨来说，公司的环境卫生才是最重要的事情。因此必须要确定自己的价值观，才能够依靠价值观来判断哪些事情是重要的，哪些事情不重要。\n\n#### 2.2.3 分类自己的事件\n当我们对自己的时间管理有了一个认知，也明白了哪些事情是重要的哪些事情是不重要的之后，我们应该如何高效的去处理这些事情呢？\n\n**四象限法则**\n\n对每一天要做的事情，按照重要程度与紧迫程度进行排序。你可以参考下面这张图：\n![四象限法则](/img/blog_imgs/xiao-qiang-sheng-zhi-ji-yi-ben-bei-ming-zi-dan-ge-de-shi-jian-guan-li-bao-dian/4.jpg)\n四象限法则将我们的事件分为4类：\n- 重要且紧急：立即去做。\n- 重要不紧急：有计划的执行。\n- 不重要但紧急：尽可能交给别人去做\n- 不重要也不紧急：不要做。\n\n对于重要且紧急的事情，我们需要立刻去完成，但同时我们还需要思考一个问题：为什么有那么多重要且紧急的事情呢？事实上稍加分析我们就不难发现，大部分重要且紧急的事件都是因为我们没有很好的完成重要但不紧急的事件，导致时间被浪费，最终不紧急的事件拖成了紧急的事件。因此我们需要牢记一点：**完成重要但不紧急的事件能够帮助我们减少重要且紧急的事件**。\n\n对于重要但不紧急的事件，我们应该有计划的，利用工作中最高效的事件有条不紊的去完成。\n\n至于不重要也不急迫的事情，我们应该尽可能的减少这类事件，或者仅仅是将其作为疲惫时用于缓冲的事件，千万不要在里面浪费太多的时间和精力。\n\n**猴子法则**\n\n不知道大家有没有发现上面没有提到不重要但紧急的事件，这一类事件我们可以尝试交给别人去做。在《小强升职记》中提到了一个概念叫做“猴子法则”，这个概念比较大且存在一些争议，此处不做进一步探讨。我们应该注意每一件被标记为不重要但紧急的事件是否真的应该由自己去做，比如工作的时候收到了一封邮件，一个电话，一封短信等。晚一点处理也许没什么，但立即处理却可能导致当前的思路被打断。\n\n**投资时间**\n\n将投资的五大原则用在时间管理上：\n- 找到杰出的公司：字面意思。\n- 少就是多：优先处理最重要最复杂的事情，而不是处理更多的不重要的事情。\n- 押大赌注于高概率事件：当我们能够肯定一件事情的回报值得付出时，应该不惜投入大量时间搞定这件事情。\n- 要有耐心：完成某件事情的回报或许不会立刻体现，我们需要事件来证明它。\n- 不要担心短期的价格波动：当认定一件事有价值时，就不要因为其它的因素干扰了自己的心情。\n\n#### 2.2.4 执行\n通过上面的方法，我们对自己所有的事件进行分类处理，之所以分类，是为了能够更高效的完成最重要的事情。\n\n**脑子里只装一件事**\n\n我们将事件记录在便签上之后，对所有需要进行的事件进行处理，它保证了我们能够专心的去处理眼前的事件而不用担心遗漏了什么。这也是 `GTD` 工作法中非常重要的一个观念：**通过记录的方式把头脑中的各种任务移出来**。\n\n**项目 & 行动**\n\n我们在事件列表里记录的事件，并不一定是清晰的可执行的，例如：\n- 开发一个个人项目\n- 做一个视频\n\n这些事件一个共同的特点是它们都无法直接执行。开发一个个人项目需要敲定项目的主题，技术栈，开发周期等，当功能和需求较多时甚至需要引入项目的工程化管理。做一个视频同样需要敲定视频的主题，创作内容，取材，剪辑，后期等过程。这些事件我们将其称之为项目。\n\n当我们将项目进行分解，则得到了行动，还是以开发一个个人项目举例子，我们将其拆解为：\n1. 查询资料确定几个可靠的项目主题\n2. 查询相关领域的专业书籍，了解该领域的知识\n3. 规划项目的需求，确定第一个迭代的功能点\n4. 调研功能的可行性，制定实施方案\n5. 确定本版本的功能点，规划迭代\n......\n\n当我们将项目拆解为行动之后，我们就可以只专注于当前行动，当前行动完成后再进入“下一步行动”，直到项目完成。\n\n#### 2.2.5 衣柜整理法\n衣柜整理法是对上述时间管理方法的整理，它分为五个水平流程：收集、处理、组织、回顾、行动。\n\n**收集**\n\n收集是指收集一切引起我们注意的事情。我们在工作或者学习的时候，或许会收到各种来自同事，朋友，家人的委托。对于这些事件，我们并不应该立即去处理，而是将其收集到事件清单里。等手头的工作结束后再统一的处理。\n\n**处理 & 组织**\n\n通过上述步骤，我们收集了若干事件，现在需要将其进行分类。一个要点是我们应该快速从清单的第一项开始对每一个事件进行标记，将其区分为“可以执行”和“不可执行”，直到清单的最后一项。\n\n我们将不可执行的事件分为如下三类：\n- 辣鸡：扔掉。\n- 将来也许可能做：记录到一个单独的清单里。\n- 参考资料：进行归档处理。\n\n将可以执行的事件又分为如下五类：\n- 2分钟之内可以搞定的事情：立即处理掉。\n- 需要多个步骤处理的事情：记录到项目清单。\n- 指派给别人的事情：立即指派。\n- 特定时间做的事情：加入日程表。\n- 待办事项：记录到代办事项清单。\n\n通过这样的操作，我们将事件分类到了3个清单里：项目清单，待办事项清单，将来也许会做清单。它们与我们记录的事件列表组成了 “3+1清单系统”。\n\n**回顾**\n\n对清单进行回顾有如下好处：\n- 站在更高的角度去看待问题。\n- 孵化那些曾经想做的事情（清理将来也许会做清单）。\n\n每天工作或学习前首先审视自己的清单，每周定期做回顾，把将来也许会做清单里可以做的事情取出来进行规划，没做成的事件删除；了解项目清单中的项目进度；清理待办事项清单，最后审视自己的目标。\n\n**行动**\n\n最后，如何审视自己的行动，我们需要提到“六个高度”的概念。\n\n六个高度教会我们站在六个高度来看到我们正在做的行动，让我们更快的确定自己是否处于正确的轨道上。它们分别是：\n1. 原则（五万米视角）：我的人生目标，实现自我价值，成为对社会有用的人。\n2. 愿景（四万米视角）：3-5年的展望，积累技术，成为独当一面的工程师；学会思考，成为一名有思想的产品经理。\n3. 目标（三万米视角）：1-2年的目标，开发一款产品级应用，精通一种编程语言。\n4. 责任（两万米视角）：我的身份对应的责任，技术，思想。\n5. 项目（一万米视角）：具体的项目。\n6. 行动：具体项目的实施细节。\n\n### 2.3 规划自己的人生\n如何规划自己的人生，首先我们需要目标。\n\n#### 2.3.1 正确的描述自己的目标\n描述目标的方式需要精确：\n我的目标是1年之内独立开发一款产品并上线，为此我需要从调研开始，清晰产品定位，设计产品的功能与内在哲学，同时需要提升技术来实现每一个功能模块。当项目迎来第一个外部用户时，目标即视为实现。\n\n精确的描述使我们认清目标的可行性。\n\n#### 2.3.2 分解目标\n分解目标之前，我们需要具备充足的条件和理有让保持自己每一次都能够信息百倍的去向着目标前进。\n\n**我为什么要实现我的目标？**\n\n1. 我渴望表现自己的想法。\n2. 我希望自己的技术和思维能够解决其他人的问题。\n3. 我希望增加自己在专业领域的创造力和执行力。\n\n**我为什么可以做到？**\n1. 我已经掌握了该项目的大部分技术。\n2. 我认为该项目能够解决我和大部分人对时间管理的需求。\n3. 我已基本了解了该方向的理论了知识。\n\n**打算多久实现这个目标**\n1年。\n\n接下来我们就可以开始分解目标了：\n写下实现目标的计划：\n1. 阅读项目主题相关领域的专业书籍，建立理论体系。\n2. 整理需求点，设计产品的功能\n3. 进行开发\n\n然后对每一项进行进一步的分解：\n1. 阅读项目主题相关领域的专业书籍，建立理论体系。\n  1. 阅读《小强升职记》并写书评。\n  2. 了解 `GTD` 理论。\n  3. 阅读 《番茄钟工作法》并写书评。\n2. 整理需求点，设计产品功能。\n  1. 假设自己就是用户，列举用户需求。\n  2. 调研每一个需求的可行性。\n  3. 规划该版本要实现的需求。\n  4. 规划迭代\n3. 开发\n  1. 确定技术栈\n  ……\n\n## 3. 最后\n以上是本书的一些总结，第一次写这种书评和笔记，确实发现自己的思路非常混乱，并且在写的时候又几乎把书重新翻了一遍- -!\n\n时间管理是一种自我投资，我认为未来会有越来越多的人（尤其是年轻人）意识到时间管理的重要性，这不是在玩某种梗文化，而是快节奏生活下最真实的需求。我也真切的希望这篇文章能够帮助到点进来的任何一个读者，如果你对时间管理有任何心得或者想法，欢迎在文章下方留言。同样也欢迎将我的文章分享给你的朋友们，你们的支持是我最大的动力，谢谢！。","slug":"小强升职记-一本被名字耽搁的时间管理宝典","published":1,"updated":"2022-05-03T08:45:16.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdun002kr2ve70ax767m","content":"<h2 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h2><p>最近读了《小强升职记》一书，不由得感慨：给书起一个好名字太重要！乍一听这名字不由想到什么《杜xx升职记》，瞬间不想读的欲望又增加了。</p>\n<p>《小强升职记》是一本以时间管理为主的小故事。整个故事围绕职场老鸟“老付”，和他的下属“小强”展开。小强是一个人间普通社畜，跟我们一样每天苦于应付各种琐碎的工作。而老付则是一个有着明确目标的职场前辈。故事主要讲述了小强在老付的帮助下，慢慢学会时间管理，并终于走向人生正规的故事。</p>\n<h2 id=\"2-启发\"><a href=\"#2-启发\" class=\"headerlink\" title=\"2. 启发\"></a>2. 启发</h2><h3 id=\"2-1-为什么要管理自己的时间？\"><a href=\"#2-1-为什么要管理自己的时间？\" class=\"headerlink\" title=\"2.1 为什么要管理自己的时间？\"></a>2.1 为什么要管理自己的时间？</h3><p>为了更高效的完成工作任务和学习目标，最终实现自己的梦想。</p>\n<h3 id=\"2-2-如何管理自己的时间？\"><a href=\"#2-2-如何管理自己的时间？\" class=\"headerlink\" title=\"2.2 如何管理自己的时间？\"></a>2.2 如何管理自己的时间？</h3><p>管理好自己的时间不是一件易事，我们应该先从发现问题开始，然后加以改善。</p>\n<h4 id=\"2-2-1-正视自己的时间观念\"><a href=\"#2-2-1-正视自己的时间观念\" class=\"headerlink\" title=\"2.2.1 正视自己的时间观念\"></a>2.2.1 正视自己的时间观念</h4><p>正视自己的时间观念能够让我们发现自身的问题。</p>\n<p><strong>时间黑洞</strong></p>\n<p>持续两周每隔一个小时记录自己正在做的事情，然后分析多少时间是在集中精力处理事件，多少时间是在做无意义的事情，多少时间是在休息。</p>\n<p>一定要去做一定要去做一定要去做！重要的话说三遍。当我定期对工作进行总结的时候，很多时候我都不能精确的说出半个月内我在什么事情上花了多少时间。这一度使我在公司进行工作总结的时候非常被动，特别是当这半个月的事情非常琐碎的时候，我必须努力去回忆我做了什么。很多同学觉得自己记忆力很ok就不动笔，真的请千万不要这样做，写个便签占用不了多少时间的。</p>\n<p><strong>时间日志</strong></p>\n<p>持续两周每隔一小时计划下一个小时要做的事情，同时记录上一个小时自己做的事情。</p>\n<p>如果说记录自己做的事情是为了正视自己的时间管理能力，那么时间日志就是为了发现问题。</p>\n<p>计划一个小时完成的事情，结果花了两个小时；在精力最充沛的时间里做了最次要的事情；无法处理突发事件导致本该完成的事情没有完成……</p>\n<p>和上面一样，建议同学们一定要用文档或者纸笔去记录而不是用大脑来记录。每天对时间日志进行整理总结的时候就会发现存在很多处理事情方面的问题。</p>\n<h4 id=\"2-2-2-确定自己的价值观\"><a href=\"#2-2-2-确定自己的价值观\" class=\"headerlink\" title=\"2.2.2 确定自己的价值观\"></a>2.2.2 确定自己的价值观</h4><p>每一天开始工作或者学习之前，首先将今天要做的事情都列举出来，并根据重要级别排序。</p>\n<p>这里要提到一个很重要的东西就是你的价值观。不同的人看代问题的角度不同，因此他们眼中事件的重要级别也一定不同。如何确定一件事情是否重要，取决于你的价值观。</p>\n<p>对于软件开发工程师来说，保证软件的可用性要比保证公司垃圾篓的干净程度重要；反之对于保洁阿姨来说，公司的环境卫生才是最重要的事情。因此必须要确定自己的价值观，才能够依靠价值观来判断哪些事情是重要的，哪些事情不重要。</p>\n<h4 id=\"2-2-3-分类自己的事件\"><a href=\"#2-2-3-分类自己的事件\" class=\"headerlink\" title=\"2.2.3 分类自己的事件\"></a>2.2.3 分类自己的事件</h4><p>当我们对自己的时间管理有了一个认知，也明白了哪些事情是重要的哪些事情是不重要的之后，我们应该如何高效的去处理这些事情呢？</p>\n<p><strong>四象限法则</strong></p>\n<p>对每一天要做的事情，按照重要程度与紧迫程度进行排序。你可以参考下面这张图：<br><img src=\"/img/blog_imgs/xiao-qiang-sheng-zhi-ji-yi-ben-bei-ming-zi-dan-ge-de-shi-jian-guan-li-bao-dian/4.jpg\" alt=\"四象限法则\"><br>四象限法则将我们的事件分为4类：</p>\n<ul>\n<li>重要且紧急：立即去做。</li>\n<li>重要不紧急：有计划的执行。</li>\n<li>不重要但紧急：尽可能交给别人去做</li>\n<li>不重要也不紧急：不要做。</li>\n</ul>\n<p>对于重要且紧急的事情，我们需要立刻去完成，但同时我们还需要思考一个问题：为什么有那么多重要且紧急的事情呢？事实上稍加分析我们就不难发现，大部分重要且紧急的事件都是因为我们没有很好的完成重要但不紧急的事件，导致时间被浪费，最终不紧急的事件拖成了紧急的事件。因此我们需要牢记一点：<strong>完成重要但不紧急的事件能够帮助我们减少重要且紧急的事件</strong>。</p>\n<p>对于重要但不紧急的事件，我们应该有计划的，利用工作中最高效的事件有条不紊的去完成。</p>\n<p>至于不重要也不急迫的事情，我们应该尽可能的减少这类事件，或者仅仅是将其作为疲惫时用于缓冲的事件，千万不要在里面浪费太多的时间和精力。</p>\n<p><strong>猴子法则</strong></p>\n<p>不知道大家有没有发现上面没有提到不重要但紧急的事件，这一类事件我们可以尝试交给别人去做。在《小强升职记》中提到了一个概念叫做“猴子法则”，这个概念比较大且存在一些争议，此处不做进一步探讨。我们应该注意每一件被标记为不重要但紧急的事件是否真的应该由自己去做，比如工作的时候收到了一封邮件，一个电话，一封短信等。晚一点处理也许没什么，但立即处理却可能导致当前的思路被打断。</p>\n<p><strong>投资时间</strong></p>\n<p>将投资的五大原则用在时间管理上：</p>\n<ul>\n<li>找到杰出的公司：字面意思。</li>\n<li>少就是多：优先处理最重要最复杂的事情，而不是处理更多的不重要的事情。</li>\n<li>押大赌注于高概率事件：当我们能够肯定一件事情的回报值得付出时，应该不惜投入大量时间搞定这件事情。</li>\n<li>要有耐心：完成某件事情的回报或许不会立刻体现，我们需要事件来证明它。</li>\n<li>不要担心短期的价格波动：当认定一件事有价值时，就不要因为其它的因素干扰了自己的心情。</li>\n</ul>\n<h4 id=\"2-2-4-执行\"><a href=\"#2-2-4-执行\" class=\"headerlink\" title=\"2.2.4 执行\"></a>2.2.4 执行</h4><p>通过上面的方法，我们对自己所有的事件进行分类处理，之所以分类，是为了能够更高效的完成最重要的事情。</p>\n<p><strong>脑子里只装一件事</strong></p>\n<p>我们将事件记录在便签上之后，对所有需要进行的事件进行处理，它保证了我们能够专心的去处理眼前的事件而不用担心遗漏了什么。这也是 <code>GTD</code> 工作法中非常重要的一个观念：<strong>通过记录的方式把头脑中的各种任务移出来</strong>。</p>\n<p><strong>项目 &amp; 行动</strong></p>\n<p>我们在事件列表里记录的事件，并不一定是清晰的可执行的，例如：</p>\n<ul>\n<li>开发一个个人项目</li>\n<li>做一个视频</li>\n</ul>\n<p>这些事件一个共同的特点是它们都无法直接执行。开发一个个人项目需要敲定项目的主题，技术栈，开发周期等，当功能和需求较多时甚至需要引入项目的工程化管理。做一个视频同样需要敲定视频的主题，创作内容，取材，剪辑，后期等过程。这些事件我们将其称之为项目。</p>\n<p>当我们将项目进行分解，则得到了行动，还是以开发一个个人项目举例子，我们将其拆解为：</p>\n<ol>\n<li>查询资料确定几个可靠的项目主题</li>\n<li>查询相关领域的专业书籍，了解该领域的知识</li>\n<li>规划项目的需求，确定第一个迭代的功能点</li>\n<li>调研功能的可行性，制定实施方案</li>\n<li>确定本版本的功能点，规划迭代<br>……</li>\n</ol>\n<p>当我们将项目拆解为行动之后，我们就可以只专注于当前行动，当前行动完成后再进入“下一步行动”，直到项目完成。</p>\n<h4 id=\"2-2-5-衣柜整理法\"><a href=\"#2-2-5-衣柜整理法\" class=\"headerlink\" title=\"2.2.5 衣柜整理法\"></a>2.2.5 衣柜整理法</h4><p>衣柜整理法是对上述时间管理方法的整理，它分为五个水平流程：收集、处理、组织、回顾、行动。</p>\n<p><strong>收集</strong></p>\n<p>收集是指收集一切引起我们注意的事情。我们在工作或者学习的时候，或许会收到各种来自同事，朋友，家人的委托。对于这些事件，我们并不应该立即去处理，而是将其收集到事件清单里。等手头的工作结束后再统一的处理。</p>\n<p><strong>处理 &amp; 组织</strong></p>\n<p>通过上述步骤，我们收集了若干事件，现在需要将其进行分类。一个要点是我们应该快速从清单的第一项开始对每一个事件进行标记，将其区分为“可以执行”和“不可执行”，直到清单的最后一项。</p>\n<p>我们将不可执行的事件分为如下三类：</p>\n<ul>\n<li>辣鸡：扔掉。</li>\n<li>将来也许可能做：记录到一个单独的清单里。</li>\n<li>参考资料：进行归档处理。</li>\n</ul>\n<p>将可以执行的事件又分为如下五类：</p>\n<ul>\n<li>2分钟之内可以搞定的事情：立即处理掉。</li>\n<li>需要多个步骤处理的事情：记录到项目清单。</li>\n<li>指派给别人的事情：立即指派。</li>\n<li>特定时间做的事情：加入日程表。</li>\n<li>待办事项：记录到代办事项清单。</li>\n</ul>\n<p>通过这样的操作，我们将事件分类到了3个清单里：项目清单，待办事项清单，将来也许会做清单。它们与我们记录的事件列表组成了 “3+1清单系统”。</p>\n<p><strong>回顾</strong></p>\n<p>对清单进行回顾有如下好处：</p>\n<ul>\n<li>站在更高的角度去看待问题。</li>\n<li>孵化那些曾经想做的事情（清理将来也许会做清单）。</li>\n</ul>\n<p>每天工作或学习前首先审视自己的清单，每周定期做回顾，把将来也许会做清单里可以做的事情取出来进行规划，没做成的事件删除；了解项目清单中的项目进度；清理待办事项清单，最后审视自己的目标。</p>\n<p><strong>行动</strong></p>\n<p>最后，如何审视自己的行动，我们需要提到“六个高度”的概念。</p>\n<p>六个高度教会我们站在六个高度来看到我们正在做的行动，让我们更快的确定自己是否处于正确的轨道上。它们分别是：</p>\n<ol>\n<li>原则（五万米视角）：我的人生目标，实现自我价值，成为对社会有用的人。</li>\n<li>愿景（四万米视角）：3-5年的展望，积累技术，成为独当一面的工程师；学会思考，成为一名有思想的产品经理。</li>\n<li>目标（三万米视角）：1-2年的目标，开发一款产品级应用，精通一种编程语言。</li>\n<li>责任（两万米视角）：我的身份对应的责任，技术，思想。</li>\n<li>项目（一万米视角）：具体的项目。</li>\n<li>行动：具体项目的实施细节。</li>\n</ol>\n<h3 id=\"2-3-规划自己的人生\"><a href=\"#2-3-规划自己的人生\" class=\"headerlink\" title=\"2.3 规划自己的人生\"></a>2.3 规划自己的人生</h3><p>如何规划自己的人生，首先我们需要目标。</p>\n<h4 id=\"2-3-1-正确的描述自己的目标\"><a href=\"#2-3-1-正确的描述自己的目标\" class=\"headerlink\" title=\"2.3.1 正确的描述自己的目标\"></a>2.3.1 正确的描述自己的目标</h4><p>描述目标的方式需要精确：<br>我的目标是1年之内独立开发一款产品并上线，为此我需要从调研开始，清晰产品定位，设计产品的功能与内在哲学，同时需要提升技术来实现每一个功能模块。当项目迎来第一个外部用户时，目标即视为实现。</p>\n<p>精确的描述使我们认清目标的可行性。</p>\n<h4 id=\"2-3-2-分解目标\"><a href=\"#2-3-2-分解目标\" class=\"headerlink\" title=\"2.3.2 分解目标\"></a>2.3.2 分解目标</h4><p>分解目标之前，我们需要具备充足的条件和理有让保持自己每一次都能够信息百倍的去向着目标前进。</p>\n<p><strong>我为什么要实现我的目标？</strong></p>\n<ol>\n<li>我渴望表现自己的想法。</li>\n<li>我希望自己的技术和思维能够解决其他人的问题。</li>\n<li>我希望增加自己在专业领域的创造力和执行力。</li>\n</ol>\n<p><strong>我为什么可以做到？</strong></p>\n<ol>\n<li>我已经掌握了该项目的大部分技术。</li>\n<li>我认为该项目能够解决我和大部分人对时间管理的需求。</li>\n<li>我已基本了解了该方向的理论了知识。</li>\n</ol>\n<p><strong>打算多久实现这个目标</strong><br>1年。</p>\n<p>接下来我们就可以开始分解目标了：<br>写下实现目标的计划：</p>\n<ol>\n<li>阅读项目主题相关领域的专业书籍，建立理论体系。</li>\n<li>整理需求点，设计产品的功能</li>\n<li>进行开发</li>\n</ol>\n<p>然后对每一项进行进一步的分解：</p>\n<ol>\n<li>阅读项目主题相关领域的专业书籍，建立理论体系。</li>\n<li>阅读《小强升职记》并写书评。</li>\n<li>了解 <code>GTD</code> 理论。</li>\n<li>阅读 《番茄钟工作法》并写书评。</li>\n<li>整理需求点，设计产品功能。</li>\n<li>假设自己就是用户，列举用户需求。</li>\n<li>调研每一个需求的可行性。</li>\n<li>规划该版本要实现的需求。</li>\n<li>规划迭代</li>\n<li>开发</li>\n<li>确定技术栈<br>  ……</li>\n</ol>\n<h2 id=\"3-最后\"><a href=\"#3-最后\" class=\"headerlink\" title=\"3. 最后\"></a>3. 最后</h2><p>以上是本书的一些总结，第一次写这种书评和笔记，确实发现自己的思路非常混乱，并且在写的时候又几乎把书重新翻了一遍- -!</p>\n<p>时间管理是一种自我投资，我认为未来会有越来越多的人（尤其是年轻人）意识到时间管理的重要性，这不是在玩某种梗文化，而是快节奏生活下最真实的需求。我也真切的希望这篇文章能够帮助到点进来的任何一个读者，如果你对时间管理有任何心得或者想法，欢迎在文章下方留言。同样也欢迎将我的文章分享给你的朋友们，你们的支持是我最大的动力，谢谢！。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h2 id=\"1-介绍\"><a href=\"#1-介绍\" class=\"headerlink\" title=\"1. 介绍\"></a>1. 介绍</h2><p>最近读了《小强升职记》一书，不由得感慨：给书起一个好名字太重要！乍一听这名字不由想到什么《杜xx升职记》，瞬间不想读的欲望又增加了。</p>\n<p>《小强升职记》是一本以时间管理为主的小故事。整个故事围绕职场老鸟“老付”，和他的下属“小强”展开。小强是一个人间普通社畜，跟我们一样每天苦于应付各种琐碎的工作。而老付则是一个有着明确目标的职场前辈。故事主要讲述了小强在老付的帮助下，慢慢学会时间管理，并终于走向人生正规的故事。</p>\n<h2 id=\"2-启发\"><a href=\"#2-启发\" class=\"headerlink\" title=\"2. 启发\"></a>2. 启发</h2><h3 id=\"2-1-为什么要管理自己的时间？\"><a href=\"#2-1-为什么要管理自己的时间？\" class=\"headerlink\" title=\"2.1 为什么要管理自己的时间？\"></a>2.1 为什么要管理自己的时间？</h3><p>为了更高效的完成工作任务和学习目标，最终实现自己的梦想。</p>\n<h3 id=\"2-2-如何管理自己的时间？\"><a href=\"#2-2-如何管理自己的时间？\" class=\"headerlink\" title=\"2.2 如何管理自己的时间？\"></a>2.2 如何管理自己的时间？</h3><p>管理好自己的时间不是一件易事，我们应该先从发现问题开始，然后加以改善。</p>\n<h4 id=\"2-2-1-正视自己的时间观念\"><a href=\"#2-2-1-正视自己的时间观念\" class=\"headerlink\" title=\"2.2.1 正视自己的时间观念\"></a>2.2.1 正视自己的时间观念</h4><p>正视自己的时间观念能够让我们发现自身的问题。</p>\n<p><strong>时间黑洞</strong></p>\n<p>持续两周每隔一个小时记录自己正在做的事情，然后分析多少时间是在集中精力处理事件，多少时间是在做无意义的事情，多少时间是在休息。</p>\n<p>一定要去做一定要去做一定要去做！重要的话说三遍。当我定期对工作进行总结的时候，很多时候我都不能精确的说出半个月内我在什么事情上花了多少时间。这一度使我在公司进行工作总结的时候非常被动，特别是当这半个月的事情非常琐碎的时候，我必须努力去回忆我做了什么。很多同学觉得自己记忆力很ok就不动笔，真的请千万不要这样做，写个便签占用不了多少时间的。</p>\n<p><strong>时间日志</strong></p>\n<p>持续两周每隔一小时计划下一个小时要做的事情，同时记录上一个小时自己做的事情。</p>\n<p>如果说记录自己做的事情是为了正视自己的时间管理能力，那么时间日志就是为了发现问题。</p>\n<p>计划一个小时完成的事情，结果花了两个小时；在精力最充沛的时间里做了最次要的事情；无法处理突发事件导致本该完成的事情没有完成……</p>\n<p>和上面一样，建议同学们一定要用文档或者纸笔去记录而不是用大脑来记录。每天对时间日志进行整理总结的时候就会发现存在很多处理事情方面的问题。</p>\n<h4 id=\"2-2-2-确定自己的价值观\"><a href=\"#2-2-2-确定自己的价值观\" class=\"headerlink\" title=\"2.2.2 确定自己的价值观\"></a>2.2.2 确定自己的价值观</h4><p>每一天开始工作或者学习之前，首先将今天要做的事情都列举出来，并根据重要级别排序。</p>\n<p>这里要提到一个很重要的东西就是你的价值观。不同的人看代问题的角度不同，因此他们眼中事件的重要级别也一定不同。如何确定一件事情是否重要，取决于你的价值观。</p>\n<p>对于软件开发工程师来说，保证软件的可用性要比保证公司垃圾篓的干净程度重要；反之对于保洁阿姨来说，公司的环境卫生才是最重要的事情。因此必须要确定自己的价值观，才能够依靠价值观来判断哪些事情是重要的，哪些事情不重要。</p>\n<h4 id=\"2-2-3-分类自己的事件\"><a href=\"#2-2-3-分类自己的事件\" class=\"headerlink\" title=\"2.2.3 分类自己的事件\"></a>2.2.3 分类自己的事件</h4><p>当我们对自己的时间管理有了一个认知，也明白了哪些事情是重要的哪些事情是不重要的之后，我们应该如何高效的去处理这些事情呢？</p>\n<p><strong>四象限法则</strong></p>\n<p>对每一天要做的事情，按照重要程度与紧迫程度进行排序。你可以参考下面这张图：<br><img src=\"/img/blog_imgs/xiao-qiang-sheng-zhi-ji-yi-ben-bei-ming-zi-dan-ge-de-shi-jian-guan-li-bao-dian/4.jpg\" alt=\"四象限法则\"><br>四象限法则将我们的事件分为4类：</p>\n<ul>\n<li>重要且紧急：立即去做。</li>\n<li>重要不紧急：有计划的执行。</li>\n<li>不重要但紧急：尽可能交给别人去做</li>\n<li>不重要也不紧急：不要做。</li>\n</ul>\n<p>对于重要且紧急的事情，我们需要立刻去完成，但同时我们还需要思考一个问题：为什么有那么多重要且紧急的事情呢？事实上稍加分析我们就不难发现，大部分重要且紧急的事件都是因为我们没有很好的完成重要但不紧急的事件，导致时间被浪费，最终不紧急的事件拖成了紧急的事件。因此我们需要牢记一点：<strong>完成重要但不紧急的事件能够帮助我们减少重要且紧急的事件</strong>。</p>\n<p>对于重要但不紧急的事件，我们应该有计划的，利用工作中最高效的事件有条不紊的去完成。</p>\n<p>至于不重要也不急迫的事情，我们应该尽可能的减少这类事件，或者仅仅是将其作为疲惫时用于缓冲的事件，千万不要在里面浪费太多的时间和精力。</p>\n<p><strong>猴子法则</strong></p>\n<p>不知道大家有没有发现上面没有提到不重要但紧急的事件，这一类事件我们可以尝试交给别人去做。在《小强升职记》中提到了一个概念叫做“猴子法则”，这个概念比较大且存在一些争议，此处不做进一步探讨。我们应该注意每一件被标记为不重要但紧急的事件是否真的应该由自己去做，比如工作的时候收到了一封邮件，一个电话，一封短信等。晚一点处理也许没什么，但立即处理却可能导致当前的思路被打断。</p>\n<p><strong>投资时间</strong></p>\n<p>将投资的五大原则用在时间管理上：</p>\n<ul>\n<li>找到杰出的公司：字面意思。</li>\n<li>少就是多：优先处理最重要最复杂的事情，而不是处理更多的不重要的事情。</li>\n<li>押大赌注于高概率事件：当我们能够肯定一件事情的回报值得付出时，应该不惜投入大量时间搞定这件事情。</li>\n<li>要有耐心：完成某件事情的回报或许不会立刻体现，我们需要事件来证明它。</li>\n<li>不要担心短期的价格波动：当认定一件事有价值时，就不要因为其它的因素干扰了自己的心情。</li>\n</ul>\n<h4 id=\"2-2-4-执行\"><a href=\"#2-2-4-执行\" class=\"headerlink\" title=\"2.2.4 执行\"></a>2.2.4 执行</h4><p>通过上面的方法，我们对自己所有的事件进行分类处理，之所以分类，是为了能够更高效的完成最重要的事情。</p>\n<p><strong>脑子里只装一件事</strong></p>\n<p>我们将事件记录在便签上之后，对所有需要进行的事件进行处理，它保证了我们能够专心的去处理眼前的事件而不用担心遗漏了什么。这也是 <code>GTD</code> 工作法中非常重要的一个观念：<strong>通过记录的方式把头脑中的各种任务移出来</strong>。</p>\n<p><strong>项目 &amp; 行动</strong></p>\n<p>我们在事件列表里记录的事件，并不一定是清晰的可执行的，例如：</p>\n<ul>\n<li>开发一个个人项目</li>\n<li>做一个视频</li>\n</ul>\n<p>这些事件一个共同的特点是它们都无法直接执行。开发一个个人项目需要敲定项目的主题，技术栈，开发周期等，当功能和需求较多时甚至需要引入项目的工程化管理。做一个视频同样需要敲定视频的主题，创作内容，取材，剪辑，后期等过程。这些事件我们将其称之为项目。</p>\n<p>当我们将项目进行分解，则得到了行动，还是以开发一个个人项目举例子，我们将其拆解为：</p>\n<ol>\n<li>查询资料确定几个可靠的项目主题</li>\n<li>查询相关领域的专业书籍，了解该领域的知识</li>\n<li>规划项目的需求，确定第一个迭代的功能点</li>\n<li>调研功能的可行性，制定实施方案</li>\n<li>确定本版本的功能点，规划迭代<br>……</li>\n</ol>\n<p>当我们将项目拆解为行动之后，我们就可以只专注于当前行动，当前行动完成后再进入“下一步行动”，直到项目完成。</p>\n<h4 id=\"2-2-5-衣柜整理法\"><a href=\"#2-2-5-衣柜整理法\" class=\"headerlink\" title=\"2.2.5 衣柜整理法\"></a>2.2.5 衣柜整理法</h4><p>衣柜整理法是对上述时间管理方法的整理，它分为五个水平流程：收集、处理、组织、回顾、行动。</p>\n<p><strong>收集</strong></p>\n<p>收集是指收集一切引起我们注意的事情。我们在工作或者学习的时候，或许会收到各种来自同事，朋友，家人的委托。对于这些事件，我们并不应该立即去处理，而是将其收集到事件清单里。等手头的工作结束后再统一的处理。</p>\n<p><strong>处理 &amp; 组织</strong></p>\n<p>通过上述步骤，我们收集了若干事件，现在需要将其进行分类。一个要点是我们应该快速从清单的第一项开始对每一个事件进行标记，将其区分为“可以执行”和“不可执行”，直到清单的最后一项。</p>\n<p>我们将不可执行的事件分为如下三类：</p>\n<ul>\n<li>辣鸡：扔掉。</li>\n<li>将来也许可能做：记录到一个单独的清单里。</li>\n<li>参考资料：进行归档处理。</li>\n</ul>\n<p>将可以执行的事件又分为如下五类：</p>\n<ul>\n<li>2分钟之内可以搞定的事情：立即处理掉。</li>\n<li>需要多个步骤处理的事情：记录到项目清单。</li>\n<li>指派给别人的事情：立即指派。</li>\n<li>特定时间做的事情：加入日程表。</li>\n<li>待办事项：记录到代办事项清单。</li>\n</ul>\n<p>通过这样的操作，我们将事件分类到了3个清单里：项目清单，待办事项清单，将来也许会做清单。它们与我们记录的事件列表组成了 “3+1清单系统”。</p>\n<p><strong>回顾</strong></p>\n<p>对清单进行回顾有如下好处：</p>\n<ul>\n<li>站在更高的角度去看待问题。</li>\n<li>孵化那些曾经想做的事情（清理将来也许会做清单）。</li>\n</ul>\n<p>每天工作或学习前首先审视自己的清单，每周定期做回顾，把将来也许会做清单里可以做的事情取出来进行规划，没做成的事件删除；了解项目清单中的项目进度；清理待办事项清单，最后审视自己的目标。</p>\n<p><strong>行动</strong></p>\n<p>最后，如何审视自己的行动，我们需要提到“六个高度”的概念。</p>\n<p>六个高度教会我们站在六个高度来看到我们正在做的行动，让我们更快的确定自己是否处于正确的轨道上。它们分别是：</p>\n<ol>\n<li>原则（五万米视角）：我的人生目标，实现自我价值，成为对社会有用的人。</li>\n<li>愿景（四万米视角）：3-5年的展望，积累技术，成为独当一面的工程师；学会思考，成为一名有思想的产品经理。</li>\n<li>目标（三万米视角）：1-2年的目标，开发一款产品级应用，精通一种编程语言。</li>\n<li>责任（两万米视角）：我的身份对应的责任，技术，思想。</li>\n<li>项目（一万米视角）：具体的项目。</li>\n<li>行动：具体项目的实施细节。</li>\n</ol>\n<h3 id=\"2-3-规划自己的人生\"><a href=\"#2-3-规划自己的人生\" class=\"headerlink\" title=\"2.3 规划自己的人生\"></a>2.3 规划自己的人生</h3><p>如何规划自己的人生，首先我们需要目标。</p>\n<h4 id=\"2-3-1-正确的描述自己的目标\"><a href=\"#2-3-1-正确的描述自己的目标\" class=\"headerlink\" title=\"2.3.1 正确的描述自己的目标\"></a>2.3.1 正确的描述自己的目标</h4><p>描述目标的方式需要精确：<br>我的目标是1年之内独立开发一款产品并上线，为此我需要从调研开始，清晰产品定位，设计产品的功能与内在哲学，同时需要提升技术来实现每一个功能模块。当项目迎来第一个外部用户时，目标即视为实现。</p>\n<p>精确的描述使我们认清目标的可行性。</p>\n<h4 id=\"2-3-2-分解目标\"><a href=\"#2-3-2-分解目标\" class=\"headerlink\" title=\"2.3.2 分解目标\"></a>2.3.2 分解目标</h4><p>分解目标之前，我们需要具备充足的条件和理有让保持自己每一次都能够信息百倍的去向着目标前进。</p>\n<p><strong>我为什么要实现我的目标？</strong></p>\n<ol>\n<li>我渴望表现自己的想法。</li>\n<li>我希望自己的技术和思维能够解决其他人的问题。</li>\n<li>我希望增加自己在专业领域的创造力和执行力。</li>\n</ol>\n<p><strong>我为什么可以做到？</strong></p>\n<ol>\n<li>我已经掌握了该项目的大部分技术。</li>\n<li>我认为该项目能够解决我和大部分人对时间管理的需求。</li>\n<li>我已基本了解了该方向的理论了知识。</li>\n</ol>\n<p><strong>打算多久实现这个目标</strong><br>1年。</p>\n<p>接下来我们就可以开始分解目标了：<br>写下实现目标的计划：</p>\n<ol>\n<li>阅读项目主题相关领域的专业书籍，建立理论体系。</li>\n<li>整理需求点，设计产品的功能</li>\n<li>进行开发</li>\n</ol>\n<p>然后对每一项进行进一步的分解：</p>\n<ol>\n<li>阅读项目主题相关领域的专业书籍，建立理论体系。</li>\n<li>阅读《小强升职记》并写书评。</li>\n<li>了解 <code>GTD</code> 理论。</li>\n<li>阅读 《番茄钟工作法》并写书评。</li>\n<li>整理需求点，设计产品功能。</li>\n<li>假设自己就是用户，列举用户需求。</li>\n<li>调研每一个需求的可行性。</li>\n<li>规划该版本要实现的需求。</li>\n<li>规划迭代</li>\n<li>开发</li>\n<li>确定技术栈<br>  ……</li>\n</ol>\n<h2 id=\"3-最后\"><a href=\"#3-最后\" class=\"headerlink\" title=\"3. 最后\"></a>3. 最后</h2><p>以上是本书的一些总结，第一次写这种书评和笔记，确实发现自己的思路非常混乱，并且在写的时候又几乎把书重新翻了一遍- -!</p>\n<p>时间管理是一种自我投资，我认为未来会有越来越多的人（尤其是年轻人）意识到时间管理的重要性，这不是在玩某种梗文化，而是快节奏生活下最真实的需求。我也真切的希望这篇文章能够帮助到点进来的任何一个读者，如果你对时间管理有任何心得或者想法，欢迎在文章下方留言。同样也欢迎将我的文章分享给你的朋友们，你们的支持是我最大的动力，谢谢！。</p>\n"},{"title":"扒视频！Ruby爬虫初探","date":"2020-06-11T11:25:25.000Z","_content":"\n> 写在最前面：出于学习目的，我在网络上分享了这篇文章。但我不能保证我的文章是否会给文章里的站点带来困扰，因而文中将不会出现该站点的真实访问路径。\n\n## 1. 起因\n最近因为公司产品需要，老板交代我从某网站下载大量的资源，网站的资源列表一共有116页，每一页有16个子页面，进入子页面后拿到百度云分享链接的提取码，然后进入分享页面输入提取码，登录百度云账号，将文件保存到云盘，最后使用百度云客户端进行下载。\n\n我看了下页码和网站的响应速度，顿时感觉此事没那么简单，掏出了我的计算器进行计算：`116*16=1856`，该网站的服务器在国外，初步评测发现，打开首页 -> 进入详情页-> 打开百度云分享页 -> 输入密码并提取文件 -> 保存到自己的百度云盘，这个过程至少也要花1分钟。也就是说保存完所有的资源我们**需要花上`30`小时以上**！\n\n\n## 2. 爬虫\n大概在前年的时候，那会儿我刚开始学习写代码，在朋友的推荐下开始使用简书来记录学习的一些心得。记得当时铺天盖地的营销号标题：《我用`Python`爬虫爬了xxGxx资源》看的我好生羡慕，后来虽然没有学`Python`，但摸鱼的时候还是去尝试着鼓捣了一下。\n\n### 2.1 爬虫的前置知识\n爬虫并不是什么神秘的东西，从一个比较基础的层面上讲，爬虫就仅仅是一种围绕拉取网站资源而展开的脚本而已。\n\n**请求**\n\n我们知道，当我们在浏览器里访问一个页面时，实际上是发出了一个`GET`请求，服务器接收请求并响应`HTML`静态页面给浏览器，最终浏览器渲染页面并展示给用户，一次访问就完成了。\n\n**渲染**\n\n不管什么样的页面，在请求后一样都是由服务器返回`HTML`静态页面给浏览器，但在实际的架构实践中，我们要区分服务端渲染与客户端渲染。\n\n基于服务端渲染的技术包括了`JSP``ASP`等，它们会在接收请求后将生成的静态页面发送给客户端，页面到达客户端时就已经是页面最终的样子。\n\n基于客户端渲染的技术包括了`VUE`,`React`等，它们在接受请求后返回入口页和`JavaScript`脚本文件，当页面到达客户端后，`JavaScript`执行渲染来呈现最终的页面。\n\n这两者最大的区别就在于，当我们拉取页面结构时，基于服务端渲染的页面会返回完整的`HTML`结构，而基于客户端渲染的页面则只返回最基础的入口页标签。我们可以通过如下两张图对比差异：\n\n![服务端渲染](./images/ba-shi-pin-ruby-pa-chong-chu-tan/ssr.png)\n\n![客户端渲染](./images/ba-shi-pin-ruby-pa-chong-chu-tan/csr.png)\n\n上图我们拉取了服务端渲染的百度，很显然我们拿到了所有的页面标签；而下图中，我们拉取了客户端渲染的`antd pro`，在页面中，除了大量的`<script></script>`标签外，我们只看到了少数入口标签如`<div id='root'></div>`。\n\n**数据**\n\n我们编写爬虫是为了从站点中获取数据，但上述的图例中我们显然没有成功的从客户端渲染的页面里获取到期望的数据。\n\n参考一下客户端渲染的实践，我们通常在组件挂载后请求数据。这里重点就来了，既然客户端渲染是请求数据，那么我们又何必拘束与非要从页面上拉取数据呢？因此针对客户端渲染，我们不妨使用模拟请求的方式进行数据的拉取。\n\n### 2.2 工具介绍\n在BB了这么多之后，还需要介绍一下在本次案例中使用到的工具与库，我使用的是 `Ruby` 语言，但编写爬虫并不局限你使用哪一种语言。\n- `nokogiri`库：一个解析`HTML/XML`字符串的库，它可以将`HTML/XML`字符串解析为我们熟悉的`HTML`元素对象，同时还提供了`css`选择器风格的过滤方法。\n- `rest-client`库：一个请求库，它用起来就像`axios`一样方便。\n- `open-uri`：同上。\n- `json`：`JSON`解析库。\n- `chrome`调试工具：不多解释了。\n\n### 2.3 编码\n在准备工作做好之后，我们就可以开始代码的遍写了。\n\n**获取每一页的所有Item项的访问地址**\n\n首先我们应该通过`chrome`的代码审查来确定页面到底基于什么样的方式构建。\n\n可以看到如下图所示，我们右击选择查看网页源代码，就可以看到该页面的列表实际上使用了`JavaScript`来渲染。\n\n![首页列表](./images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list.png)\n\n![列表js脚本](./images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list_javascript.png)\n\n确定了列表是使用`JavaScript`渲染之后，我们可以打开`Chrome`开发者工具，选择`network`里的`XHR`并刷新页面，我们不难找到有个叫做`launchpad/fetch`的接口，它的返回值里包含了一个长度为16的数组，页面里的列表正是使用了这个数组进行遍历渲染。稍微查阅一下该请求的请求头，参数等部分，我们很容易得到如下信息：\n\n接口名|参数|备注\n--|:--:|--:\n/api/launchpad/fetch|pageNo/pageSize|传递页码/数据量，返回每个列表项页面的唯一ID\n\n代码：\n~~~ruby\nFETCH_ITEM_URL = 'http://.../api/launchpad/fetch'.freeze\nresponse = RestClient.post(FETCH_ITEM_URL,\n                          'pageNo': page_no,\n                          'pageSize': 16)\nproject_list_data = JSON.parse(response.body)['result']\n~~~\n我们再次查阅源站页面，发现，接口中返回的`prefectureId`将作为`URL`参数直接传递到子页面，就像这样：\n~~~ \nhttp://.../home/launchpad/detail?prefectureId=prefectureId\n~~~\n我们只需要遍历`project_list_data`数组，就可以获得当前页面列表中，所有子列表项的访问地址：\n~~~ ruby\nproject_list_data.each do |project|\n  prefecture_id = project['prefectureId']\n  project_item_url = ITEM_PAGE_URL + prefecture_id.to_s\nend\n~~~\n\n**访问子页面下载视频**\n\n在我刚写完获取首页列表项（我们后面统称为子页面）的访问链接时，我的老板又给我追加了一个任务：**下载子页面上的视频**。\n\n没有任何问题，我们依然从页面审查开始：\n![视频页面元素](./images/ba-shi-pin-ruby-pa-chong-chu-tan/video_href.png)\n\n如图我们首先确定了这个页面（至少视频部分）是使用服务端渲染的，并且很快找到了页面中的`video`元素，不难发现`src`属性中的链接似乎就是我们希望找到的东西，将其复制，在浏览器中打开，成功看到了我们想要的视频，Good~\n\n当我们拿到这样一个链接后，想要将其下载是非常简单的：\n~~~ ruby\nitem_page = Nokogiri::HTML(open(project_item_url))\nvideo_url = item_page.css('.container source')[0]['src']\nfile_name = video_url[video_url.rindex('/') + 1..-1]\n\nputs \"#{file_name}下载完成\"\n\nvideo = RestClient.get(URI.encode(video_url))\n\nfile = File.open(\"videos/#{file_name}.mp4\", \"a+\")\nif file\n  file.syswrite(video)\nend\n~~~\n拉取子页面并使用`nokogiri`进行解析，然后我们就像写`JQuery`一样使用`css`选择器获取了`video`元素并读取到了`src`属性。\n\n我们使用`GET`方法请求该属性即可拿到视频的数据，然后将其写出到指定的文件目录里，一个视频就简单粗暴的下载好了，为了让每个视频都有自己的名字，我们简单的使用字符串方法截取了视频的名字，现在当我们运行脚本，就可以看到`videos`目录下有一个又一个视频冒出来~\n\n![下载视频](./images/ba-shi-pin-ruby-pa-chong-chu-tan/download_video_result.png)\n\n#### 2.3.3 访问子页面获取资源提取码与分享地址\n\n#### 2.3.4 使用提取码提取文件\n\n#### 2.3.5 将文件转存到我的百度云盘\n\n### 2.4 成果\n\n## 3. 总结\n## 4. 尾声\n","source":"_posts/扒视频！Ruby爬虫初探.md","raw":"---\ntitle: 扒视频！Ruby爬虫初探\ndate: 2020-06-11 19:25:25\ntags:\n  - Ruby\n  - 后端\n  - 爬虫\ncategories:\n  - 程序员的幸福：让代码变成强有力的工具\n---\n\n> 写在最前面：出于学习目的，我在网络上分享了这篇文章。但我不能保证我的文章是否会给文章里的站点带来困扰，因而文中将不会出现该站点的真实访问路径。\n\n## 1. 起因\n最近因为公司产品需要，老板交代我从某网站下载大量的资源，网站的资源列表一共有116页，每一页有16个子页面，进入子页面后拿到百度云分享链接的提取码，然后进入分享页面输入提取码，登录百度云账号，将文件保存到云盘，最后使用百度云客户端进行下载。\n\n我看了下页码和网站的响应速度，顿时感觉此事没那么简单，掏出了我的计算器进行计算：`116*16=1856`，该网站的服务器在国外，初步评测发现，打开首页 -> 进入详情页-> 打开百度云分享页 -> 输入密码并提取文件 -> 保存到自己的百度云盘，这个过程至少也要花1分钟。也就是说保存完所有的资源我们**需要花上`30`小时以上**！\n\n\n## 2. 爬虫\n大概在前年的时候，那会儿我刚开始学习写代码，在朋友的推荐下开始使用简书来记录学习的一些心得。记得当时铺天盖地的营销号标题：《我用`Python`爬虫爬了xxGxx资源》看的我好生羡慕，后来虽然没有学`Python`，但摸鱼的时候还是去尝试着鼓捣了一下。\n\n### 2.1 爬虫的前置知识\n爬虫并不是什么神秘的东西，从一个比较基础的层面上讲，爬虫就仅仅是一种围绕拉取网站资源而展开的脚本而已。\n\n**请求**\n\n我们知道，当我们在浏览器里访问一个页面时，实际上是发出了一个`GET`请求，服务器接收请求并响应`HTML`静态页面给浏览器，最终浏览器渲染页面并展示给用户，一次访问就完成了。\n\n**渲染**\n\n不管什么样的页面，在请求后一样都是由服务器返回`HTML`静态页面给浏览器，但在实际的架构实践中，我们要区分服务端渲染与客户端渲染。\n\n基于服务端渲染的技术包括了`JSP``ASP`等，它们会在接收请求后将生成的静态页面发送给客户端，页面到达客户端时就已经是页面最终的样子。\n\n基于客户端渲染的技术包括了`VUE`,`React`等，它们在接受请求后返回入口页和`JavaScript`脚本文件，当页面到达客户端后，`JavaScript`执行渲染来呈现最终的页面。\n\n这两者最大的区别就在于，当我们拉取页面结构时，基于服务端渲染的页面会返回完整的`HTML`结构，而基于客户端渲染的页面则只返回最基础的入口页标签。我们可以通过如下两张图对比差异：\n\n![服务端渲染](./images/ba-shi-pin-ruby-pa-chong-chu-tan/ssr.png)\n\n![客户端渲染](./images/ba-shi-pin-ruby-pa-chong-chu-tan/csr.png)\n\n上图我们拉取了服务端渲染的百度，很显然我们拿到了所有的页面标签；而下图中，我们拉取了客户端渲染的`antd pro`，在页面中，除了大量的`<script></script>`标签外，我们只看到了少数入口标签如`<div id='root'></div>`。\n\n**数据**\n\n我们编写爬虫是为了从站点中获取数据，但上述的图例中我们显然没有成功的从客户端渲染的页面里获取到期望的数据。\n\n参考一下客户端渲染的实践，我们通常在组件挂载后请求数据。这里重点就来了，既然客户端渲染是请求数据，那么我们又何必拘束与非要从页面上拉取数据呢？因此针对客户端渲染，我们不妨使用模拟请求的方式进行数据的拉取。\n\n### 2.2 工具介绍\n在BB了这么多之后，还需要介绍一下在本次案例中使用到的工具与库，我使用的是 `Ruby` 语言，但编写爬虫并不局限你使用哪一种语言。\n- `nokogiri`库：一个解析`HTML/XML`字符串的库，它可以将`HTML/XML`字符串解析为我们熟悉的`HTML`元素对象，同时还提供了`css`选择器风格的过滤方法。\n- `rest-client`库：一个请求库，它用起来就像`axios`一样方便。\n- `open-uri`：同上。\n- `json`：`JSON`解析库。\n- `chrome`调试工具：不多解释了。\n\n### 2.3 编码\n在准备工作做好之后，我们就可以开始代码的遍写了。\n\n**获取每一页的所有Item项的访问地址**\n\n首先我们应该通过`chrome`的代码审查来确定页面到底基于什么样的方式构建。\n\n可以看到如下图所示，我们右击选择查看网页源代码，就可以看到该页面的列表实际上使用了`JavaScript`来渲染。\n\n![首页列表](./images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list.png)\n\n![列表js脚本](./images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list_javascript.png)\n\n确定了列表是使用`JavaScript`渲染之后，我们可以打开`Chrome`开发者工具，选择`network`里的`XHR`并刷新页面，我们不难找到有个叫做`launchpad/fetch`的接口，它的返回值里包含了一个长度为16的数组，页面里的列表正是使用了这个数组进行遍历渲染。稍微查阅一下该请求的请求头，参数等部分，我们很容易得到如下信息：\n\n接口名|参数|备注\n--|:--:|--:\n/api/launchpad/fetch|pageNo/pageSize|传递页码/数据量，返回每个列表项页面的唯一ID\n\n代码：\n~~~ruby\nFETCH_ITEM_URL = 'http://.../api/launchpad/fetch'.freeze\nresponse = RestClient.post(FETCH_ITEM_URL,\n                          'pageNo': page_no,\n                          'pageSize': 16)\nproject_list_data = JSON.parse(response.body)['result']\n~~~\n我们再次查阅源站页面，发现，接口中返回的`prefectureId`将作为`URL`参数直接传递到子页面，就像这样：\n~~~ \nhttp://.../home/launchpad/detail?prefectureId=prefectureId\n~~~\n我们只需要遍历`project_list_data`数组，就可以获得当前页面列表中，所有子列表项的访问地址：\n~~~ ruby\nproject_list_data.each do |project|\n  prefecture_id = project['prefectureId']\n  project_item_url = ITEM_PAGE_URL + prefecture_id.to_s\nend\n~~~\n\n**访问子页面下载视频**\n\n在我刚写完获取首页列表项（我们后面统称为子页面）的访问链接时，我的老板又给我追加了一个任务：**下载子页面上的视频**。\n\n没有任何问题，我们依然从页面审查开始：\n![视频页面元素](./images/ba-shi-pin-ruby-pa-chong-chu-tan/video_href.png)\n\n如图我们首先确定了这个页面（至少视频部分）是使用服务端渲染的，并且很快找到了页面中的`video`元素，不难发现`src`属性中的链接似乎就是我们希望找到的东西，将其复制，在浏览器中打开，成功看到了我们想要的视频，Good~\n\n当我们拿到这样一个链接后，想要将其下载是非常简单的：\n~~~ ruby\nitem_page = Nokogiri::HTML(open(project_item_url))\nvideo_url = item_page.css('.container source')[0]['src']\nfile_name = video_url[video_url.rindex('/') + 1..-1]\n\nputs \"#{file_name}下载完成\"\n\nvideo = RestClient.get(URI.encode(video_url))\n\nfile = File.open(\"videos/#{file_name}.mp4\", \"a+\")\nif file\n  file.syswrite(video)\nend\n~~~\n拉取子页面并使用`nokogiri`进行解析，然后我们就像写`JQuery`一样使用`css`选择器获取了`video`元素并读取到了`src`属性。\n\n我们使用`GET`方法请求该属性即可拿到视频的数据，然后将其写出到指定的文件目录里，一个视频就简单粗暴的下载好了，为了让每个视频都有自己的名字，我们简单的使用字符串方法截取了视频的名字，现在当我们运行脚本，就可以看到`videos`目录下有一个又一个视频冒出来~\n\n![下载视频](./images/ba-shi-pin-ruby-pa-chong-chu-tan/download_video_result.png)\n\n#### 2.3.3 访问子页面获取资源提取码与分享地址\n\n#### 2.3.4 使用提取码提取文件\n\n#### 2.3.5 将文件转存到我的百度云盘\n\n### 2.4 成果\n\n## 3. 总结\n## 4. 尾声\n","slug":"扒视频！Ruby爬虫初探","published":1,"updated":"2022-05-03T09:25:26.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mduo002nr2ve416gh35m","content":"<blockquote>\n<p>写在最前面：出于学习目的，我在网络上分享了这篇文章。但我不能保证我的文章是否会给文章里的站点带来困扰，因而文中将不会出现该站点的真实访问路径。</p>\n</blockquote>\n<h2 id=\"1-起因\"><a href=\"#1-起因\" class=\"headerlink\" title=\"1. 起因\"></a>1. 起因</h2><p>最近因为公司产品需要，老板交代我从某网站下载大量的资源，网站的资源列表一共有116页，每一页有16个子页面，进入子页面后拿到百度云分享链接的提取码，然后进入分享页面输入提取码，登录百度云账号，将文件保存到云盘，最后使用百度云客户端进行下载。</p>\n<p>我看了下页码和网站的响应速度，顿时感觉此事没那么简单，掏出了我的计算器进行计算：<code>116*16=1856</code>，该网站的服务器在国外，初步评测发现，打开首页 -&gt; 进入详情页-&gt; 打开百度云分享页 -&gt; 输入密码并提取文件 -&gt; 保存到自己的百度云盘，这个过程至少也要花1分钟。也就是说保存完所有的资源我们<strong>需要花上<code>30</code>小时以上</strong>！</p>\n<h2 id=\"2-爬虫\"><a href=\"#2-爬虫\" class=\"headerlink\" title=\"2. 爬虫\"></a>2. 爬虫</h2><p>大概在前年的时候，那会儿我刚开始学习写代码，在朋友的推荐下开始使用简书来记录学习的一些心得。记得当时铺天盖地的营销号标题：《我用<code>Python</code>爬虫爬了xxGxx资源》看的我好生羡慕，后来虽然没有学<code>Python</code>，但摸鱼的时候还是去尝试着鼓捣了一下。</p>\n<h3 id=\"2-1-爬虫的前置知识\"><a href=\"#2-1-爬虫的前置知识\" class=\"headerlink\" title=\"2.1 爬虫的前置知识\"></a>2.1 爬虫的前置知识</h3><p>爬虫并不是什么神秘的东西，从一个比较基础的层面上讲，爬虫就仅仅是一种围绕拉取网站资源而展开的脚本而已。</p>\n<p><strong>请求</strong></p>\n<p>我们知道，当我们在浏览器里访问一个页面时，实际上是发出了一个<code>GET</code>请求，服务器接收请求并响应<code>HTML</code>静态页面给浏览器，最终浏览器渲染页面并展示给用户，一次访问就完成了。</p>\n<p><strong>渲染</strong></p>\n<p>不管什么样的页面，在请求后一样都是由服务器返回<code>HTML</code>静态页面给浏览器，但在实际的架构实践中，我们要区分服务端渲染与客户端渲染。</p>\n<p>基于服务端渲染的技术包括了<code>JSP``ASP</code>等，它们会在接收请求后将生成的静态页面发送给客户端，页面到达客户端时就已经是页面最终的样子。</p>\n<p>基于客户端渲染的技术包括了<code>VUE</code>,<code>React</code>等，它们在接受请求后返回入口页和<code>JavaScript</code>脚本文件，当页面到达客户端后，<code>JavaScript</code>执行渲染来呈现最终的页面。</p>\n<p>这两者最大的区别就在于，当我们拉取页面结构时，基于服务端渲染的页面会返回完整的<code>HTML</code>结构，而基于客户端渲染的页面则只返回最基础的入口页标签。我们可以通过如下两张图对比差异：</p>\n<p><img src=\"/./images/ba-shi-pin-ruby-pa-chong-chu-tan/ssr.png\" alt=\"服务端渲染\"></p>\n<p><img src=\"/./images/ba-shi-pin-ruby-pa-chong-chu-tan/csr.png\" alt=\"客户端渲染\"></p>\n<p>上图我们拉取了服务端渲染的百度，很显然我们拿到了所有的页面标签；而下图中，我们拉取了客户端渲染的<code>antd pro</code>，在页面中，除了大量的<code>&lt;script&gt;&lt;/script&gt;</code>标签外，我们只看到了少数入口标签如<code>&lt;div id=&#39;root&#39;&gt;&lt;/div&gt;</code>。</p>\n<p><strong>数据</strong></p>\n<p>我们编写爬虫是为了从站点中获取数据，但上述的图例中我们显然没有成功的从客户端渲染的页面里获取到期望的数据。</p>\n<p>参考一下客户端渲染的实践，我们通常在组件挂载后请求数据。这里重点就来了，既然客户端渲染是请求数据，那么我们又何必拘束与非要从页面上拉取数据呢？因此针对客户端渲染，我们不妨使用模拟请求的方式进行数据的拉取。</p>\n<h3 id=\"2-2-工具介绍\"><a href=\"#2-2-工具介绍\" class=\"headerlink\" title=\"2.2 工具介绍\"></a>2.2 工具介绍</h3><p>在BB了这么多之后，还需要介绍一下在本次案例中使用到的工具与库，我使用的是 <code>Ruby</code> 语言，但编写爬虫并不局限你使用哪一种语言。</p>\n<ul>\n<li><code>nokogiri</code>库：一个解析<code>HTML/XML</code>字符串的库，它可以将<code>HTML/XML</code>字符串解析为我们熟悉的<code>HTML</code>元素对象，同时还提供了<code>css</code>选择器风格的过滤方法。</li>\n<li><code>rest-client</code>库：一个请求库，它用起来就像<code>axios</code>一样方便。</li>\n<li><code>open-uri</code>：同上。</li>\n<li><code>json</code>：<code>JSON</code>解析库。</li>\n<li><code>chrome</code>调试工具：不多解释了。</li>\n</ul>\n<h3 id=\"2-3-编码\"><a href=\"#2-3-编码\" class=\"headerlink\" title=\"2.3 编码\"></a>2.3 编码</h3><p>在准备工作做好之后，我们就可以开始代码的遍写了。</p>\n<p><strong>获取每一页的所有Item项的访问地址</strong></p>\n<p>首先我们应该通过<code>chrome</code>的代码审查来确定页面到底基于什么样的方式构建。</p>\n<p>可以看到如下图所示，我们右击选择查看网页源代码，就可以看到该页面的列表实际上使用了<code>JavaScript</code>来渲染。</p>\n<p><img src=\"/./images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list.png\" alt=\"首页列表\"></p>\n<p><img src=\"/./images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list_javascript.png\" alt=\"列表js脚本\"></p>\n<p>确定了列表是使用<code>JavaScript</code>渲染之后，我们可以打开<code>Chrome</code>开发者工具，选择<code>network</code>里的<code>XHR</code>并刷新页面，我们不难找到有个叫做<code>launchpad/fetch</code>的接口，它的返回值里包含了一个长度为16的数组，页面里的列表正是使用了这个数组进行遍历渲染。稍微查阅一下该请求的请求头，参数等部分，我们很容易得到如下信息：</p>\n<table>\n<thead>\n<tr>\n<th>接口名</th>\n<th align=\"center\">参数</th>\n<th align=\"right\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x2F;api&#x2F;launchpad&#x2F;fetch</td>\n<td align=\"center\">pageNo&#x2F;pageSize</td>\n<td align=\"right\">传递页码&#x2F;数据量，返回每个列表项页面的唯一ID</td>\n</tr>\n</tbody></table>\n<p>代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">FETCH_ITEM_URL</span> = <span class=\"string\">&#x27;http://.../api/launchpad/fetch&#x27;</span>.freeze</span><br><span class=\"line\">response = RestClient.post(<span class=\"variable constant_\">FETCH_ITEM_URL</span>,</span><br><span class=\"line\">                          <span class=\"string\">&#x27;pageNo&#x27;</span>: page_no,</span><br><span class=\"line\">                          <span class=\"string\">&#x27;pageSize&#x27;</span>: <span class=\"number\">16</span>)</span><br><span class=\"line\">project_list_data = <span class=\"variable constant_\">JSON</span>.parse(response.body)[<span class=\"string\">&#x27;result&#x27;</span>]</span><br></pre></td></tr></table></figure>\n<p>我们再次查阅源站页面，发现，接口中返回的<code>prefectureId</code>将作为<code>URL</code>参数直接传递到子页面，就像这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://.../home/launchpad/detail?prefectureId=prefectureId</span><br></pre></td></tr></table></figure>\n<p>我们只需要遍历<code>project_list_data</code>数组，就可以获得当前页面列表中，所有子列表项的访问地址：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project_list_data.each <span class=\"keyword\">do</span> |<span class=\"params\">project</span>|</span><br><span class=\"line\">  prefecture_id = project[<span class=\"string\">&#x27;prefectureId&#x27;</span>]</span><br><span class=\"line\">  project_item_url = <span class=\"variable constant_\">ITEM_PAGE_URL</span> + prefecture_id.to_s</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>访问子页面下载视频</strong></p>\n<p>在我刚写完获取首页列表项（我们后面统称为子页面）的访问链接时，我的老板又给我追加了一个任务：<strong>下载子页面上的视频</strong>。</p>\n<p>没有任何问题，我们依然从页面审查开始：<br><img src=\"/./images/ba-shi-pin-ruby-pa-chong-chu-tan/video_href.png\" alt=\"视频页面元素\"></p>\n<p>如图我们首先确定了这个页面（至少视频部分）是使用服务端渲染的，并且很快找到了页面中的<code>video</code>元素，不难发现<code>src</code>属性中的链接似乎就是我们希望找到的东西，将其复制，在浏览器中打开，成功看到了我们想要的视频，Good~</p>\n<p>当我们拿到这样一个链接后，想要将其下载是非常简单的：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item_page = Nokogiri::<span class=\"variable constant_\">HTML</span>(open(project_item_url))</span><br><span class=\"line\">video_url = item_page.css(<span class=\"string\">&#x27;.container source&#x27;</span>)[<span class=\"number\">0</span>][<span class=\"string\">&#x27;src&#x27;</span>]</span><br><span class=\"line\">file_name = video_url[video_url.rindex(<span class=\"string\">&#x27;/&#x27;</span>) + <span class=\"number\">1</span>..-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">puts <span class=\"string\">&quot;<span class=\"subst\">#&#123;file_name&#125;</span>下载完成&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">video = RestClient.get(<span class=\"variable constant_\">URI</span>.encode(video_url))</span><br><span class=\"line\"></span><br><span class=\"line\">file = File.open(<span class=\"string\">&quot;videos/<span class=\"subst\">#&#123;file_name&#125;</span>.mp4&quot;</span>, <span class=\"string\">&quot;a+&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> file</span><br><span class=\"line\">  file.syswrite(video)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>拉取子页面并使用<code>nokogiri</code>进行解析，然后我们就像写<code>JQuery</code>一样使用<code>css</code>选择器获取了<code>video</code>元素并读取到了<code>src</code>属性。</p>\n<p>我们使用<code>GET</code>方法请求该属性即可拿到视频的数据，然后将其写出到指定的文件目录里，一个视频就简单粗暴的下载好了，为了让每个视频都有自己的名字，我们简单的使用字符串方法截取了视频的名字，现在当我们运行脚本，就可以看到<code>videos</code>目录下有一个又一个视频冒出来~</p>\n<p><img src=\"/./images/ba-shi-pin-ruby-pa-chong-chu-tan/download_video_result.png\" alt=\"下载视频\"></p>\n<h4 id=\"2-3-3-访问子页面获取资源提取码与分享地址\"><a href=\"#2-3-3-访问子页面获取资源提取码与分享地址\" class=\"headerlink\" title=\"2.3.3 访问子页面获取资源提取码与分享地址\"></a>2.3.3 访问子页面获取资源提取码与分享地址</h4><h4 id=\"2-3-4-使用提取码提取文件\"><a href=\"#2-3-4-使用提取码提取文件\" class=\"headerlink\" title=\"2.3.4 使用提取码提取文件\"></a>2.3.4 使用提取码提取文件</h4><h4 id=\"2-3-5-将文件转存到我的百度云盘\"><a href=\"#2-3-5-将文件转存到我的百度云盘\" class=\"headerlink\" title=\"2.3.5 将文件转存到我的百度云盘\"></a>2.3.5 将文件转存到我的百度云盘</h4><h3 id=\"2-4-成果\"><a href=\"#2-4-成果\" class=\"headerlink\" title=\"2.4 成果\"></a>2.4 成果</h3><h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h2><h2 id=\"4-尾声\"><a href=\"#4-尾声\" class=\"headerlink\" title=\"4. 尾声\"></a>4. 尾声</h2>","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<blockquote>\n<p>写在最前面：出于学习目的，我在网络上分享了这篇文章。但我不能保证我的文章是否会给文章里的站点带来困扰，因而文中将不会出现该站点的真实访问路径。</p>\n</blockquote>\n<h2 id=\"1-起因\"><a href=\"#1-起因\" class=\"headerlink\" title=\"1. 起因\"></a>1. 起因</h2><p>最近因为公司产品需要，老板交代我从某网站下载大量的资源，网站的资源列表一共有116页，每一页有16个子页面，进入子页面后拿到百度云分享链接的提取码，然后进入分享页面输入提取码，登录百度云账号，将文件保存到云盘，最后使用百度云客户端进行下载。</p>\n<p>我看了下页码和网站的响应速度，顿时感觉此事没那么简单，掏出了我的计算器进行计算：<code>116*16=1856</code>，该网站的服务器在国外，初步评测发现，打开首页 -&gt; 进入详情页-&gt; 打开百度云分享页 -&gt; 输入密码并提取文件 -&gt; 保存到自己的百度云盘，这个过程至少也要花1分钟。也就是说保存完所有的资源我们<strong>需要花上<code>30</code>小时以上</strong>！</p>\n<h2 id=\"2-爬虫\"><a href=\"#2-爬虫\" class=\"headerlink\" title=\"2. 爬虫\"></a>2. 爬虫</h2><p>大概在前年的时候，那会儿我刚开始学习写代码，在朋友的推荐下开始使用简书来记录学习的一些心得。记得当时铺天盖地的营销号标题：《我用<code>Python</code>爬虫爬了xxGxx资源》看的我好生羡慕，后来虽然没有学<code>Python</code>，但摸鱼的时候还是去尝试着鼓捣了一下。</p>\n<h3 id=\"2-1-爬虫的前置知识\"><a href=\"#2-1-爬虫的前置知识\" class=\"headerlink\" title=\"2.1 爬虫的前置知识\"></a>2.1 爬虫的前置知识</h3><p>爬虫并不是什么神秘的东西，从一个比较基础的层面上讲，爬虫就仅仅是一种围绕拉取网站资源而展开的脚本而已。</p>\n<p><strong>请求</strong></p>\n<p>我们知道，当我们在浏览器里访问一个页面时，实际上是发出了一个<code>GET</code>请求，服务器接收请求并响应<code>HTML</code>静态页面给浏览器，最终浏览器渲染页面并展示给用户，一次访问就完成了。</p>\n<p><strong>渲染</strong></p>\n<p>不管什么样的页面，在请求后一样都是由服务器返回<code>HTML</code>静态页面给浏览器，但在实际的架构实践中，我们要区分服务端渲染与客户端渲染。</p>\n<p>基于服务端渲染的技术包括了<code>JSP``ASP</code>等，它们会在接收请求后将生成的静态页面发送给客户端，页面到达客户端时就已经是页面最终的样子。</p>\n<p>基于客户端渲染的技术包括了<code>VUE</code>,<code>React</code>等，它们在接受请求后返回入口页和<code>JavaScript</code>脚本文件，当页面到达客户端后，<code>JavaScript</code>执行渲染来呈现最终的页面。</p>\n<p>这两者最大的区别就在于，当我们拉取页面结构时，基于服务端渲染的页面会返回完整的<code>HTML</code>结构，而基于客户端渲染的页面则只返回最基础的入口页标签。我们可以通过如下两张图对比差异：</p>\n<p><img src=\"/./images/ba-shi-pin-ruby-pa-chong-chu-tan/ssr.png\" alt=\"服务端渲染\"></p>\n<p><img src=\"/./images/ba-shi-pin-ruby-pa-chong-chu-tan/csr.png\" alt=\"客户端渲染\"></p>\n<p>上图我们拉取了服务端渲染的百度，很显然我们拿到了所有的页面标签；而下图中，我们拉取了客户端渲染的<code>antd pro</code>，在页面中，除了大量的<code>&lt;script&gt;&lt;/script&gt;</code>标签外，我们只看到了少数入口标签如<code>&lt;div id=&#39;root&#39;&gt;&lt;/div&gt;</code>。</p>\n<p><strong>数据</strong></p>\n<p>我们编写爬虫是为了从站点中获取数据，但上述的图例中我们显然没有成功的从客户端渲染的页面里获取到期望的数据。</p>\n<p>参考一下客户端渲染的实践，我们通常在组件挂载后请求数据。这里重点就来了，既然客户端渲染是请求数据，那么我们又何必拘束与非要从页面上拉取数据呢？因此针对客户端渲染，我们不妨使用模拟请求的方式进行数据的拉取。</p>\n<h3 id=\"2-2-工具介绍\"><a href=\"#2-2-工具介绍\" class=\"headerlink\" title=\"2.2 工具介绍\"></a>2.2 工具介绍</h3><p>在BB了这么多之后，还需要介绍一下在本次案例中使用到的工具与库，我使用的是 <code>Ruby</code> 语言，但编写爬虫并不局限你使用哪一种语言。</p>\n<ul>\n<li><code>nokogiri</code>库：一个解析<code>HTML/XML</code>字符串的库，它可以将<code>HTML/XML</code>字符串解析为我们熟悉的<code>HTML</code>元素对象，同时还提供了<code>css</code>选择器风格的过滤方法。</li>\n<li><code>rest-client</code>库：一个请求库，它用起来就像<code>axios</code>一样方便。</li>\n<li><code>open-uri</code>：同上。</li>\n<li><code>json</code>：<code>JSON</code>解析库。</li>\n<li><code>chrome</code>调试工具：不多解释了。</li>\n</ul>\n<h3 id=\"2-3-编码\"><a href=\"#2-3-编码\" class=\"headerlink\" title=\"2.3 编码\"></a>2.3 编码</h3><p>在准备工作做好之后，我们就可以开始代码的遍写了。</p>\n<p><strong>获取每一页的所有Item项的访问地址</strong></p>\n<p>首先我们应该通过<code>chrome</code>的代码审查来确定页面到底基于什么样的方式构建。</p>\n<p>可以看到如下图所示，我们右击选择查看网页源代码，就可以看到该页面的列表实际上使用了<code>JavaScript</code>来渲染。</p>\n<p><img src=\"/./images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list.png\" alt=\"首页列表\"></p>\n<p><img src=\"/./images/ba-shi-pin-ruby-pa-chong-chu-tan/home_list_javascript.png\" alt=\"列表js脚本\"></p>\n<p>确定了列表是使用<code>JavaScript</code>渲染之后，我们可以打开<code>Chrome</code>开发者工具，选择<code>network</code>里的<code>XHR</code>并刷新页面，我们不难找到有个叫做<code>launchpad/fetch</code>的接口，它的返回值里包含了一个长度为16的数组，页面里的列表正是使用了这个数组进行遍历渲染。稍微查阅一下该请求的请求头，参数等部分，我们很容易得到如下信息：</p>\n<table>\n<thead>\n<tr>\n<th>接口名</th>\n<th align=\"center\">参数</th>\n<th align=\"right\">备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x2F;api&#x2F;launchpad&#x2F;fetch</td>\n<td align=\"center\">pageNo&#x2F;pageSize</td>\n<td align=\"right\">传递页码&#x2F;数据量，返回每个列表项页面的唯一ID</td>\n</tr>\n</tbody></table>\n<p>代码：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable constant_\">FETCH_ITEM_URL</span> = <span class=\"string\">&#x27;http://.../api/launchpad/fetch&#x27;</span>.freeze</span><br><span class=\"line\">response = RestClient.post(<span class=\"variable constant_\">FETCH_ITEM_URL</span>,</span><br><span class=\"line\">                          <span class=\"string\">&#x27;pageNo&#x27;</span>: page_no,</span><br><span class=\"line\">                          <span class=\"string\">&#x27;pageSize&#x27;</span>: <span class=\"number\">16</span>)</span><br><span class=\"line\">project_list_data = <span class=\"variable constant_\">JSON</span>.parse(response.body)[<span class=\"string\">&#x27;result&#x27;</span>]</span><br></pre></td></tr></table></figure>\n<p>我们再次查阅源站页面，发现，接口中返回的<code>prefectureId</code>将作为<code>URL</code>参数直接传递到子页面，就像这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://.../home/launchpad/detail?prefectureId=prefectureId</span><br></pre></td></tr></table></figure>\n<p>我们只需要遍历<code>project_list_data</code>数组，就可以获得当前页面列表中，所有子列表项的访问地址：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">project_list_data.each <span class=\"keyword\">do</span> |<span class=\"params\">project</span>|</span><br><span class=\"line\">  prefecture_id = project[<span class=\"string\">&#x27;prefectureId&#x27;</span>]</span><br><span class=\"line\">  project_item_url = <span class=\"variable constant_\">ITEM_PAGE_URL</span> + prefecture_id.to_s</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>访问子页面下载视频</strong></p>\n<p>在我刚写完获取首页列表项（我们后面统称为子页面）的访问链接时，我的老板又给我追加了一个任务：<strong>下载子页面上的视频</strong>。</p>\n<p>没有任何问题，我们依然从页面审查开始：<br><img src=\"/./images/ba-shi-pin-ruby-pa-chong-chu-tan/video_href.png\" alt=\"视频页面元素\"></p>\n<p>如图我们首先确定了这个页面（至少视频部分）是使用服务端渲染的，并且很快找到了页面中的<code>video</code>元素，不难发现<code>src</code>属性中的链接似乎就是我们希望找到的东西，将其复制，在浏览器中打开，成功看到了我们想要的视频，Good~</p>\n<p>当我们拿到这样一个链接后，想要将其下载是非常简单的：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">item_page = Nokogiri::<span class=\"variable constant_\">HTML</span>(open(project_item_url))</span><br><span class=\"line\">video_url = item_page.css(<span class=\"string\">&#x27;.container source&#x27;</span>)[<span class=\"number\">0</span>][<span class=\"string\">&#x27;src&#x27;</span>]</span><br><span class=\"line\">file_name = video_url[video_url.rindex(<span class=\"string\">&#x27;/&#x27;</span>) + <span class=\"number\">1</span>..-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">puts <span class=\"string\">&quot;<span class=\"subst\">#&#123;file_name&#125;</span>下载完成&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">video = RestClient.get(<span class=\"variable constant_\">URI</span>.encode(video_url))</span><br><span class=\"line\"></span><br><span class=\"line\">file = File.open(<span class=\"string\">&quot;videos/<span class=\"subst\">#&#123;file_name&#125;</span>.mp4&quot;</span>, <span class=\"string\">&quot;a+&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> file</span><br><span class=\"line\">  file.syswrite(video)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>拉取子页面并使用<code>nokogiri</code>进行解析，然后我们就像写<code>JQuery</code>一样使用<code>css</code>选择器获取了<code>video</code>元素并读取到了<code>src</code>属性。</p>\n<p>我们使用<code>GET</code>方法请求该属性即可拿到视频的数据，然后将其写出到指定的文件目录里，一个视频就简单粗暴的下载好了，为了让每个视频都有自己的名字，我们简单的使用字符串方法截取了视频的名字，现在当我们运行脚本，就可以看到<code>videos</code>目录下有一个又一个视频冒出来~</p>\n<p><img src=\"/./images/ba-shi-pin-ruby-pa-chong-chu-tan/download_video_result.png\" alt=\"下载视频\"></p>\n<h4 id=\"2-3-3-访问子页面获取资源提取码与分享地址\"><a href=\"#2-3-3-访问子页面获取资源提取码与分享地址\" class=\"headerlink\" title=\"2.3.3 访问子页面获取资源提取码与分享地址\"></a>2.3.3 访问子页面获取资源提取码与分享地址</h4><h4 id=\"2-3-4-使用提取码提取文件\"><a href=\"#2-3-4-使用提取码提取文件\" class=\"headerlink\" title=\"2.3.4 使用提取码提取文件\"></a>2.3.4 使用提取码提取文件</h4><h4 id=\"2-3-5-将文件转存到我的百度云盘\"><a href=\"#2-3-5-将文件转存到我的百度云盘\" class=\"headerlink\" title=\"2.3.5 将文件转存到我的百度云盘\"></a>2.3.5 将文件转存到我的百度云盘</h4><h3 id=\"2-4-成果\"><a href=\"#2-4-成果\" class=\"headerlink\" title=\"2.4 成果\"></a>2.4 成果</h3><h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h2><h2 id=\"4-尾声\"><a href=\"#4-尾声\" class=\"headerlink\" title=\"4. 尾声\"></a>4. 尾声</h2>"},{"title":"简单的遍历文件路径","date":"2018-09-08T13:48:00.000Z","_content":"\n闲得无聊写了一个用来遍历所有文件夹的Class，也许以后会用上吧。= =！\n\n## 1. `ListDirUtil`类的编写\n分析需求：\n1. 获取用户指定的路径\n2. 判断该路径是否存在\n3. 判断是否是一个目录\n4. 遍历输出其子文件\n5. 就子文件是目录的部分进行递归输出\n\n编写：\n~~~java\npackage com.yuchi;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class ListDirUtil {\n\tpublic static void listDir(File file) throws IOException {\n\t\tif(!file.exists()) {\n\t\t\tthrow new IllegalArgumentException(\"文件\" + file + \"不存在！\");\n\t\t}\n\t\tif(!file.isDirectory()) {\n\t\t\tthrow new IllegalArgumentException(file + \"不是目录\");\n\t\t}\n\t\tFile[] ChildFiles = file.listFiles();\n\t\tif(ChildFiles != null && ChildFiles.length > 0) {\n\t\t\tfor(int i = 0; i < ChildFiles.length; i++) {\n\t\t\t\tif(ChildFiles[i].isDirectory()) {\n\t\t\t\t\tlistDir(ChildFiles[i]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(ChildFiles[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n~~~\n\n为了方便使用，我写了一个static方法方便调用，方法体内首先对需求1,2进行了判断，当条件不符合时抛出异常已提示用户。之后再获取子文件后，进行判断，就文件进行输出，目录进行递归。\n\n## 2. `ListDirClass`类的编写\n\n用于测试的`ListDirClass`类\n\n~~~java\npublic static void main(String[] args) throws IOException {\n\t// TODO 自动生成的方法存根\n\tFile file=new File(\"D:\\\\qycache\\\\download\");\n\tListDirUtil.listDir(file);\n}\n~~~\n\n运行结果如下（请不要介意文件的内容_(:з」∠)_）\n\n![运行结果](./images/jian-dan-de-bian-li-wen-jian-lu-jing/1.webp)\n\n到这里一个简单的文件遍历小工具就完成了，之所以会想到写这么一个东西，其实完全只是觉得日后可能会用的上，所以预先写完放在这儿以后可以直接复制粘贴= =！\n","source":"_posts/简单的遍历文件路径.md","raw":"---\ntitle: 简单的遍历文件路径\ndate: 2018.09.08 21:48\ntags:\n  - Java\ncategories:\n  - 好饿，早知道不学编程了\n---\n\n闲得无聊写了一个用来遍历所有文件夹的Class，也许以后会用上吧。= =！\n\n## 1. `ListDirUtil`类的编写\n分析需求：\n1. 获取用户指定的路径\n2. 判断该路径是否存在\n3. 判断是否是一个目录\n4. 遍历输出其子文件\n5. 就子文件是目录的部分进行递归输出\n\n编写：\n~~~java\npackage com.yuchi;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class ListDirUtil {\n\tpublic static void listDir(File file) throws IOException {\n\t\tif(!file.exists()) {\n\t\t\tthrow new IllegalArgumentException(\"文件\" + file + \"不存在！\");\n\t\t}\n\t\tif(!file.isDirectory()) {\n\t\t\tthrow new IllegalArgumentException(file + \"不是目录\");\n\t\t}\n\t\tFile[] ChildFiles = file.listFiles();\n\t\tif(ChildFiles != null && ChildFiles.length > 0) {\n\t\t\tfor(int i = 0; i < ChildFiles.length; i++) {\n\t\t\t\tif(ChildFiles[i].isDirectory()) {\n\t\t\t\t\tlistDir(ChildFiles[i]);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(ChildFiles[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n~~~\n\n为了方便使用，我写了一个static方法方便调用，方法体内首先对需求1,2进行了判断，当条件不符合时抛出异常已提示用户。之后再获取子文件后，进行判断，就文件进行输出，目录进行递归。\n\n## 2. `ListDirClass`类的编写\n\n用于测试的`ListDirClass`类\n\n~~~java\npublic static void main(String[] args) throws IOException {\n\t// TODO 自动生成的方法存根\n\tFile file=new File(\"D:\\\\qycache\\\\download\");\n\tListDirUtil.listDir(file);\n}\n~~~\n\n运行结果如下（请不要介意文件的内容_(:з」∠)_）\n\n![运行结果](./images/jian-dan-de-bian-li-wen-jian-lu-jing/1.webp)\n\n到这里一个简单的文件遍历小工具就完成了，之所以会想到写这么一个东西，其实完全只是觉得日后可能会用的上，所以预先写完放在这儿以后可以直接复制粘贴= =！\n","slug":"简单的遍历文件路径","published":1,"updated":"2022-05-03T09:47:55.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mduo002qr2ve0se46j46","content":"<p>闲得无聊写了一个用来遍历所有文件夹的Class，也许以后会用上吧。&#x3D; &#x3D;！</p>\n<h2 id=\"1-ListDirUtil类的编写\"><a href=\"#1-ListDirUtil类的编写\" class=\"headerlink\" title=\"1. ListDirUtil类的编写\"></a>1. <code>ListDirUtil</code>类的编写</h2><p>分析需求：</p>\n<ol>\n<li>获取用户指定的路径</li>\n<li>判断该路径是否存在</li>\n<li>判断是否是一个目录</li>\n<li>遍历输出其子文件</li>\n<li>就子文件是目录的部分进行递归输出</li>\n</ol>\n<p>编写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.yuchi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ListDirUtil</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listDir</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!file.exists()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;文件&quot;</span> + file + <span class=\"string\">&quot;不存在！&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!file.isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(file + <span class=\"string\">&quot;不是目录&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tFile[] ChildFiles = file.listFiles();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ChildFiles != <span class=\"literal\">null</span> &amp;&amp; ChildFiles.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; ChildFiles.length; i++) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ChildFiles[i].isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlistDir(ChildFiles[i]);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(ChildFiles[i]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了方便使用，我写了一个static方法方便调用，方法体内首先对需求1,2进行了判断，当条件不符合时抛出异常已提示用户。之后再获取子文件后，进行判断，就文件进行输出，目录进行递归。</p>\n<h2 id=\"2-ListDirClass类的编写\"><a href=\"#2-ListDirClass类的编写\" class=\"headerlink\" title=\"2. ListDirClass类的编写\"></a>2. <code>ListDirClass</code>类的编写</h2><p>用于测试的<code>ListDirClass</code>类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// TODO 自动生成的方法存根</span></span><br><span class=\"line\">\tFile file=<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;D:\\\\qycache\\\\download&quot;</span>);</span><br><span class=\"line\">\tListDirUtil.listDir(file);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下（请不要介意文件的内容_(:з」∠)_）</p>\n<p><img src=\"/./images/jian-dan-de-bian-li-wen-jian-lu-jing/1.webp\" alt=\"运行结果\"></p>\n<p>到这里一个简单的文件遍历小工具就完成了，之所以会想到写这么一个东西，其实完全只是觉得日后可能会用的上，所以预先写完放在这儿以后可以直接复制粘贴&#x3D; &#x3D;！</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<p>闲得无聊写了一个用来遍历所有文件夹的Class，也许以后会用上吧。&#x3D; &#x3D;！</p>\n<h2 id=\"1-ListDirUtil类的编写\"><a href=\"#1-ListDirUtil类的编写\" class=\"headerlink\" title=\"1. ListDirUtil类的编写\"></a>1. <code>ListDirUtil</code>类的编写</h2><p>分析需求：</p>\n<ol>\n<li>获取用户指定的路径</li>\n<li>判断该路径是否存在</li>\n<li>判断是否是一个目录</li>\n<li>遍历输出其子文件</li>\n<li>就子文件是目录的部分进行递归输出</li>\n</ol>\n<p>编写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.yuchi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.File;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ListDirUtil</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">listDir</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!file.exists()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;文件&quot;</span> + file + <span class=\"string\">&quot;不存在！&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!file.isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(file + <span class=\"string\">&quot;不是目录&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tFile[] ChildFiles = file.listFiles();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ChildFiles != <span class=\"literal\">null</span> &amp;&amp; ChildFiles.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; ChildFiles.length; i++) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ChildFiles[i].isDirectory()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlistDir(ChildFiles[i]);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tSystem.out.println(ChildFiles[i]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了方便使用，我写了一个static方法方便调用，方法体内首先对需求1,2进行了判断，当条件不符合时抛出异常已提示用户。之后再获取子文件后，进行判断，就文件进行输出，目录进行递归。</p>\n<h2 id=\"2-ListDirClass类的编写\"><a href=\"#2-ListDirClass类的编写\" class=\"headerlink\" title=\"2. ListDirClass类的编写\"></a>2. <code>ListDirClass</code>类的编写</h2><p>用于测试的<code>ListDirClass</code>类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// TODO 自动生成的方法存根</span></span><br><span class=\"line\">\tFile file=<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;D:\\\\qycache\\\\download&quot;</span>);</span><br><span class=\"line\">\tListDirUtil.listDir(file);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下（请不要介意文件的内容_(:з」∠)_）</p>\n<p><img src=\"/./images/jian-dan-de-bian-li-wen-jian-lu-jing/1.webp\" alt=\"运行结果\"></p>\n<p>到这里一个简单的文件遍历小工具就完成了，之所以会想到写这么一个东西，其实完全只是觉得日后可能会用的上，所以预先写完放在这儿以后可以直接复制粘贴&#x3D; &#x3D;！</p>\n"},{"title":"数据结构： 线性表","date":"2022-02-13T10:43:19.000Z","_content":"# 前言（啰嗦两句）\n\n作为一名普通野鸡大学的毕业的科班生，虽然在学校学过《数据结构》这样一门课程，但彼时的我所有的编码经验也就只是写过一些诸如杨辉三角，水仙花数之类的例题，因而在结课后很快就还给老师了……\n\n最近颇乏于写应用层代码，终于又双叒叕难得想学数据结构了，遂打算开一个系列，希望能够有始有终的写完。\n\n[yuchiXiong/data-structure: 我又双叒叕准备学数据结构啦](https://github.com/yuchiXiong/data-structure)\n\n# 1. 线性表是什么？\n\n> [wiki](https://zh.wikipedia.org/wiki/线性表): 线性表是一个具有顺序的，由同类型数据组成的集合，它是常用的数据结构之一。\n\n线性表具有几个基本特征：\n\n1. 有限性，线性表是一个有限序列。\n2. 有序性，线性表具有基本的顺序属性。\n3. 同一性，线性表元素具有相同的类型。\n\n关于上述3，在参考广义表的相关定义后，我认为应该更完整的描述为：线性表由同类型数据组成，且该类型被限定为原子类型（如整数、字符串、布尔值等），而非结构类型（如数组、结构体、类等）。\n\n关于 `线性` ，我们知道数据结构中还定义了其他诸多非线性数据结构如树、图等。它们在计算机中存储时并非真的表现为树状或图状，而是从逻辑上抽象为树状或图状。线性结构与之类似，当我们将线性表的元素按照逻辑顺序排列时，它呈现为一条线段，因而我们称之为线性结构。对应的，当我们将广义表的元素按照其层次排列时，它并不是一条线段，而更像是一个平面，这正是我们说广义表是一种非线性数据结构的原因，同时也是线性表同一性限制存在的原因。\n\n# 2. 顺序存储与链式存储\n\n线性表的线性是逻辑层面的，但实际无论是线性表，广义表，还是树，图等，在计算机中存储时，都无外乎两种形式：顺序存储和链式存储。\n\n## 2.1 顺序存储与顺序表\n\n在计算机中存储数据的第一种方式是顺序存储，基于顺序存储方式实现的线性表称为顺序表，举一个比较形象的例子：\n\n*你和小伙伴一起去看电影，你当然希望可以和小伙伴们坐在一起，因而你们选择购买了某一座位开始往后的多个****连续****的座位。*\n\n不难发现，在这一案例中有几个重要的细节：\n\n1. 我们需要一次性购买多个连续的座位。\n2. 当我们知道第一个座位的编号时，很容通过第一个座位的编号，计算出后面的座位的编号。\n3. 当我们希望在保持原有的座位顺序的前提下，插入一个新的座位时，我们需要将原有的每一个座位向后移动一个位置。\n4. 当我们希望在保持原有的座位顺序的前提下，删除一个已有座位时，我们需要将原有的每一个座位向前移动一个位置。\n\n我们将这个例子映射到顺序表中，就可以得到顺序表的几个重要特征：\n\n1. 在使用顺序表时，我们需要一次性申请存储元素所需要的空间。\n2. 通过元素下标我们可以快速的访问元素。\n3. 在插入/删除顺序表中的元素时，我们需要将原有的每一个元素向后/向前移动一个位置。\n\n这些特征决定了顺序表最重要的优点：访问速度快。通过下标我们能在 `O(1)` 时间复杂度内访问到某个元素。\n\n同时也暴露了顺序表的缺点：\n\n1. 由于在使用前需要一次性申请指定容量的空间，当遇到数据增长速度较快的场景时，顺序表容量可能会达到最大值而无法添加新的数据，但如果一次性申请的空间过大，则又容易造成浪费。\n2. 如果需要对顺序表进行扩容，则需要额外的空间来进行数据的复制。\n3. 如果需要插入元素到顺序表中，则需要将原有的每一个元素向后移动一个位置，时间复杂度为 `O(n)`。\n\n最后，以 `C` 语言为例，我们可以将数组看作一个顺序表，但值得注意的是，在部分动态语言如 `Python/JavaScript/Ruby` 等中，数组元素的类型是动态的，它可以是数组、对象等任何类型的数据，此时的数组则更应该看作广义表而非线性表。\n\n## 2.2 链式存储与链表\n\n在计算机中存储数据的另一种方式是链式存储，基于链式存储方式实现的线性表称为链表。\n\n链表的每一个节点分散存储在不同的地址，而后使用一个 `next` 指针来指向下一个节点，最终实现了维护其逻辑上的线性的目的。这样做的好处是当我们需要对链表进行修改时，无需再对其他元素进行移动操作：\n\n1. 当需要在链表中插入新节点时，我们只需要修改目标位置上一个位置节点的 `next` 指针指向新节点，然后将新节点的 `next` 指针指向原有位置上的节点即可。\n2. 当需要在链表中删除一个节点时，我们只需要将目标位置上一个位置节点的 `next` 指针指向目标位置下一个节点即可。\n3. 当需要在表头插入新节点时，我们只需要将新节点的 `next` 指针指向原有的表头即可。\n4. 当需要在表尾插入新节点时，我们只需要将表尾节点的 `next` 指针指向新节点即可。\n\n但由于链表的线性关系是通过 `next` 指针来实现的，因此当希望读取链表的某一个元素时，无法通过下标的方式以 `O(1)` 的时间复杂度完成而是需要进行遍历，时间复杂度为 `O(n)`。\n\n基本单链表节点实现 [LinkedNode.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedNode.cpp)\n\n# 3. 常见线性数据结构\n\n在实际的使用过程中，我们经常基于线性表来实现一些更符合业务场景的数据结构。\n\n## 3.1 变长数组\n\n由于顺序表始终需要维护一个固定的长度，在使用过程中扩容极不方便，因而我们可以基于顺序表来实现一个变长数组，使其能够在使用的过程中进行动态扩容。\n\n`Java Collection Framework`（简称 `JCF`) 中实现的 `ArrayList/Vector` 以及 `CPP STL Container adaptors` 中提供的 `Vector` 都可以看作一个变长数组。其实现的原理大致为，当向数组中添加或删除元素时，首先检查数组的容量：\n\n1. 如果当前数组的容量不足以添加新的元素，将数组扩容（通常为原来的两倍），然后将原来的数据复制到新的数组中。\n2. 如果当前数组的使用容量低于阈值（通常是当前容量的 `1/4` ），将数组的容量缩小为原来的一半，然后将原来的数据复制到新的数组中。\n\n变长数组实现 [Vector.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/Vector.cpp)\n\n## 3.2 链式线性容器\n基础的链表节点实现在使用时并不太方便，我们可以基于此封装一个与变长数组相似的链式线性容器。\n\n基于单链表的链式线性容器实现 [SLinkedList.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/SLinkedList.cpp)\n\n基于双向链表的链式线性容器实现 [LinkedList.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedList.cpp)\n\n## 3.3 顺序栈\n栈是一种受限制的线性表，其特点是 `First In Last Out` (简称 `FILO` )，即先进后出。\n\n现实生活中的羽毛球桶就可以看作一个栈，当一个球桶里装满球时，只能先取出后放进的羽毛球，再取出倒数第二次序放入的羽毛球。\n\n栈有两个基本操作：\n- 将元素押入栈顶，即入栈\n- 从栈中弹出栈顶元素，即出栈\n\n栈是一种非常实用的数据结构，例如前端开发中比较常提及的页面跳转栈，在页面跳转过程中，我们可以将页面跳转的每一步都保存在栈中，当页面进行回退操作时，我们可以从栈中取出每一步的跳转页面，直到栈为空。\n\n基于线性表我们可以很快的实现一个栈数据结构，不过由于线性表具体分为顺序表和链表两种，因而实现栈也有两种方式。其中通过顺序表实现的栈被称为顺序栈。\n\n实现顺序栈通常来说不太困难，但考虑到顺序表固定长度的特性，为了使顺序栈拥有更好的可用性，我们可以通过变长数组来实现。而对于栈的弹出和押入操作，只需要简单的对变长数组队尾的元素进行简单的操作即可。同时，由于栈的操作中不涉及到在已有序列中插入和删除元素的操作，因而恰好避开了顺序表在插入和删除元素时需要移动元素的问题。\n\n顺序栈实现 [ArrayStack.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/ArrayStack.cpp)\n\n## 3.4 链式栈\n除了使用顺序表实现的栈，我们还可以使用链表来实现栈。链式栈和顺序栈本质上来说没有什么太大的区别，只是底层的存储方式不太一样。\n\n基于链表实现的栈，主要的思路是维护一个链表的头节点，当押入新元素到栈内时，只需要基于新元素创建一个新的节点，并将头节点插入到新节点的后面即可。而弹出时，只需要将内部维护的头节点更新为当前头节点的下一个节点即可。以下给出的参考代码实现是基于双向链表的，但由于栈数据结构始终只对尾节点进行操作，因而使用双向链表并不能简化操作，甚至还会导致实现的抽象难度增加。\n\n链式栈实现 [LinkedStack.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedStack.cpp)\n\n## 3.5 顺序队列，假溢出和循环队列\n队列同样是一种受限制的线性表，其特点是 `First In First Out` (简称 `FIFO` )，即先进先出。\n\n在现实生活中，我们其实经常使用到队列的特性，比如超市的排队等等。对于一个队列我们有两种基本的操作：\n- 元素入队，即把元素插入队列的尾部\n- 元素出队，即把队列的头元素删除\n\n与顺序栈和链式栈相同，队列也有两种实现方式，一种是顺序队列，另一种是链式队列。\n\n同样考虑到顺序表定长的特性，在实际实现中我们可以考虑基于变长数组来实现队列以支持自适应动态扩容和缩容。\n\n当元素入队时，我们只需要把元素插入到变长数组的尾部即可，但当元素出队时问题就显的稍微复杂一些了。当元素出队时，我们需要删除队列的头元素，考虑到如果将后续元素都向前位移必定会造成大量的性能损耗，我们可以维护一个标识来表示实际的队列头。然而这样又回引出新的问题，既当元素不断的出队与入队，队头的标识会越来越靠后，这样势必会导致顺序队列中存在大量的连续的空间浪费。\n\n基于变长数组的顺序队列实现 [ArrayQueue.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/ArrayQueue.cpp)\n\n我们可以使用循环队列来解决这些问题，既当队列元素入队时，如果当前队尾元素的下标超过了队列的最大容量，那么我们就将队尾元素的下标重置为0，这样可以保证队列中的元素是连续的同时，不浪费之前的空间。而当元素出队时，我们还是一样删除队尾元素即可。当然，由于循环队列从存储上来说并不是完全连续的，在对变长数组进行动态扩容时我们需要两段的元素列表分别拷贝到对应的位置中。\n\n循环顺序队列实现 [CircularQueue.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/CircularQueue.cpp)\n\n## 3.6 链式队列\n很显然，基于链式存储结构实现的队列被称为链式队列。\n\n由于队列的两种常用操作分别作用于队头和队尾，当我们使用单链表实现时，操作队尾元素很容易，但是操作队头元素则需要遍历整个队列，这样会带来较大的性能开销。此时我们可以增加一个指向上一个节点的 `prev` 指针来将单链表修改为双向链表，然后以同样的方式保存对头元素的指针和队尾元素的指针，之后就可以方便快捷的进行出队和入队操作了。\n\n双向链表实现 [DoublyLinkedNode.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/DoublyLinkedNode.cpp)\n\n基于双向链表的链式队列实现 [LinkedQueue.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedQueue.cpp)\n\n<!-- ## 3.7 双端队列\n\n## 3.8 顺序双端队列 -->\n\n# 4. 参考\n\n- [CPP Reference Containers library](https://en.cppreference.com/w/cpp/container)\n- [Java8 API 中文文档](https://www.matools.com/api/java8)\n\n","source":"_posts/线性表.md","raw":"---\ntitle: 数据结构： 线性表\ndate:  2022.02.13 18:43:19\ntags:\n  - c\ncategories:\n  - 好饿，早知道不学编程了\n---\n# 前言（啰嗦两句）\n\n作为一名普通野鸡大学的毕业的科班生，虽然在学校学过《数据结构》这样一门课程，但彼时的我所有的编码经验也就只是写过一些诸如杨辉三角，水仙花数之类的例题，因而在结课后很快就还给老师了……\n\n最近颇乏于写应用层代码，终于又双叒叕难得想学数据结构了，遂打算开一个系列，希望能够有始有终的写完。\n\n[yuchiXiong/data-structure: 我又双叒叕准备学数据结构啦](https://github.com/yuchiXiong/data-structure)\n\n# 1. 线性表是什么？\n\n> [wiki](https://zh.wikipedia.org/wiki/线性表): 线性表是一个具有顺序的，由同类型数据组成的集合，它是常用的数据结构之一。\n\n线性表具有几个基本特征：\n\n1. 有限性，线性表是一个有限序列。\n2. 有序性，线性表具有基本的顺序属性。\n3. 同一性，线性表元素具有相同的类型。\n\n关于上述3，在参考广义表的相关定义后，我认为应该更完整的描述为：线性表由同类型数据组成，且该类型被限定为原子类型（如整数、字符串、布尔值等），而非结构类型（如数组、结构体、类等）。\n\n关于 `线性` ，我们知道数据结构中还定义了其他诸多非线性数据结构如树、图等。它们在计算机中存储时并非真的表现为树状或图状，而是从逻辑上抽象为树状或图状。线性结构与之类似，当我们将线性表的元素按照逻辑顺序排列时，它呈现为一条线段，因而我们称之为线性结构。对应的，当我们将广义表的元素按照其层次排列时，它并不是一条线段，而更像是一个平面，这正是我们说广义表是一种非线性数据结构的原因，同时也是线性表同一性限制存在的原因。\n\n# 2. 顺序存储与链式存储\n\n线性表的线性是逻辑层面的，但实际无论是线性表，广义表，还是树，图等，在计算机中存储时，都无外乎两种形式：顺序存储和链式存储。\n\n## 2.1 顺序存储与顺序表\n\n在计算机中存储数据的第一种方式是顺序存储，基于顺序存储方式实现的线性表称为顺序表，举一个比较形象的例子：\n\n*你和小伙伴一起去看电影，你当然希望可以和小伙伴们坐在一起，因而你们选择购买了某一座位开始往后的多个****连续****的座位。*\n\n不难发现，在这一案例中有几个重要的细节：\n\n1. 我们需要一次性购买多个连续的座位。\n2. 当我们知道第一个座位的编号时，很容通过第一个座位的编号，计算出后面的座位的编号。\n3. 当我们希望在保持原有的座位顺序的前提下，插入一个新的座位时，我们需要将原有的每一个座位向后移动一个位置。\n4. 当我们希望在保持原有的座位顺序的前提下，删除一个已有座位时，我们需要将原有的每一个座位向前移动一个位置。\n\n我们将这个例子映射到顺序表中，就可以得到顺序表的几个重要特征：\n\n1. 在使用顺序表时，我们需要一次性申请存储元素所需要的空间。\n2. 通过元素下标我们可以快速的访问元素。\n3. 在插入/删除顺序表中的元素时，我们需要将原有的每一个元素向后/向前移动一个位置。\n\n这些特征决定了顺序表最重要的优点：访问速度快。通过下标我们能在 `O(1)` 时间复杂度内访问到某个元素。\n\n同时也暴露了顺序表的缺点：\n\n1. 由于在使用前需要一次性申请指定容量的空间，当遇到数据增长速度较快的场景时，顺序表容量可能会达到最大值而无法添加新的数据，但如果一次性申请的空间过大，则又容易造成浪费。\n2. 如果需要对顺序表进行扩容，则需要额外的空间来进行数据的复制。\n3. 如果需要插入元素到顺序表中，则需要将原有的每一个元素向后移动一个位置，时间复杂度为 `O(n)`。\n\n最后，以 `C` 语言为例，我们可以将数组看作一个顺序表，但值得注意的是，在部分动态语言如 `Python/JavaScript/Ruby` 等中，数组元素的类型是动态的，它可以是数组、对象等任何类型的数据，此时的数组则更应该看作广义表而非线性表。\n\n## 2.2 链式存储与链表\n\n在计算机中存储数据的另一种方式是链式存储，基于链式存储方式实现的线性表称为链表。\n\n链表的每一个节点分散存储在不同的地址，而后使用一个 `next` 指针来指向下一个节点，最终实现了维护其逻辑上的线性的目的。这样做的好处是当我们需要对链表进行修改时，无需再对其他元素进行移动操作：\n\n1. 当需要在链表中插入新节点时，我们只需要修改目标位置上一个位置节点的 `next` 指针指向新节点，然后将新节点的 `next` 指针指向原有位置上的节点即可。\n2. 当需要在链表中删除一个节点时，我们只需要将目标位置上一个位置节点的 `next` 指针指向目标位置下一个节点即可。\n3. 当需要在表头插入新节点时，我们只需要将新节点的 `next` 指针指向原有的表头即可。\n4. 当需要在表尾插入新节点时，我们只需要将表尾节点的 `next` 指针指向新节点即可。\n\n但由于链表的线性关系是通过 `next` 指针来实现的，因此当希望读取链表的某一个元素时，无法通过下标的方式以 `O(1)` 的时间复杂度完成而是需要进行遍历，时间复杂度为 `O(n)`。\n\n基本单链表节点实现 [LinkedNode.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedNode.cpp)\n\n# 3. 常见线性数据结构\n\n在实际的使用过程中，我们经常基于线性表来实现一些更符合业务场景的数据结构。\n\n## 3.1 变长数组\n\n由于顺序表始终需要维护一个固定的长度，在使用过程中扩容极不方便，因而我们可以基于顺序表来实现一个变长数组，使其能够在使用的过程中进行动态扩容。\n\n`Java Collection Framework`（简称 `JCF`) 中实现的 `ArrayList/Vector` 以及 `CPP STL Container adaptors` 中提供的 `Vector` 都可以看作一个变长数组。其实现的原理大致为，当向数组中添加或删除元素时，首先检查数组的容量：\n\n1. 如果当前数组的容量不足以添加新的元素，将数组扩容（通常为原来的两倍），然后将原来的数据复制到新的数组中。\n2. 如果当前数组的使用容量低于阈值（通常是当前容量的 `1/4` ），将数组的容量缩小为原来的一半，然后将原来的数据复制到新的数组中。\n\n变长数组实现 [Vector.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/Vector.cpp)\n\n## 3.2 链式线性容器\n基础的链表节点实现在使用时并不太方便，我们可以基于此封装一个与变长数组相似的链式线性容器。\n\n基于单链表的链式线性容器实现 [SLinkedList.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/SLinkedList.cpp)\n\n基于双向链表的链式线性容器实现 [LinkedList.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedList.cpp)\n\n## 3.3 顺序栈\n栈是一种受限制的线性表，其特点是 `First In Last Out` (简称 `FILO` )，即先进后出。\n\n现实生活中的羽毛球桶就可以看作一个栈，当一个球桶里装满球时，只能先取出后放进的羽毛球，再取出倒数第二次序放入的羽毛球。\n\n栈有两个基本操作：\n- 将元素押入栈顶，即入栈\n- 从栈中弹出栈顶元素，即出栈\n\n栈是一种非常实用的数据结构，例如前端开发中比较常提及的页面跳转栈，在页面跳转过程中，我们可以将页面跳转的每一步都保存在栈中，当页面进行回退操作时，我们可以从栈中取出每一步的跳转页面，直到栈为空。\n\n基于线性表我们可以很快的实现一个栈数据结构，不过由于线性表具体分为顺序表和链表两种，因而实现栈也有两种方式。其中通过顺序表实现的栈被称为顺序栈。\n\n实现顺序栈通常来说不太困难，但考虑到顺序表固定长度的特性，为了使顺序栈拥有更好的可用性，我们可以通过变长数组来实现。而对于栈的弹出和押入操作，只需要简单的对变长数组队尾的元素进行简单的操作即可。同时，由于栈的操作中不涉及到在已有序列中插入和删除元素的操作，因而恰好避开了顺序表在插入和删除元素时需要移动元素的问题。\n\n顺序栈实现 [ArrayStack.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/ArrayStack.cpp)\n\n## 3.4 链式栈\n除了使用顺序表实现的栈，我们还可以使用链表来实现栈。链式栈和顺序栈本质上来说没有什么太大的区别，只是底层的存储方式不太一样。\n\n基于链表实现的栈，主要的思路是维护一个链表的头节点，当押入新元素到栈内时，只需要基于新元素创建一个新的节点，并将头节点插入到新节点的后面即可。而弹出时，只需要将内部维护的头节点更新为当前头节点的下一个节点即可。以下给出的参考代码实现是基于双向链表的，但由于栈数据结构始终只对尾节点进行操作，因而使用双向链表并不能简化操作，甚至还会导致实现的抽象难度增加。\n\n链式栈实现 [LinkedStack.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedStack.cpp)\n\n## 3.5 顺序队列，假溢出和循环队列\n队列同样是一种受限制的线性表，其特点是 `First In First Out` (简称 `FIFO` )，即先进先出。\n\n在现实生活中，我们其实经常使用到队列的特性，比如超市的排队等等。对于一个队列我们有两种基本的操作：\n- 元素入队，即把元素插入队列的尾部\n- 元素出队，即把队列的头元素删除\n\n与顺序栈和链式栈相同，队列也有两种实现方式，一种是顺序队列，另一种是链式队列。\n\n同样考虑到顺序表定长的特性，在实际实现中我们可以考虑基于变长数组来实现队列以支持自适应动态扩容和缩容。\n\n当元素入队时，我们只需要把元素插入到变长数组的尾部即可，但当元素出队时问题就显的稍微复杂一些了。当元素出队时，我们需要删除队列的头元素，考虑到如果将后续元素都向前位移必定会造成大量的性能损耗，我们可以维护一个标识来表示实际的队列头。然而这样又回引出新的问题，既当元素不断的出队与入队，队头的标识会越来越靠后，这样势必会导致顺序队列中存在大量的连续的空间浪费。\n\n基于变长数组的顺序队列实现 [ArrayQueue.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/ArrayQueue.cpp)\n\n我们可以使用循环队列来解决这些问题，既当队列元素入队时，如果当前队尾元素的下标超过了队列的最大容量，那么我们就将队尾元素的下标重置为0，这样可以保证队列中的元素是连续的同时，不浪费之前的空间。而当元素出队时，我们还是一样删除队尾元素即可。当然，由于循环队列从存储上来说并不是完全连续的，在对变长数组进行动态扩容时我们需要两段的元素列表分别拷贝到对应的位置中。\n\n循环顺序队列实现 [CircularQueue.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/CircularQueue.cpp)\n\n## 3.6 链式队列\n很显然，基于链式存储结构实现的队列被称为链式队列。\n\n由于队列的两种常用操作分别作用于队头和队尾，当我们使用单链表实现时，操作队尾元素很容易，但是操作队头元素则需要遍历整个队列，这样会带来较大的性能开销。此时我们可以增加一个指向上一个节点的 `prev` 指针来将单链表修改为双向链表，然后以同样的方式保存对头元素的指针和队尾元素的指针，之后就可以方便快捷的进行出队和入队操作了。\n\n双向链表实现 [DoublyLinkedNode.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/DoublyLinkedNode.cpp)\n\n基于双向链表的链式队列实现 [LinkedQueue.cpp](https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedQueue.cpp)\n\n<!-- ## 3.7 双端队列\n\n## 3.8 顺序双端队列 -->\n\n# 4. 参考\n\n- [CPP Reference Containers library](https://en.cppreference.com/w/cpp/container)\n- [Java8 API 中文文档](https://www.matools.com/api/java8)\n\n","slug":"线性表","published":1,"updated":"2022-05-03T09:57:05.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdup002ur2ve558e9ii8","content":"<h1 id=\"前言（啰嗦两句）\"><a href=\"#前言（啰嗦两句）\" class=\"headerlink\" title=\"前言（啰嗦两句）\"></a>前言（啰嗦两句）</h1><p>作为一名普通野鸡大学的毕业的科班生，虽然在学校学过《数据结构》这样一门课程，但彼时的我所有的编码经验也就只是写过一些诸如杨辉三角，水仙花数之类的例题，因而在结课后很快就还给老师了……</p>\n<p>最近颇乏于写应用层代码，终于又双叒叕难得想学数据结构了，遂打算开一个系列，希望能够有始有终的写完。</p>\n<p><a href=\"https://github.com/yuchiXiong/data-structure\">yuchiXiong&#x2F;data-structure: 我又双叒叕准备学数据结构啦</a></p>\n<h1 id=\"1-线性表是什么？\"><a href=\"#1-线性表是什么？\" class=\"headerlink\" title=\"1. 线性表是什么？\"></a>1. 线性表是什么？</h1><blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8\">wiki</a>: 线性表是一个具有顺序的，由同类型数据组成的集合，它是常用的数据结构之一。</p>\n</blockquote>\n<p>线性表具有几个基本特征：</p>\n<ol>\n<li>有限性，线性表是一个有限序列。</li>\n<li>有序性，线性表具有基本的顺序属性。</li>\n<li>同一性，线性表元素具有相同的类型。</li>\n</ol>\n<p>关于上述3，在参考广义表的相关定义后，我认为应该更完整的描述为：线性表由同类型数据组成，且该类型被限定为原子类型（如整数、字符串、布尔值等），而非结构类型（如数组、结构体、类等）。</p>\n<p>关于 <code>线性</code> ，我们知道数据结构中还定义了其他诸多非线性数据结构如树、图等。它们在计算机中存储时并非真的表现为树状或图状，而是从逻辑上抽象为树状或图状。线性结构与之类似，当我们将线性表的元素按照逻辑顺序排列时，它呈现为一条线段，因而我们称之为线性结构。对应的，当我们将广义表的元素按照其层次排列时，它并不是一条线段，而更像是一个平面，这正是我们说广义表是一种非线性数据结构的原因，同时也是线性表同一性限制存在的原因。</p>\n<h1 id=\"2-顺序存储与链式存储\"><a href=\"#2-顺序存储与链式存储\" class=\"headerlink\" title=\"2. 顺序存储与链式存储\"></a>2. 顺序存储与链式存储</h1><p>线性表的线性是逻辑层面的，但实际无论是线性表，广义表，还是树，图等，在计算机中存储时，都无外乎两种形式：顺序存储和链式存储。</p>\n<h2 id=\"2-1-顺序存储与顺序表\"><a href=\"#2-1-顺序存储与顺序表\" class=\"headerlink\" title=\"2.1 顺序存储与顺序表\"></a>2.1 顺序存储与顺序表</h2><p>在计算机中存储数据的第一种方式是顺序存储，基于顺序存储方式实现的线性表称为顺序表，举一个比较形象的例子：</p>\n<p><em>你和小伙伴一起去看电影，你当然希望可以和小伙伴们坐在一起，因而你们选择购买了某一座位开始往后的多个</em><em><strong>连续</strong></em><em>的座位。</em></p>\n<p>不难发现，在这一案例中有几个重要的细节：</p>\n<ol>\n<li>我们需要一次性购买多个连续的座位。</li>\n<li>当我们知道第一个座位的编号时，很容通过第一个座位的编号，计算出后面的座位的编号。</li>\n<li>当我们希望在保持原有的座位顺序的前提下，插入一个新的座位时，我们需要将原有的每一个座位向后移动一个位置。</li>\n<li>当我们希望在保持原有的座位顺序的前提下，删除一个已有座位时，我们需要将原有的每一个座位向前移动一个位置。</li>\n</ol>\n<p>我们将这个例子映射到顺序表中，就可以得到顺序表的几个重要特征：</p>\n<ol>\n<li>在使用顺序表时，我们需要一次性申请存储元素所需要的空间。</li>\n<li>通过元素下标我们可以快速的访问元素。</li>\n<li>在插入&#x2F;删除顺序表中的元素时，我们需要将原有的每一个元素向后&#x2F;向前移动一个位置。</li>\n</ol>\n<p>这些特征决定了顺序表最重要的优点：访问速度快。通过下标我们能在 <code>O(1)</code> 时间复杂度内访问到某个元素。</p>\n<p>同时也暴露了顺序表的缺点：</p>\n<ol>\n<li>由于在使用前需要一次性申请指定容量的空间，当遇到数据增长速度较快的场景时，顺序表容量可能会达到最大值而无法添加新的数据，但如果一次性申请的空间过大，则又容易造成浪费。</li>\n<li>如果需要对顺序表进行扩容，则需要额外的空间来进行数据的复制。</li>\n<li>如果需要插入元素到顺序表中，则需要将原有的每一个元素向后移动一个位置，时间复杂度为 <code>O(n)</code>。</li>\n</ol>\n<p>最后，以 <code>C</code> 语言为例，我们可以将数组看作一个顺序表，但值得注意的是，在部分动态语言如 <code>Python/JavaScript/Ruby</code> 等中，数组元素的类型是动态的，它可以是数组、对象等任何类型的数据，此时的数组则更应该看作广义表而非线性表。</p>\n<h2 id=\"2-2-链式存储与链表\"><a href=\"#2-2-链式存储与链表\" class=\"headerlink\" title=\"2.2 链式存储与链表\"></a>2.2 链式存储与链表</h2><p>在计算机中存储数据的另一种方式是链式存储，基于链式存储方式实现的线性表称为链表。</p>\n<p>链表的每一个节点分散存储在不同的地址，而后使用一个 <code>next</code> 指针来指向下一个节点，最终实现了维护其逻辑上的线性的目的。这样做的好处是当我们需要对链表进行修改时，无需再对其他元素进行移动操作：</p>\n<ol>\n<li>当需要在链表中插入新节点时，我们只需要修改目标位置上一个位置节点的 <code>next</code> 指针指向新节点，然后将新节点的 <code>next</code> 指针指向原有位置上的节点即可。</li>\n<li>当需要在链表中删除一个节点时，我们只需要将目标位置上一个位置节点的 <code>next</code> 指针指向目标位置下一个节点即可。</li>\n<li>当需要在表头插入新节点时，我们只需要将新节点的 <code>next</code> 指针指向原有的表头即可。</li>\n<li>当需要在表尾插入新节点时，我们只需要将表尾节点的 <code>next</code> 指针指向新节点即可。</li>\n</ol>\n<p>但由于链表的线性关系是通过 <code>next</code> 指针来实现的，因此当希望读取链表的某一个元素时，无法通过下标的方式以 <code>O(1)</code> 的时间复杂度完成而是需要进行遍历，时间复杂度为 <code>O(n)</code>。</p>\n<p>基本单链表节点实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedNode.cpp\">LinkedNode.cpp</a></p>\n<h1 id=\"3-常见线性数据结构\"><a href=\"#3-常见线性数据结构\" class=\"headerlink\" title=\"3. 常见线性数据结构\"></a>3. 常见线性数据结构</h1><p>在实际的使用过程中，我们经常基于线性表来实现一些更符合业务场景的数据结构。</p>\n<h2 id=\"3-1-变长数组\"><a href=\"#3-1-变长数组\" class=\"headerlink\" title=\"3.1 变长数组\"></a>3.1 变长数组</h2><p>由于顺序表始终需要维护一个固定的长度，在使用过程中扩容极不方便，因而我们可以基于顺序表来实现一个变长数组，使其能够在使用的过程中进行动态扩容。</p>\n<p><code>Java Collection Framework</code>（简称 <code>JCF</code>) 中实现的 <code>ArrayList/Vector</code> 以及 <code>CPP STL Container adaptors</code> 中提供的 <code>Vector</code> 都可以看作一个变长数组。其实现的原理大致为，当向数组中添加或删除元素时，首先检查数组的容量：</p>\n<ol>\n<li>如果当前数组的容量不足以添加新的元素，将数组扩容（通常为原来的两倍），然后将原来的数据复制到新的数组中。</li>\n<li>如果当前数组的使用容量低于阈值（通常是当前容量的 <code>1/4</code> ），将数组的容量缩小为原来的一半，然后将原来的数据复制到新的数组中。</li>\n</ol>\n<p>变长数组实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/Vector.cpp\">Vector.cpp</a></p>\n<h2 id=\"3-2-链式线性容器\"><a href=\"#3-2-链式线性容器\" class=\"headerlink\" title=\"3.2 链式线性容器\"></a>3.2 链式线性容器</h2><p>基础的链表节点实现在使用时并不太方便，我们可以基于此封装一个与变长数组相似的链式线性容器。</p>\n<p>基于单链表的链式线性容器实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/SLinkedList.cpp\">SLinkedList.cpp</a></p>\n<p>基于双向链表的链式线性容器实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedList.cpp\">LinkedList.cpp</a></p>\n<h2 id=\"3-3-顺序栈\"><a href=\"#3-3-顺序栈\" class=\"headerlink\" title=\"3.3 顺序栈\"></a>3.3 顺序栈</h2><p>栈是一种受限制的线性表，其特点是 <code>First In Last Out</code> (简称 <code>FILO</code> )，即先进后出。</p>\n<p>现实生活中的羽毛球桶就可以看作一个栈，当一个球桶里装满球时，只能先取出后放进的羽毛球，再取出倒数第二次序放入的羽毛球。</p>\n<p>栈有两个基本操作：</p>\n<ul>\n<li>将元素押入栈顶，即入栈</li>\n<li>从栈中弹出栈顶元素，即出栈</li>\n</ul>\n<p>栈是一种非常实用的数据结构，例如前端开发中比较常提及的页面跳转栈，在页面跳转过程中，我们可以将页面跳转的每一步都保存在栈中，当页面进行回退操作时，我们可以从栈中取出每一步的跳转页面，直到栈为空。</p>\n<p>基于线性表我们可以很快的实现一个栈数据结构，不过由于线性表具体分为顺序表和链表两种，因而实现栈也有两种方式。其中通过顺序表实现的栈被称为顺序栈。</p>\n<p>实现顺序栈通常来说不太困难，但考虑到顺序表固定长度的特性，为了使顺序栈拥有更好的可用性，我们可以通过变长数组来实现。而对于栈的弹出和押入操作，只需要简单的对变长数组队尾的元素进行简单的操作即可。同时，由于栈的操作中不涉及到在已有序列中插入和删除元素的操作，因而恰好避开了顺序表在插入和删除元素时需要移动元素的问题。</p>\n<p>顺序栈实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/ArrayStack.cpp\">ArrayStack.cpp</a></p>\n<h2 id=\"3-4-链式栈\"><a href=\"#3-4-链式栈\" class=\"headerlink\" title=\"3.4 链式栈\"></a>3.4 链式栈</h2><p>除了使用顺序表实现的栈，我们还可以使用链表来实现栈。链式栈和顺序栈本质上来说没有什么太大的区别，只是底层的存储方式不太一样。</p>\n<p>基于链表实现的栈，主要的思路是维护一个链表的头节点，当押入新元素到栈内时，只需要基于新元素创建一个新的节点，并将头节点插入到新节点的后面即可。而弹出时，只需要将内部维护的头节点更新为当前头节点的下一个节点即可。以下给出的参考代码实现是基于双向链表的，但由于栈数据结构始终只对尾节点进行操作，因而使用双向链表并不能简化操作，甚至还会导致实现的抽象难度增加。</p>\n<p>链式栈实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedStack.cpp\">LinkedStack.cpp</a></p>\n<h2 id=\"3-5-顺序队列，假溢出和循环队列\"><a href=\"#3-5-顺序队列，假溢出和循环队列\" class=\"headerlink\" title=\"3.5 顺序队列，假溢出和循环队列\"></a>3.5 顺序队列，假溢出和循环队列</h2><p>队列同样是一种受限制的线性表，其特点是 <code>First In First Out</code> (简称 <code>FIFO</code> )，即先进先出。</p>\n<p>在现实生活中，我们其实经常使用到队列的特性，比如超市的排队等等。对于一个队列我们有两种基本的操作：</p>\n<ul>\n<li>元素入队，即把元素插入队列的尾部</li>\n<li>元素出队，即把队列的头元素删除</li>\n</ul>\n<p>与顺序栈和链式栈相同，队列也有两种实现方式，一种是顺序队列，另一种是链式队列。</p>\n<p>同样考虑到顺序表定长的特性，在实际实现中我们可以考虑基于变长数组来实现队列以支持自适应动态扩容和缩容。</p>\n<p>当元素入队时，我们只需要把元素插入到变长数组的尾部即可，但当元素出队时问题就显的稍微复杂一些了。当元素出队时，我们需要删除队列的头元素，考虑到如果将后续元素都向前位移必定会造成大量的性能损耗，我们可以维护一个标识来表示实际的队列头。然而这样又回引出新的问题，既当元素不断的出队与入队，队头的标识会越来越靠后，这样势必会导致顺序队列中存在大量的连续的空间浪费。</p>\n<p>基于变长数组的顺序队列实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/ArrayQueue.cpp\">ArrayQueue.cpp</a></p>\n<p>我们可以使用循环队列来解决这些问题，既当队列元素入队时，如果当前队尾元素的下标超过了队列的最大容量，那么我们就将队尾元素的下标重置为0，这样可以保证队列中的元素是连续的同时，不浪费之前的空间。而当元素出队时，我们还是一样删除队尾元素即可。当然，由于循环队列从存储上来说并不是完全连续的，在对变长数组进行动态扩容时我们需要两段的元素列表分别拷贝到对应的位置中。</p>\n<p>循环顺序队列实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/CircularQueue.cpp\">CircularQueue.cpp</a></p>\n<h2 id=\"3-6-链式队列\"><a href=\"#3-6-链式队列\" class=\"headerlink\" title=\"3.6 链式队列\"></a>3.6 链式队列</h2><p>很显然，基于链式存储结构实现的队列被称为链式队列。</p>\n<p>由于队列的两种常用操作分别作用于队头和队尾，当我们使用单链表实现时，操作队尾元素很容易，但是操作队头元素则需要遍历整个队列，这样会带来较大的性能开销。此时我们可以增加一个指向上一个节点的 <code>prev</code> 指针来将单链表修改为双向链表，然后以同样的方式保存对头元素的指针和队尾元素的指针，之后就可以方便快捷的进行出队和入队操作了。</p>\n<p>双向链表实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/DoublyLinkedNode.cpp\">DoublyLinkedNode.cpp</a></p>\n<p>基于双向链表的链式队列实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedQueue.cpp\">LinkedQueue.cpp</a></p>\n<!-- ## 3.7 双端队列\n\n## 3.8 顺序双端队列 -->\n\n<h1 id=\"4-参考\"><a href=\"#4-参考\" class=\"headerlink\" title=\"4. 参考\"></a>4. 参考</h1><ul>\n<li><a href=\"https://en.cppreference.com/w/cpp/container\">CPP Reference Containers library</a></li>\n<li><a href=\"https://www.matools.com/api/java8\">Java8 API 中文文档</a></li>\n</ul>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"前言（啰嗦两句）\"><a href=\"#前言（啰嗦两句）\" class=\"headerlink\" title=\"前言（啰嗦两句）\"></a>前言（啰嗦两句）</h1><p>作为一名普通野鸡大学的毕业的科班生，虽然在学校学过《数据结构》这样一门课程，但彼时的我所有的编码经验也就只是写过一些诸如杨辉三角，水仙花数之类的例题，因而在结课后很快就还给老师了……</p>\n<p>最近颇乏于写应用层代码，终于又双叒叕难得想学数据结构了，遂打算开一个系列，希望能够有始有终的写完。</p>\n<p><a href=\"https://github.com/yuchiXiong/data-structure\">yuchiXiong&#x2F;data-structure: 我又双叒叕准备学数据结构啦</a></p>\n<h1 id=\"1-线性表是什么？\"><a href=\"#1-线性表是什么？\" class=\"headerlink\" title=\"1. 线性表是什么？\"></a>1. 线性表是什么？</h1><blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8\">wiki</a>: 线性表是一个具有顺序的，由同类型数据组成的集合，它是常用的数据结构之一。</p>\n</blockquote>\n<p>线性表具有几个基本特征：</p>\n<ol>\n<li>有限性，线性表是一个有限序列。</li>\n<li>有序性，线性表具有基本的顺序属性。</li>\n<li>同一性，线性表元素具有相同的类型。</li>\n</ol>\n<p>关于上述3，在参考广义表的相关定义后，我认为应该更完整的描述为：线性表由同类型数据组成，且该类型被限定为原子类型（如整数、字符串、布尔值等），而非结构类型（如数组、结构体、类等）。</p>\n<p>关于 <code>线性</code> ，我们知道数据结构中还定义了其他诸多非线性数据结构如树、图等。它们在计算机中存储时并非真的表现为树状或图状，而是从逻辑上抽象为树状或图状。线性结构与之类似，当我们将线性表的元素按照逻辑顺序排列时，它呈现为一条线段，因而我们称之为线性结构。对应的，当我们将广义表的元素按照其层次排列时，它并不是一条线段，而更像是一个平面，这正是我们说广义表是一种非线性数据结构的原因，同时也是线性表同一性限制存在的原因。</p>\n<h1 id=\"2-顺序存储与链式存储\"><a href=\"#2-顺序存储与链式存储\" class=\"headerlink\" title=\"2. 顺序存储与链式存储\"></a>2. 顺序存储与链式存储</h1><p>线性表的线性是逻辑层面的，但实际无论是线性表，广义表，还是树，图等，在计算机中存储时，都无外乎两种形式：顺序存储和链式存储。</p>\n<h2 id=\"2-1-顺序存储与顺序表\"><a href=\"#2-1-顺序存储与顺序表\" class=\"headerlink\" title=\"2.1 顺序存储与顺序表\"></a>2.1 顺序存储与顺序表</h2><p>在计算机中存储数据的第一种方式是顺序存储，基于顺序存储方式实现的线性表称为顺序表，举一个比较形象的例子：</p>\n<p><em>你和小伙伴一起去看电影，你当然希望可以和小伙伴们坐在一起，因而你们选择购买了某一座位开始往后的多个</em><em><strong>连续</strong></em><em>的座位。</em></p>\n<p>不难发现，在这一案例中有几个重要的细节：</p>\n<ol>\n<li>我们需要一次性购买多个连续的座位。</li>\n<li>当我们知道第一个座位的编号时，很容通过第一个座位的编号，计算出后面的座位的编号。</li>\n<li>当我们希望在保持原有的座位顺序的前提下，插入一个新的座位时，我们需要将原有的每一个座位向后移动一个位置。</li>\n<li>当我们希望在保持原有的座位顺序的前提下，删除一个已有座位时，我们需要将原有的每一个座位向前移动一个位置。</li>\n</ol>\n<p>我们将这个例子映射到顺序表中，就可以得到顺序表的几个重要特征：</p>\n<ol>\n<li>在使用顺序表时，我们需要一次性申请存储元素所需要的空间。</li>\n<li>通过元素下标我们可以快速的访问元素。</li>\n<li>在插入&#x2F;删除顺序表中的元素时，我们需要将原有的每一个元素向后&#x2F;向前移动一个位置。</li>\n</ol>\n<p>这些特征决定了顺序表最重要的优点：访问速度快。通过下标我们能在 <code>O(1)</code> 时间复杂度内访问到某个元素。</p>\n<p>同时也暴露了顺序表的缺点：</p>\n<ol>\n<li>由于在使用前需要一次性申请指定容量的空间，当遇到数据增长速度较快的场景时，顺序表容量可能会达到最大值而无法添加新的数据，但如果一次性申请的空间过大，则又容易造成浪费。</li>\n<li>如果需要对顺序表进行扩容，则需要额外的空间来进行数据的复制。</li>\n<li>如果需要插入元素到顺序表中，则需要将原有的每一个元素向后移动一个位置，时间复杂度为 <code>O(n)</code>。</li>\n</ol>\n<p>最后，以 <code>C</code> 语言为例，我们可以将数组看作一个顺序表，但值得注意的是，在部分动态语言如 <code>Python/JavaScript/Ruby</code> 等中，数组元素的类型是动态的，它可以是数组、对象等任何类型的数据，此时的数组则更应该看作广义表而非线性表。</p>\n<h2 id=\"2-2-链式存储与链表\"><a href=\"#2-2-链式存储与链表\" class=\"headerlink\" title=\"2.2 链式存储与链表\"></a>2.2 链式存储与链表</h2><p>在计算机中存储数据的另一种方式是链式存储，基于链式存储方式实现的线性表称为链表。</p>\n<p>链表的每一个节点分散存储在不同的地址，而后使用一个 <code>next</code> 指针来指向下一个节点，最终实现了维护其逻辑上的线性的目的。这样做的好处是当我们需要对链表进行修改时，无需再对其他元素进行移动操作：</p>\n<ol>\n<li>当需要在链表中插入新节点时，我们只需要修改目标位置上一个位置节点的 <code>next</code> 指针指向新节点，然后将新节点的 <code>next</code> 指针指向原有位置上的节点即可。</li>\n<li>当需要在链表中删除一个节点时，我们只需要将目标位置上一个位置节点的 <code>next</code> 指针指向目标位置下一个节点即可。</li>\n<li>当需要在表头插入新节点时，我们只需要将新节点的 <code>next</code> 指针指向原有的表头即可。</li>\n<li>当需要在表尾插入新节点时，我们只需要将表尾节点的 <code>next</code> 指针指向新节点即可。</li>\n</ol>\n<p>但由于链表的线性关系是通过 <code>next</code> 指针来实现的，因此当希望读取链表的某一个元素时，无法通过下标的方式以 <code>O(1)</code> 的时间复杂度完成而是需要进行遍历，时间复杂度为 <code>O(n)</code>。</p>\n<p>基本单链表节点实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedNode.cpp\">LinkedNode.cpp</a></p>\n<h1 id=\"3-常见线性数据结构\"><a href=\"#3-常见线性数据结构\" class=\"headerlink\" title=\"3. 常见线性数据结构\"></a>3. 常见线性数据结构</h1><p>在实际的使用过程中，我们经常基于线性表来实现一些更符合业务场景的数据结构。</p>\n<h2 id=\"3-1-变长数组\"><a href=\"#3-1-变长数组\" class=\"headerlink\" title=\"3.1 变长数组\"></a>3.1 变长数组</h2><p>由于顺序表始终需要维护一个固定的长度，在使用过程中扩容极不方便，因而我们可以基于顺序表来实现一个变长数组，使其能够在使用的过程中进行动态扩容。</p>\n<p><code>Java Collection Framework</code>（简称 <code>JCF</code>) 中实现的 <code>ArrayList/Vector</code> 以及 <code>CPP STL Container adaptors</code> 中提供的 <code>Vector</code> 都可以看作一个变长数组。其实现的原理大致为，当向数组中添加或删除元素时，首先检查数组的容量：</p>\n<ol>\n<li>如果当前数组的容量不足以添加新的元素，将数组扩容（通常为原来的两倍），然后将原来的数据复制到新的数组中。</li>\n<li>如果当前数组的使用容量低于阈值（通常是当前容量的 <code>1/4</code> ），将数组的容量缩小为原来的一半，然后将原来的数据复制到新的数组中。</li>\n</ol>\n<p>变长数组实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/Vector.cpp\">Vector.cpp</a></p>\n<h2 id=\"3-2-链式线性容器\"><a href=\"#3-2-链式线性容器\" class=\"headerlink\" title=\"3.2 链式线性容器\"></a>3.2 链式线性容器</h2><p>基础的链表节点实现在使用时并不太方便，我们可以基于此封装一个与变长数组相似的链式线性容器。</p>\n<p>基于单链表的链式线性容器实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/SLinkedList.cpp\">SLinkedList.cpp</a></p>\n<p>基于双向链表的链式线性容器实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedList.cpp\">LinkedList.cpp</a></p>\n<h2 id=\"3-3-顺序栈\"><a href=\"#3-3-顺序栈\" class=\"headerlink\" title=\"3.3 顺序栈\"></a>3.3 顺序栈</h2><p>栈是一种受限制的线性表，其特点是 <code>First In Last Out</code> (简称 <code>FILO</code> )，即先进后出。</p>\n<p>现实生活中的羽毛球桶就可以看作一个栈，当一个球桶里装满球时，只能先取出后放进的羽毛球，再取出倒数第二次序放入的羽毛球。</p>\n<p>栈有两个基本操作：</p>\n<ul>\n<li>将元素押入栈顶，即入栈</li>\n<li>从栈中弹出栈顶元素，即出栈</li>\n</ul>\n<p>栈是一种非常实用的数据结构，例如前端开发中比较常提及的页面跳转栈，在页面跳转过程中，我们可以将页面跳转的每一步都保存在栈中，当页面进行回退操作时，我们可以从栈中取出每一步的跳转页面，直到栈为空。</p>\n<p>基于线性表我们可以很快的实现一个栈数据结构，不过由于线性表具体分为顺序表和链表两种，因而实现栈也有两种方式。其中通过顺序表实现的栈被称为顺序栈。</p>\n<p>实现顺序栈通常来说不太困难，但考虑到顺序表固定长度的特性，为了使顺序栈拥有更好的可用性，我们可以通过变长数组来实现。而对于栈的弹出和押入操作，只需要简单的对变长数组队尾的元素进行简单的操作即可。同时，由于栈的操作中不涉及到在已有序列中插入和删除元素的操作，因而恰好避开了顺序表在插入和删除元素时需要移动元素的问题。</p>\n<p>顺序栈实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/ArrayStack.cpp\">ArrayStack.cpp</a></p>\n<h2 id=\"3-4-链式栈\"><a href=\"#3-4-链式栈\" class=\"headerlink\" title=\"3.4 链式栈\"></a>3.4 链式栈</h2><p>除了使用顺序表实现的栈，我们还可以使用链表来实现栈。链式栈和顺序栈本质上来说没有什么太大的区别，只是底层的存储方式不太一样。</p>\n<p>基于链表实现的栈，主要的思路是维护一个链表的头节点，当押入新元素到栈内时，只需要基于新元素创建一个新的节点，并将头节点插入到新节点的后面即可。而弹出时，只需要将内部维护的头节点更新为当前头节点的下一个节点即可。以下给出的参考代码实现是基于双向链表的，但由于栈数据结构始终只对尾节点进行操作，因而使用双向链表并不能简化操作，甚至还会导致实现的抽象难度增加。</p>\n<p>链式栈实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedStack.cpp\">LinkedStack.cpp</a></p>\n<h2 id=\"3-5-顺序队列，假溢出和循环队列\"><a href=\"#3-5-顺序队列，假溢出和循环队列\" class=\"headerlink\" title=\"3.5 顺序队列，假溢出和循环队列\"></a>3.5 顺序队列，假溢出和循环队列</h2><p>队列同样是一种受限制的线性表，其特点是 <code>First In First Out</code> (简称 <code>FIFO</code> )，即先进先出。</p>\n<p>在现实生活中，我们其实经常使用到队列的特性，比如超市的排队等等。对于一个队列我们有两种基本的操作：</p>\n<ul>\n<li>元素入队，即把元素插入队列的尾部</li>\n<li>元素出队，即把队列的头元素删除</li>\n</ul>\n<p>与顺序栈和链式栈相同，队列也有两种实现方式，一种是顺序队列，另一种是链式队列。</p>\n<p>同样考虑到顺序表定长的特性，在实际实现中我们可以考虑基于变长数组来实现队列以支持自适应动态扩容和缩容。</p>\n<p>当元素入队时，我们只需要把元素插入到变长数组的尾部即可，但当元素出队时问题就显的稍微复杂一些了。当元素出队时，我们需要删除队列的头元素，考虑到如果将后续元素都向前位移必定会造成大量的性能损耗，我们可以维护一个标识来表示实际的队列头。然而这样又回引出新的问题，既当元素不断的出队与入队，队头的标识会越来越靠后，这样势必会导致顺序队列中存在大量的连续的空间浪费。</p>\n<p>基于变长数组的顺序队列实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/ArrayQueue.cpp\">ArrayQueue.cpp</a></p>\n<p>我们可以使用循环队列来解决这些问题，既当队列元素入队时，如果当前队尾元素的下标超过了队列的最大容量，那么我们就将队尾元素的下标重置为0，这样可以保证队列中的元素是连续的同时，不浪费之前的空间。而当元素出队时，我们还是一样删除队尾元素即可。当然，由于循环队列从存储上来说并不是完全连续的，在对变长数组进行动态扩容时我们需要两段的元素列表分别拷贝到对应的位置中。</p>\n<p>循环顺序队列实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/CircularQueue.cpp\">CircularQueue.cpp</a></p>\n<h2 id=\"3-6-链式队列\"><a href=\"#3-6-链式队列\" class=\"headerlink\" title=\"3.6 链式队列\"></a>3.6 链式队列</h2><p>很显然，基于链式存储结构实现的队列被称为链式队列。</p>\n<p>由于队列的两种常用操作分别作用于队头和队尾，当我们使用单链表实现时，操作队尾元素很容易，但是操作队头元素则需要遍历整个队列，这样会带来较大的性能开销。此时我们可以增加一个指向上一个节点的 <code>prev</code> 指针来将单链表修改为双向链表，然后以同样的方式保存对头元素的指针和队尾元素的指针，之后就可以方便快捷的进行出队和入队操作了。</p>\n<p>双向链表实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/DoublyLinkedNode.cpp\">DoublyLinkedNode.cpp</a></p>\n<p>基于双向链表的链式队列实现 <a href=\"https://github.com/yuchiXiong/data-structure/blob/main/LinearList/LinkedQueue.cpp\">LinkedQueue.cpp</a></p>\n<!-- ## 3.7 双端队列\n\n## 3.8 顺序双端队列 -->\n\n<h1 id=\"4-参考\"><a href=\"#4-参考\" class=\"headerlink\" title=\"4. 参考\"></a>4. 参考</h1><ul>\n<li><a href=\"https://en.cppreference.com/w/cpp/container\">CPP Reference Containers library</a></li>\n<li><a href=\"https://www.matools.com/api/java8\">Java8 API 中文文档</a></li>\n</ul>\n"},{"title":"练手项目：BullShit聊天室（第一天）","date":"2018-10-16T02:47:00.000Z","_content":"接到关于毕业设计的一些课题，在其中看到不少可以尝试的项目，电子商城，网络聊天室等等。在课上也挺无聊的，就开始尝试写了个网络聊天室的小Demo。\n\n## 1. 设想\n\n用一个页面 不断从数据库读取内容（用户消息），并对每一条记录进行排版。先做出后端的逻辑，然后补上前端。\n\n![预想程序效果](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/1.webp)\n\n## 2. 实现\n\n### 2.0 数据库的搭建\n\n没有做过专业的表结构分析- -所以只能想到哪儿做到哪儿\n\n![简单的不能再简单的表结构](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/2.webp)\n\n\n### 2.1 用于接受数据并排版，然后嵌入在用户聊天界面的页面`News.jsp`\n\n这个页面的主要功能就是接受数据库里的信息，然后排版遍历输出，之后利用`iframe`嵌入用户聊天的界面中。\n\n说归说实际实现起来真的惨不忍睹\n- 第一版：在页面中直接使用`JDBC`连接数据库，对获取到的结果集遍历生成`HTML`代码，之后使用`JavaScript`计时器不停的刷新页面得到最新的数据库结果。\n我一定要吐槽这种写法真的很傻*，后面嵌入到用户界面闪闪闪个不停，并且滚动条完全没法拖动。\n- 第二版：为了解决局部刷新，学习了`AJAX`，同时也重写了之前的页面，将大部分`Jsp`代码都写进了`Servlet`中，不管怎么说至少我觉得舒服多了吧。\n\n![News.jsp第二版](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/3.webp)\n\n说明：页面结构里本身什么都没有，页面加载之后启动`JavaScript`的计时器开始执行`Ajax`,`Ajax`发送请求到`GetNewsServlet`中，在`GetNewsServlet`中完成对数据库的遍历并将生成的代码发送回来，之后写入到页面。\n\n![GetNewsServlet](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/4.webp)\n\n说明：这一版本也没有见多好= =！只是学了点`Ajax`之后，可以处理异步刷新了，至少不会闪啊闪的刷新了。\n\n### 2.2 用户界面页\n说来界面页应该做好前端的……但是此时的我却一句CSS都没写_(:з」∠)_\n\n先分析一下功能：这个页面主要功能有两个，第一是显示聊天记录；第二则是发送聊天内容。功能一需要的是嵌入之前的网页，而功能二则是往数据库中插入记录。\n\n事实上因为写这个页面的时候什么也没想，这个页面的版本还真挺难算的……\n- 第一版：最最最最最最最最无聊的垃圾代码，重复了80%的jdbc代码（剩下20%是把`Statement`换成了`PreparedStatement`）,使用表单传数据然后为了处理插入数据库的操作还专门写了一个`Seeding.jsp`的页面。\n- 第二版：前面已经写了获取`Connection`对象的工具类以及消息对应的实体类。此处又再前者的基础上增加了一个用于插入数据库的`SendNewsServlet`类。\n\n![相比遍历时的内容这里就相对比较简单了](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/5.webp)\n\n页面里的`ajax`还是要说一下的，一开始目的很纯粹只是发送数据到对应的`Servlet`，因为没有做规划所以当时的用户名用的是`String UserName=\"用户\"`,之后扔到服务器上消息的显示着实不清晰，于是去找了个简单的接口获取IP地址和归属地\n\n~~~js\n<script src=\"http://pv.sohu.com/cityjson?ie=utf-8\"></script>\nvar ip=returnCitySN[\"cip\"];//获取ip\nvar address=returnCitySN[\"cname\"]//获取地址\n~~~\n\n之后的用户名就用这个来代替了，不过后续加入用户系统之后，这个肯定就不用了。\n\n![用户名](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/6.webp)\n\n## 3. 细节处理\n\n其实写到这里这个小项目的主要功能已经停止了，但实际上我确实不认为这样一个东西能算的上项目，所以在做完前端和细节的处理之后，这边我打算完善其它功能，例如在线人数，一对一私聊等等。此处先处理一些比较严重的细节。\n\n### 3.1 滚动条\n\n问题描述：如上设计中比较硬伤的一个问题是，用户每一次接受到信息的时候，滚动条的位置都是在最顶部，那么使用起来非常不方便甚至会使用户产生没有新消息的错觉。\n\n解决方法：获取`iframe`连接的页面，然后设置滚动条高度为实际内容高度\n\n~~~js\nvar x = $(\"#News_iframe\")[0].contentWindow.document;\n$(x).scrollTop($(x).height() + 56);\n~~~\n\n但这里的问题并没有完全解决，我把这段代码放在了用户发送信息时的`JavaScript`中，这样每一次用户发送数据都可以看到最新消息。然而其它用户在接受到消息的时候并不会触发这段代码，因此其它用户的消息框滚动条并不会产生改变。如果将代码放入接受消息的计时器中，则又会产生计时器执行过快导致页面一直被迫显示最底部，翻阅了一本教材里的项目案例《精彩人生聊天室》，发现其代码使用的是`News.jsp`版本一的写法，也就是那个闪瞎眼的写法，叫人无力吐槽。\n\n### 2.2 按键绑定\n问题描述：在发表消息时出现了一个问题是有时候能发送有时候却不能发送，仔细排查发现是有时候无意识的用鼠标单击发送按钮，而有时候又是按的`enter`键\n\n解决过程：一开始没有多想，找了一些关于按键绑定的内容看了一下，给发表按钮做了按键绑定。\n\n~~~js\n$(document).keydown(function(e) {\n\tvar eCode = e.keyCode ? e.keyCode : e.which ? e.which : e.charCode;\n\tif (eCode == 13)\n\t\tajaxFun();\n\t})\n~~~\n\n经过以上处理之后发现，按键检测的内容可以触发，但消息依然无法发送，并且有明显的刷新迹象。随机考虑到`Submit`按钮与`Enter`键似乎本身有绑定，加上此环境下本身就不需要表单，于是删除了页面中的表单并修改按钮类型为`button`，问题解决。\n\n## 3. 版本管理\n之前已经在服务器上装了Git了，不过多赘述了。\n\n## 4. 心得\n在一天时间里去做了这样一个小练手个人还是蛮开心的，首先不管怎么说学到了东西，今后的开发过程中`ajax`是必不可少的，而获取`IP`的接口也非常有趣。\n\n同时这一天也暴露了非常多的问题，首当其冲的应该是开发没有规划，大量代码的重写浪费了一些时间。其次是`JavaScript`的基础非常有问题，正如我之前文章里所说的一样：“在我尚未很好的掌握js的时候，有一件更可怕的事情那就是我已经用上jQuery了”，这一点令我比较担忧，有时间的话还是要更熟练的掌握原生`JavaScript`才可以。\n\n之后的几天里打算完善功能，然后心思就可以放在前端上了……\n","source":"_posts/练手项目：BullShit聊天室（第一天）.md","raw":"---\ntitle: 练手项目：BullShit聊天室（第一天）\ndate:  2018.10.16 10:47\ntags:\n  - Java\ncategories:\n  - 好饿，早知道不学编程了\n---\n接到关于毕业设计的一些课题，在其中看到不少可以尝试的项目，电子商城，网络聊天室等等。在课上也挺无聊的，就开始尝试写了个网络聊天室的小Demo。\n\n## 1. 设想\n\n用一个页面 不断从数据库读取内容（用户消息），并对每一条记录进行排版。先做出后端的逻辑，然后补上前端。\n\n![预想程序效果](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/1.webp)\n\n## 2. 实现\n\n### 2.0 数据库的搭建\n\n没有做过专业的表结构分析- -所以只能想到哪儿做到哪儿\n\n![简单的不能再简单的表结构](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/2.webp)\n\n\n### 2.1 用于接受数据并排版，然后嵌入在用户聊天界面的页面`News.jsp`\n\n这个页面的主要功能就是接受数据库里的信息，然后排版遍历输出，之后利用`iframe`嵌入用户聊天的界面中。\n\n说归说实际实现起来真的惨不忍睹\n- 第一版：在页面中直接使用`JDBC`连接数据库，对获取到的结果集遍历生成`HTML`代码，之后使用`JavaScript`计时器不停的刷新页面得到最新的数据库结果。\n我一定要吐槽这种写法真的很傻*，后面嵌入到用户界面闪闪闪个不停，并且滚动条完全没法拖动。\n- 第二版：为了解决局部刷新，学习了`AJAX`，同时也重写了之前的页面，将大部分`Jsp`代码都写进了`Servlet`中，不管怎么说至少我觉得舒服多了吧。\n\n![News.jsp第二版](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/3.webp)\n\n说明：页面结构里本身什么都没有，页面加载之后启动`JavaScript`的计时器开始执行`Ajax`,`Ajax`发送请求到`GetNewsServlet`中，在`GetNewsServlet`中完成对数据库的遍历并将生成的代码发送回来，之后写入到页面。\n\n![GetNewsServlet](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/4.webp)\n\n说明：这一版本也没有见多好= =！只是学了点`Ajax`之后，可以处理异步刷新了，至少不会闪啊闪的刷新了。\n\n### 2.2 用户界面页\n说来界面页应该做好前端的……但是此时的我却一句CSS都没写_(:з」∠)_\n\n先分析一下功能：这个页面主要功能有两个，第一是显示聊天记录；第二则是发送聊天内容。功能一需要的是嵌入之前的网页，而功能二则是往数据库中插入记录。\n\n事实上因为写这个页面的时候什么也没想，这个页面的版本还真挺难算的……\n- 第一版：最最最最最最最最无聊的垃圾代码，重复了80%的jdbc代码（剩下20%是把`Statement`换成了`PreparedStatement`）,使用表单传数据然后为了处理插入数据库的操作还专门写了一个`Seeding.jsp`的页面。\n- 第二版：前面已经写了获取`Connection`对象的工具类以及消息对应的实体类。此处又再前者的基础上增加了一个用于插入数据库的`SendNewsServlet`类。\n\n![相比遍历时的内容这里就相对比较简单了](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/5.webp)\n\n页面里的`ajax`还是要说一下的，一开始目的很纯粹只是发送数据到对应的`Servlet`，因为没有做规划所以当时的用户名用的是`String UserName=\"用户\"`,之后扔到服务器上消息的显示着实不清晰，于是去找了个简单的接口获取IP地址和归属地\n\n~~~js\n<script src=\"http://pv.sohu.com/cityjson?ie=utf-8\"></script>\nvar ip=returnCitySN[\"cip\"];//获取ip\nvar address=returnCitySN[\"cname\"]//获取地址\n~~~\n\n之后的用户名就用这个来代替了，不过后续加入用户系统之后，这个肯定就不用了。\n\n![用户名](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/6.webp)\n\n## 3. 细节处理\n\n其实写到这里这个小项目的主要功能已经停止了，但实际上我确实不认为这样一个东西能算的上项目，所以在做完前端和细节的处理之后，这边我打算完善其它功能，例如在线人数，一对一私聊等等。此处先处理一些比较严重的细节。\n\n### 3.1 滚动条\n\n问题描述：如上设计中比较硬伤的一个问题是，用户每一次接受到信息的时候，滚动条的位置都是在最顶部，那么使用起来非常不方便甚至会使用户产生没有新消息的错觉。\n\n解决方法：获取`iframe`连接的页面，然后设置滚动条高度为实际内容高度\n\n~~~js\nvar x = $(\"#News_iframe\")[0].contentWindow.document;\n$(x).scrollTop($(x).height() + 56);\n~~~\n\n但这里的问题并没有完全解决，我把这段代码放在了用户发送信息时的`JavaScript`中，这样每一次用户发送数据都可以看到最新消息。然而其它用户在接受到消息的时候并不会触发这段代码，因此其它用户的消息框滚动条并不会产生改变。如果将代码放入接受消息的计时器中，则又会产生计时器执行过快导致页面一直被迫显示最底部，翻阅了一本教材里的项目案例《精彩人生聊天室》，发现其代码使用的是`News.jsp`版本一的写法，也就是那个闪瞎眼的写法，叫人无力吐槽。\n\n### 2.2 按键绑定\n问题描述：在发表消息时出现了一个问题是有时候能发送有时候却不能发送，仔细排查发现是有时候无意识的用鼠标单击发送按钮，而有时候又是按的`enter`键\n\n解决过程：一开始没有多想，找了一些关于按键绑定的内容看了一下，给发表按钮做了按键绑定。\n\n~~~js\n$(document).keydown(function(e) {\n\tvar eCode = e.keyCode ? e.keyCode : e.which ? e.which : e.charCode;\n\tif (eCode == 13)\n\t\tajaxFun();\n\t})\n~~~\n\n经过以上处理之后发现，按键检测的内容可以触发，但消息依然无法发送，并且有明显的刷新迹象。随机考虑到`Submit`按钮与`Enter`键似乎本身有绑定，加上此环境下本身就不需要表单，于是删除了页面中的表单并修改按钮类型为`button`，问题解决。\n\n## 3. 版本管理\n之前已经在服务器上装了Git了，不过多赘述了。\n\n## 4. 心得\n在一天时间里去做了这样一个小练手个人还是蛮开心的，首先不管怎么说学到了东西，今后的开发过程中`ajax`是必不可少的，而获取`IP`的接口也非常有趣。\n\n同时这一天也暴露了非常多的问题，首当其冲的应该是开发没有规划，大量代码的重写浪费了一些时间。其次是`JavaScript`的基础非常有问题，正如我之前文章里所说的一样：“在我尚未很好的掌握js的时候，有一件更可怕的事情那就是我已经用上jQuery了”，这一点令我比较担忧，有时间的话还是要更熟练的掌握原生`JavaScript`才可以。\n\n之后的几天里打算完善功能，然后心思就可以放在前端上了……\n","slug":"练手项目：BullShit聊天室（第一天）","published":1,"updated":"2022-05-03T09:54:54.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mduq002yr2ve2lhnf4k4","content":"<p>接到关于毕业设计的一些课题，在其中看到不少可以尝试的项目，电子商城，网络聊天室等等。在课上也挺无聊的，就开始尝试写了个网络聊天室的小Demo。</p>\n<h2 id=\"1-设想\"><a href=\"#1-设想\" class=\"headerlink\" title=\"1. 设想\"></a>1. 设想</h2><p>用一个页面 不断从数据库读取内容（用户消息），并对每一条记录进行排版。先做出后端的逻辑，然后补上前端。</p>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/1.webp\" alt=\"预想程序效果\"></p>\n<h2 id=\"2-实现\"><a href=\"#2-实现\" class=\"headerlink\" title=\"2. 实现\"></a>2. 实现</h2><h3 id=\"2-0-数据库的搭建\"><a href=\"#2-0-数据库的搭建\" class=\"headerlink\" title=\"2.0 数据库的搭建\"></a>2.0 数据库的搭建</h3><p>没有做过专业的表结构分析- -所以只能想到哪儿做到哪儿</p>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/2.webp\" alt=\"简单的不能再简单的表结构\"></p>\n<h3 id=\"2-1-用于接受数据并排版，然后嵌入在用户聊天界面的页面News-jsp\"><a href=\"#2-1-用于接受数据并排版，然后嵌入在用户聊天界面的页面News-jsp\" class=\"headerlink\" title=\"2.1 用于接受数据并排版，然后嵌入在用户聊天界面的页面News.jsp\"></a>2.1 用于接受数据并排版，然后嵌入在用户聊天界面的页面<code>News.jsp</code></h3><p>这个页面的主要功能就是接受数据库里的信息，然后排版遍历输出，之后利用<code>iframe</code>嵌入用户聊天的界面中。</p>\n<p>说归说实际实现起来真的惨不忍睹</p>\n<ul>\n<li>第一版：在页面中直接使用<code>JDBC</code>连接数据库，对获取到的结果集遍历生成<code>HTML</code>代码，之后使用<code>JavaScript</code>计时器不停的刷新页面得到最新的数据库结果。<br>我一定要吐槽这种写法真的很傻*，后面嵌入到用户界面闪闪闪个不停，并且滚动条完全没法拖动。</li>\n<li>第二版：为了解决局部刷新，学习了<code>AJAX</code>，同时也重写了之前的页面，将大部分<code>Jsp</code>代码都写进了<code>Servlet</code>中，不管怎么说至少我觉得舒服多了吧。</li>\n</ul>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/3.webp\" alt=\"News.jsp第二版\"></p>\n<p>说明：页面结构里本身什么都没有，页面加载之后启动<code>JavaScript</code>的计时器开始执行<code>Ajax</code>,<code>Ajax</code>发送请求到<code>GetNewsServlet</code>中，在<code>GetNewsServlet</code>中完成对数据库的遍历并将生成的代码发送回来，之后写入到页面。</p>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/4.webp\" alt=\"GetNewsServlet\"></p>\n<p>说明：这一版本也没有见多好&#x3D; &#x3D;！只是学了点<code>Ajax</code>之后，可以处理异步刷新了，至少不会闪啊闪的刷新了。</p>\n<h3 id=\"2-2-用户界面页\"><a href=\"#2-2-用户界面页\" class=\"headerlink\" title=\"2.2 用户界面页\"></a>2.2 用户界面页</h3><p>说来界面页应该做好前端的……但是此时的我却一句CSS都没写_(:з」∠)_</p>\n<p>先分析一下功能：这个页面主要功能有两个，第一是显示聊天记录；第二则是发送聊天内容。功能一需要的是嵌入之前的网页，而功能二则是往数据库中插入记录。</p>\n<p>事实上因为写这个页面的时候什么也没想，这个页面的版本还真挺难算的……</p>\n<ul>\n<li>第一版：最最最最最最最最无聊的垃圾代码，重复了80%的jdbc代码（剩下20%是把<code>Statement</code>换成了<code>PreparedStatement</code>）,使用表单传数据然后为了处理插入数据库的操作还专门写了一个<code>Seeding.jsp</code>的页面。</li>\n<li>第二版：前面已经写了获取<code>Connection</code>对象的工具类以及消息对应的实体类。此处又再前者的基础上增加了一个用于插入数据库的<code>SendNewsServlet</code>类。</li>\n</ul>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/5.webp\" alt=\"相比遍历时的内容这里就相对比较简单了\"></p>\n<p>页面里的<code>ajax</code>还是要说一下的，一开始目的很纯粹只是发送数据到对应的<code>Servlet</code>，因为没有做规划所以当时的用户名用的是<code>String UserName=&quot;用户&quot;</code>,之后扔到服务器上消息的显示着实不清晰，于是去找了个简单的接口获取IP地址和归属地</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">&quot;http://pv.sohu.com/cityjson?ie=utf-8&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> ip=returnCitySN[<span class=\"string\">&quot;cip&quot;</span>];<span class=\"comment\">//获取ip</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> address=returnCitySN[<span class=\"string\">&quot;cname&quot;</span>]<span class=\"comment\">//获取地址</span></span><br></pre></td></tr></table></figure>\n\n<p>之后的用户名就用这个来代替了，不过后续加入用户系统之后，这个肯定就不用了。</p>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/6.webp\" alt=\"用户名\"></p>\n<h2 id=\"3-细节处理\"><a href=\"#3-细节处理\" class=\"headerlink\" title=\"3. 细节处理\"></a>3. 细节处理</h2><p>其实写到这里这个小项目的主要功能已经停止了，但实际上我确实不认为这样一个东西能算的上项目，所以在做完前端和细节的处理之后，这边我打算完善其它功能，例如在线人数，一对一私聊等等。此处先处理一些比较严重的细节。</p>\n<h3 id=\"3-1-滚动条\"><a href=\"#3-1-滚动条\" class=\"headerlink\" title=\"3.1 滚动条\"></a>3.1 滚动条</h3><p>问题描述：如上设计中比较硬伤的一个问题是，用户每一次接受到信息的时候，滚动条的位置都是在最顶部，那么使用起来非常不方便甚至会使用户产生没有新消息的错觉。</p>\n<p>解决方法：获取<code>iframe</code>连接的页面，然后设置滚动条高度为实际内容高度</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = $(<span class=\"string\">&quot;#News_iframe&quot;</span>)[<span class=\"number\">0</span>].<span class=\"property\">contentWindow</span>.<span class=\"property\">document</span>;</span><br><span class=\"line\">$(x).<span class=\"title function_\">scrollTop</span>($(x).<span class=\"title function_\">height</span>() + <span class=\"number\">56</span>);</span><br></pre></td></tr></table></figure>\n\n<p>但这里的问题并没有完全解决，我把这段代码放在了用户发送信息时的<code>JavaScript</code>中，这样每一次用户发送数据都可以看到最新消息。然而其它用户在接受到消息的时候并不会触发这段代码，因此其它用户的消息框滚动条并不会产生改变。如果将代码放入接受消息的计时器中，则又会产生计时器执行过快导致页面一直被迫显示最底部，翻阅了一本教材里的项目案例《精彩人生聊天室》，发现其代码使用的是<code>News.jsp</code>版本一的写法，也就是那个闪瞎眼的写法，叫人无力吐槽。</p>\n<h3 id=\"2-2-按键绑定\"><a href=\"#2-2-按键绑定\" class=\"headerlink\" title=\"2.2 按键绑定\"></a>2.2 按键绑定</h3><p>问题描述：在发表消息时出现了一个问题是有时候能发送有时候却不能发送，仔细排查发现是有时候无意识的用鼠标单击发送按钮，而有时候又是按的<code>enter</code>键</p>\n<p>解决过程：一开始没有多想，找了一些关于按键绑定的内容看了一下，给发表按钮做了按键绑定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">keydown</span>(<span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> eCode = e.<span class=\"property\">keyCode</span> ? e.<span class=\"property\">keyCode</span> : e.<span class=\"property\">which</span> ? e.<span class=\"property\">which</span> : e.<span class=\"property\">charCode</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (eCode == <span class=\"number\">13</span>)</span><br><span class=\"line\">\t\t<span class=\"title function_\">ajaxFun</span>();</span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>经过以上处理之后发现，按键检测的内容可以触发，但消息依然无法发送，并且有明显的刷新迹象。随机考虑到<code>Submit</code>按钮与<code>Enter</code>键似乎本身有绑定，加上此环境下本身就不需要表单，于是删除了页面中的表单并修改按钮类型为<code>button</code>，问题解决。</p>\n<h2 id=\"3-版本管理\"><a href=\"#3-版本管理\" class=\"headerlink\" title=\"3. 版本管理\"></a>3. 版本管理</h2><p>之前已经在服务器上装了Git了，不过多赘述了。</p>\n<h2 id=\"4-心得\"><a href=\"#4-心得\" class=\"headerlink\" title=\"4. 心得\"></a>4. 心得</h2><p>在一天时间里去做了这样一个小练手个人还是蛮开心的，首先不管怎么说学到了东西，今后的开发过程中<code>ajax</code>是必不可少的，而获取<code>IP</code>的接口也非常有趣。</p>\n<p>同时这一天也暴露了非常多的问题，首当其冲的应该是开发没有规划，大量代码的重写浪费了一些时间。其次是<code>JavaScript</code>的基础非常有问题，正如我之前文章里所说的一样：“在我尚未很好的掌握js的时候，有一件更可怕的事情那就是我已经用上jQuery了”，这一点令我比较担忧，有时间的话还是要更熟练的掌握原生<code>JavaScript</code>才可以。</p>\n<p>之后的几天里打算完善功能，然后心思就可以放在前端上了……</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<p>接到关于毕业设计的一些课题，在其中看到不少可以尝试的项目，电子商城，网络聊天室等等。在课上也挺无聊的，就开始尝试写了个网络聊天室的小Demo。</p>\n<h2 id=\"1-设想\"><a href=\"#1-设想\" class=\"headerlink\" title=\"1. 设想\"></a>1. 设想</h2><p>用一个页面 不断从数据库读取内容（用户消息），并对每一条记录进行排版。先做出后端的逻辑，然后补上前端。</p>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/1.webp\" alt=\"预想程序效果\"></p>\n<h2 id=\"2-实现\"><a href=\"#2-实现\" class=\"headerlink\" title=\"2. 实现\"></a>2. 实现</h2><h3 id=\"2-0-数据库的搭建\"><a href=\"#2-0-数据库的搭建\" class=\"headerlink\" title=\"2.0 数据库的搭建\"></a>2.0 数据库的搭建</h3><p>没有做过专业的表结构分析- -所以只能想到哪儿做到哪儿</p>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/2.webp\" alt=\"简单的不能再简单的表结构\"></p>\n<h3 id=\"2-1-用于接受数据并排版，然后嵌入在用户聊天界面的页面News-jsp\"><a href=\"#2-1-用于接受数据并排版，然后嵌入在用户聊天界面的页面News-jsp\" class=\"headerlink\" title=\"2.1 用于接受数据并排版，然后嵌入在用户聊天界面的页面News.jsp\"></a>2.1 用于接受数据并排版，然后嵌入在用户聊天界面的页面<code>News.jsp</code></h3><p>这个页面的主要功能就是接受数据库里的信息，然后排版遍历输出，之后利用<code>iframe</code>嵌入用户聊天的界面中。</p>\n<p>说归说实际实现起来真的惨不忍睹</p>\n<ul>\n<li>第一版：在页面中直接使用<code>JDBC</code>连接数据库，对获取到的结果集遍历生成<code>HTML</code>代码，之后使用<code>JavaScript</code>计时器不停的刷新页面得到最新的数据库结果。<br>我一定要吐槽这种写法真的很傻*，后面嵌入到用户界面闪闪闪个不停，并且滚动条完全没法拖动。</li>\n<li>第二版：为了解决局部刷新，学习了<code>AJAX</code>，同时也重写了之前的页面，将大部分<code>Jsp</code>代码都写进了<code>Servlet</code>中，不管怎么说至少我觉得舒服多了吧。</li>\n</ul>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/3.webp\" alt=\"News.jsp第二版\"></p>\n<p>说明：页面结构里本身什么都没有，页面加载之后启动<code>JavaScript</code>的计时器开始执行<code>Ajax</code>,<code>Ajax</code>发送请求到<code>GetNewsServlet</code>中，在<code>GetNewsServlet</code>中完成对数据库的遍历并将生成的代码发送回来，之后写入到页面。</p>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/4.webp\" alt=\"GetNewsServlet\"></p>\n<p>说明：这一版本也没有见多好&#x3D; &#x3D;！只是学了点<code>Ajax</code>之后，可以处理异步刷新了，至少不会闪啊闪的刷新了。</p>\n<h3 id=\"2-2-用户界面页\"><a href=\"#2-2-用户界面页\" class=\"headerlink\" title=\"2.2 用户界面页\"></a>2.2 用户界面页</h3><p>说来界面页应该做好前端的……但是此时的我却一句CSS都没写_(:з」∠)_</p>\n<p>先分析一下功能：这个页面主要功能有两个，第一是显示聊天记录；第二则是发送聊天内容。功能一需要的是嵌入之前的网页，而功能二则是往数据库中插入记录。</p>\n<p>事实上因为写这个页面的时候什么也没想，这个页面的版本还真挺难算的……</p>\n<ul>\n<li>第一版：最最最最最最最最无聊的垃圾代码，重复了80%的jdbc代码（剩下20%是把<code>Statement</code>换成了<code>PreparedStatement</code>）,使用表单传数据然后为了处理插入数据库的操作还专门写了一个<code>Seeding.jsp</code>的页面。</li>\n<li>第二版：前面已经写了获取<code>Connection</code>对象的工具类以及消息对应的实体类。此处又再前者的基础上增加了一个用于插入数据库的<code>SendNewsServlet</code>类。</li>\n</ul>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/5.webp\" alt=\"相比遍历时的内容这里就相对比较简单了\"></p>\n<p>页面里的<code>ajax</code>还是要说一下的，一开始目的很纯粹只是发送数据到对应的<code>Servlet</code>，因为没有做规划所以当时的用户名用的是<code>String UserName=&quot;用户&quot;</code>,之后扔到服务器上消息的显示着实不清晰，于是去找了个简单的接口获取IP地址和归属地</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">&quot;http://pv.sohu.com/cityjson?ie=utf-8&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\"><span class=\"keyword\">var</span> ip=returnCitySN[<span class=\"string\">&quot;cip&quot;</span>];<span class=\"comment\">//获取ip</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> address=returnCitySN[<span class=\"string\">&quot;cname&quot;</span>]<span class=\"comment\">//获取地址</span></span><br></pre></td></tr></table></figure>\n\n<p>之后的用户名就用这个来代替了，不过后续加入用户系统之后，这个肯定就不用了。</p>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-yi-tian/6.webp\" alt=\"用户名\"></p>\n<h2 id=\"3-细节处理\"><a href=\"#3-细节处理\" class=\"headerlink\" title=\"3. 细节处理\"></a>3. 细节处理</h2><p>其实写到这里这个小项目的主要功能已经停止了，但实际上我确实不认为这样一个东西能算的上项目，所以在做完前端和细节的处理之后，这边我打算完善其它功能，例如在线人数，一对一私聊等等。此处先处理一些比较严重的细节。</p>\n<h3 id=\"3-1-滚动条\"><a href=\"#3-1-滚动条\" class=\"headerlink\" title=\"3.1 滚动条\"></a>3.1 滚动条</h3><p>问题描述：如上设计中比较硬伤的一个问题是，用户每一次接受到信息的时候，滚动条的位置都是在最顶部，那么使用起来非常不方便甚至会使用户产生没有新消息的错觉。</p>\n<p>解决方法：获取<code>iframe</code>连接的页面，然后设置滚动条高度为实际内容高度</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = $(<span class=\"string\">&quot;#News_iframe&quot;</span>)[<span class=\"number\">0</span>].<span class=\"property\">contentWindow</span>.<span class=\"property\">document</span>;</span><br><span class=\"line\">$(x).<span class=\"title function_\">scrollTop</span>($(x).<span class=\"title function_\">height</span>() + <span class=\"number\">56</span>);</span><br></pre></td></tr></table></figure>\n\n<p>但这里的问题并没有完全解决，我把这段代码放在了用户发送信息时的<code>JavaScript</code>中，这样每一次用户发送数据都可以看到最新消息。然而其它用户在接受到消息的时候并不会触发这段代码，因此其它用户的消息框滚动条并不会产生改变。如果将代码放入接受消息的计时器中，则又会产生计时器执行过快导致页面一直被迫显示最底部，翻阅了一本教材里的项目案例《精彩人生聊天室》，发现其代码使用的是<code>News.jsp</code>版本一的写法，也就是那个闪瞎眼的写法，叫人无力吐槽。</p>\n<h3 id=\"2-2-按键绑定\"><a href=\"#2-2-按键绑定\" class=\"headerlink\" title=\"2.2 按键绑定\"></a>2.2 按键绑定</h3><p>问题描述：在发表消息时出现了一个问题是有时候能发送有时候却不能发送，仔细排查发现是有时候无意识的用鼠标单击发送按钮，而有时候又是按的<code>enter</code>键</p>\n<p>解决过程：一开始没有多想，找了一些关于按键绑定的内容看了一下，给发表按钮做了按键绑定。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"variable language_\">document</span>).<span class=\"title function_\">keydown</span>(<span class=\"keyword\">function</span>(<span class=\"params\">e</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> eCode = e.<span class=\"property\">keyCode</span> ? e.<span class=\"property\">keyCode</span> : e.<span class=\"property\">which</span> ? e.<span class=\"property\">which</span> : e.<span class=\"property\">charCode</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (eCode == <span class=\"number\">13</span>)</span><br><span class=\"line\">\t\t<span class=\"title function_\">ajaxFun</span>();</span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>经过以上处理之后发现，按键检测的内容可以触发，但消息依然无法发送，并且有明显的刷新迹象。随机考虑到<code>Submit</code>按钮与<code>Enter</code>键似乎本身有绑定，加上此环境下本身就不需要表单，于是删除了页面中的表单并修改按钮类型为<code>button</code>，问题解决。</p>\n<h2 id=\"3-版本管理\"><a href=\"#3-版本管理\" class=\"headerlink\" title=\"3. 版本管理\"></a>3. 版本管理</h2><p>之前已经在服务器上装了Git了，不过多赘述了。</p>\n<h2 id=\"4-心得\"><a href=\"#4-心得\" class=\"headerlink\" title=\"4. 心得\"></a>4. 心得</h2><p>在一天时间里去做了这样一个小练手个人还是蛮开心的，首先不管怎么说学到了东西，今后的开发过程中<code>ajax</code>是必不可少的，而获取<code>IP</code>的接口也非常有趣。</p>\n<p>同时这一天也暴露了非常多的问题，首当其冲的应该是开发没有规划，大量代码的重写浪费了一些时间。其次是<code>JavaScript</code>的基础非常有问题，正如我之前文章里所说的一样：“在我尚未很好的掌握js的时候，有一件更可怕的事情那就是我已经用上jQuery了”，这一点令我比较担忧，有时间的话还是要更熟练的掌握原生<code>JavaScript</code>才可以。</p>\n<p>之后的几天里打算完善功能，然后心思就可以放在前端上了……</p>\n"},{"title":"练手项目：BullShit聊天室（第二天）","date":"2018-10-17T07:30:00.000Z","_content":"\nBullShit聊天室开发的第二天\n\n昨天已经完成了聊天室的基本雏形，包括（显示消息，发送消息）两个主要功能。\n\n今天在之前的基础上增加了（用户登录功能），同时优化了昨天遗留的（消息显示问题），优化了用户输入框的部分内容并添加了一些前端效果。\n\n本文对于部分重复的内容不再做赘述。\n\n添加用户登录功能\n- 数据表构建\n- 实体类创建\n- 前端的编写\n\n\n此处存疑：在编写 登录/注册 的前端页面时，`Jquery`的`show()`方法无法触发，而另一个类似的按钮可以正常触发，后来删除了`Div`中的`<form>`标签后问题解决了，但事实上在测试用的`Demo`中并没有发现这个问题。\n\n## 1. 消息显示问题\n\n在考虑了昨天的遗留之后做了一些思考：`JavaScript`的计时器会一直执行，为了能更快的获得新的消息，计时器的间隔会很短，而这就一定会造成计时器内的滚动条定位被一直触发，最后使得聊天窗口的滚动条完全没法使用；\n\n\n之所以需要计时器，是为了能不断的获得数据库中的数据，而这一点却存在着一些问题：按照之前的算法，程序在不断的读取数据，然后写在页面上，事实上我们是否需要一直写呢？\n\n~~~js\nfunction callBack() {\n\tif (ajaxReq.readyState === 4) {\n\t\tif(text !== ajaxReq.responseText){\n\t\t\ttext = ajaxReq.responseText;\n\t\t\t$(\"#News_Table\").html(text);\n\t\t\t//默认滚动条最底部\n\t\t\t$(\"body,html\").scrollTop($(\"table\").height());\n\t\t}\t\t\t\n\t}\n}\n~~~\n\n如上修改了`ajax`的回调函数之后，每一次程序获得`Servlet`的反馈后，都会判断本次获取的内容是否发生了改变，如果发生了改变则重新写入新的`Html`代码，同时修改滚动条的位置，解决了昨天的遗留问题。\n\n## 2. 用户输入框的优化\n\n在之前的内容中，用户输入框使用的是`<input type=\"text\"/>`，使用该标签存在一个问题是，`input-text`并不具有换行的功能，也就是说如果输入的文本足够长，该文本框是一直不断的横向滚动而不是自动换行。\n\n不用多说自然是换成了文本域`<textarea></textarea>`标签。\n\n## 3. 前端效果的加入\n这里尝试做一个仿英雄联盟的效果用于加好友。\n\n![添加好友.gif](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-er-tian/1.webp)\n\n值得一提的是，因为类名一样，行为一样，结构一样，这里又遇到了之前[白块儿](https://www.jianshu.com/p/df57faa24e47)里对于事件解绑的问题，不过这次很快就解决了。\n\n~~~js\n$(\"#agree,#refused\").click(function(){\n\tvar height = $(\".friend\").height();\n    $(\".friend\").animate({ height: height + 100 + \"px\" }, 300);\n    $(\"#agree,#refused\").off('click').click(function() {\n\t\t$(this).parent().hide(300);\n    })\n})\n~~~\n\n当然这里的写法并没有对应功能，后端的开发还未完成，因此这里只是做了行为处理和测试。\n\n## 4. 一个非常严重的错误，登录重写\n晚一点的时候发现自己写了一个非常傻*的东西，在判定完登录之后跳转页面直接用`URL`传参了用户的账号，然后在数据库里查询账号的记录并显示了其它的内容。\n\n弊端我就不说了，`URL`里想上哪个账户就上哪个账户，完全不需要密码……\n\n最后自然是重新处理了代码，验证之后把账号密码存进了`Session`中，然后在页面开头从`Session`里取出内容进行验证防止其它更重不允许的跳转。\n\n\n## 5. 最后\n\n第二天的内容到这里就结束了，到此为止得到的是一个不含注册的聊天室应用。\n\n从今天的开发中看到最大的问题就是规划，因为没有考虑好功能的实现，太多时间都花在了重写上。其次关于`JavaScript`基础不足的问题已经没什么好说的了。\n\n给明天定个目标：首先完成注册功能，然后把验证码功能个实装，之后尝试实现添加好友（数据库，后端逻辑）。\n","source":"_posts/练手项目：BullShit聊天室（第二天）.md","raw":"---\ntitle: 练手项目：BullShit聊天室（第二天）\ndate: 2018.10.17 15:30\ntags:\n  - Java\ncategories:\n  - 好饿，早知道不学编程了\n---\n\nBullShit聊天室开发的第二天\n\n昨天已经完成了聊天室的基本雏形，包括（显示消息，发送消息）两个主要功能。\n\n今天在之前的基础上增加了（用户登录功能），同时优化了昨天遗留的（消息显示问题），优化了用户输入框的部分内容并添加了一些前端效果。\n\n本文对于部分重复的内容不再做赘述。\n\n添加用户登录功能\n- 数据表构建\n- 实体类创建\n- 前端的编写\n\n\n此处存疑：在编写 登录/注册 的前端页面时，`Jquery`的`show()`方法无法触发，而另一个类似的按钮可以正常触发，后来删除了`Div`中的`<form>`标签后问题解决了，但事实上在测试用的`Demo`中并没有发现这个问题。\n\n## 1. 消息显示问题\n\n在考虑了昨天的遗留之后做了一些思考：`JavaScript`的计时器会一直执行，为了能更快的获得新的消息，计时器的间隔会很短，而这就一定会造成计时器内的滚动条定位被一直触发，最后使得聊天窗口的滚动条完全没法使用；\n\n\n之所以需要计时器，是为了能不断的获得数据库中的数据，而这一点却存在着一些问题：按照之前的算法，程序在不断的读取数据，然后写在页面上，事实上我们是否需要一直写呢？\n\n~~~js\nfunction callBack() {\n\tif (ajaxReq.readyState === 4) {\n\t\tif(text !== ajaxReq.responseText){\n\t\t\ttext = ajaxReq.responseText;\n\t\t\t$(\"#News_Table\").html(text);\n\t\t\t//默认滚动条最底部\n\t\t\t$(\"body,html\").scrollTop($(\"table\").height());\n\t\t}\t\t\t\n\t}\n}\n~~~\n\n如上修改了`ajax`的回调函数之后，每一次程序获得`Servlet`的反馈后，都会判断本次获取的内容是否发生了改变，如果发生了改变则重新写入新的`Html`代码，同时修改滚动条的位置，解决了昨天的遗留问题。\n\n## 2. 用户输入框的优化\n\n在之前的内容中，用户输入框使用的是`<input type=\"text\"/>`，使用该标签存在一个问题是，`input-text`并不具有换行的功能，也就是说如果输入的文本足够长，该文本框是一直不断的横向滚动而不是自动换行。\n\n不用多说自然是换成了文本域`<textarea></textarea>`标签。\n\n## 3. 前端效果的加入\n这里尝试做一个仿英雄联盟的效果用于加好友。\n\n![添加好友.gif](./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-er-tian/1.webp)\n\n值得一提的是，因为类名一样，行为一样，结构一样，这里又遇到了之前[白块儿](https://www.jianshu.com/p/df57faa24e47)里对于事件解绑的问题，不过这次很快就解决了。\n\n~~~js\n$(\"#agree,#refused\").click(function(){\n\tvar height = $(\".friend\").height();\n    $(\".friend\").animate({ height: height + 100 + \"px\" }, 300);\n    $(\"#agree,#refused\").off('click').click(function() {\n\t\t$(this).parent().hide(300);\n    })\n})\n~~~\n\n当然这里的写法并没有对应功能，后端的开发还未完成，因此这里只是做了行为处理和测试。\n\n## 4. 一个非常严重的错误，登录重写\n晚一点的时候发现自己写了一个非常傻*的东西，在判定完登录之后跳转页面直接用`URL`传参了用户的账号，然后在数据库里查询账号的记录并显示了其它的内容。\n\n弊端我就不说了，`URL`里想上哪个账户就上哪个账户，完全不需要密码……\n\n最后自然是重新处理了代码，验证之后把账号密码存进了`Session`中，然后在页面开头从`Session`里取出内容进行验证防止其它更重不允许的跳转。\n\n\n## 5. 最后\n\n第二天的内容到这里就结束了，到此为止得到的是一个不含注册的聊天室应用。\n\n从今天的开发中看到最大的问题就是规划，因为没有考虑好功能的实现，太多时间都花在了重写上。其次关于`JavaScript`基础不足的问题已经没什么好说的了。\n\n给明天定个目标：首先完成注册功能，然后把验证码功能个实装，之后尝试实现添加好友（数据库，后端逻辑）。\n","slug":"练手项目：BullShit聊天室（第二天）","published":1,"updated":"2022-05-03T09:49:36.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdur0030r2vehj397ee4","content":"<p>BullShit聊天室开发的第二天</p>\n<p>昨天已经完成了聊天室的基本雏形，包括（显示消息，发送消息）两个主要功能。</p>\n<p>今天在之前的基础上增加了（用户登录功能），同时优化了昨天遗留的（消息显示问题），优化了用户输入框的部分内容并添加了一些前端效果。</p>\n<p>本文对于部分重复的内容不再做赘述。</p>\n<p>添加用户登录功能</p>\n<ul>\n<li>数据表构建</li>\n<li>实体类创建</li>\n<li>前端的编写</li>\n</ul>\n<p>此处存疑：在编写 登录&#x2F;注册 的前端页面时，<code>Jquery</code>的<code>show()</code>方法无法触发，而另一个类似的按钮可以正常触发，后来删除了<code>Div</code>中的<code>&lt;form&gt;</code>标签后问题解决了，但事实上在测试用的<code>Demo</code>中并没有发现这个问题。</p>\n<h2 id=\"1-消息显示问题\"><a href=\"#1-消息显示问题\" class=\"headerlink\" title=\"1. 消息显示问题\"></a>1. 消息显示问题</h2><p>在考虑了昨天的遗留之后做了一些思考：<code>JavaScript</code>的计时器会一直执行，为了能更快的获得新的消息，计时器的间隔会很短，而这就一定会造成计时器内的滚动条定位被一直触发，最后使得聊天窗口的滚动条完全没法使用；</p>\n<p>之所以需要计时器，是为了能不断的获得数据库中的数据，而这一点却存在着一些问题：按照之前的算法，程序在不断的读取数据，然后写在页面上，事实上我们是否需要一直写呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">callBack</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ajaxReq.<span class=\"property\">readyState</span> === <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(text !== ajaxReq.<span class=\"property\">responseText</span>)&#123;</span><br><span class=\"line\">\t\t\ttext = ajaxReq.<span class=\"property\">responseText</span>;</span><br><span class=\"line\">\t\t\t$(<span class=\"string\">&quot;#News_Table&quot;</span>).<span class=\"title function_\">html</span>(text);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//默认滚动条最底部</span></span><br><span class=\"line\">\t\t\t$(<span class=\"string\">&quot;body,html&quot;</span>).<span class=\"title function_\">scrollTop</span>($(<span class=\"string\">&quot;table&quot;</span>).<span class=\"title function_\">height</span>());</span><br><span class=\"line\">\t\t&#125;\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上修改了<code>ajax</code>的回调函数之后，每一次程序获得<code>Servlet</code>的反馈后，都会判断本次获取的内容是否发生了改变，如果发生了改变则重新写入新的<code>Html</code>代码，同时修改滚动条的位置，解决了昨天的遗留问题。</p>\n<h2 id=\"2-用户输入框的优化\"><a href=\"#2-用户输入框的优化\" class=\"headerlink\" title=\"2. 用户输入框的优化\"></a>2. 用户输入框的优化</h2><p>在之前的内容中，用户输入框使用的是<code>&lt;input type=&quot;text&quot;/&gt;</code>，使用该标签存在一个问题是，<code>input-text</code>并不具有换行的功能，也就是说如果输入的文本足够长，该文本框是一直不断的横向滚动而不是自动换行。</p>\n<p>不用多说自然是换成了文本域<code>&lt;textarea&gt;&lt;/textarea&gt;</code>标签。</p>\n<h2 id=\"3-前端效果的加入\"><a href=\"#3-前端效果的加入\" class=\"headerlink\" title=\"3. 前端效果的加入\"></a>3. 前端效果的加入</h2><p>这里尝试做一个仿英雄联盟的效果用于加好友。</p>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-er-tian/1.webp\" alt=\"添加好友.gif\"></p>\n<p>值得一提的是，因为类名一样，行为一样，结构一样，这里又遇到了之前<a href=\"https://www.jianshu.com/p/df57faa24e47\">白块儿</a>里对于事件解绑的问题，不过这次很快就解决了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&quot;#agree,#refused&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> height = $(<span class=\"string\">&quot;.friend&quot;</span>).<span class=\"title function_\">height</span>();</span><br><span class=\"line\">    $(<span class=\"string\">&quot;.friend&quot;</span>).<span class=\"title function_\">animate</span>(&#123; <span class=\"attr\">height</span>: height + <span class=\"number\">100</span> + <span class=\"string\">&quot;px&quot;</span> &#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#agree,#refused&quot;</span>).<span class=\"title function_\">off</span>(<span class=\"string\">&#x27;click&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t$(<span class=\"variable language_\">this</span>).<span class=\"title function_\">parent</span>().<span class=\"title function_\">hide</span>(<span class=\"number\">300</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当然这里的写法并没有对应功能，后端的开发还未完成，因此这里只是做了行为处理和测试。</p>\n<h2 id=\"4-一个非常严重的错误，登录重写\"><a href=\"#4-一个非常严重的错误，登录重写\" class=\"headerlink\" title=\"4. 一个非常严重的错误，登录重写\"></a>4. 一个非常严重的错误，登录重写</h2><p>晚一点的时候发现自己写了一个非常傻*的东西，在判定完登录之后跳转页面直接用<code>URL</code>传参了用户的账号，然后在数据库里查询账号的记录并显示了其它的内容。</p>\n<p>弊端我就不说了，<code>URL</code>里想上哪个账户就上哪个账户，完全不需要密码……</p>\n<p>最后自然是重新处理了代码，验证之后把账号密码存进了<code>Session</code>中，然后在页面开头从<code>Session</code>里取出内容进行验证防止其它更重不允许的跳转。</p>\n<h2 id=\"5-最后\"><a href=\"#5-最后\" class=\"headerlink\" title=\"5. 最后\"></a>5. 最后</h2><p>第二天的内容到这里就结束了，到此为止得到的是一个不含注册的聊天室应用。</p>\n<p>从今天的开发中看到最大的问题就是规划，因为没有考虑好功能的实现，太多时间都花在了重写上。其次关于<code>JavaScript</code>基础不足的问题已经没什么好说的了。</p>\n<p>给明天定个目标：首先完成注册功能，然后把验证码功能个实装，之后尝试实现添加好友（数据库，后端逻辑）。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<p>BullShit聊天室开发的第二天</p>\n<p>昨天已经完成了聊天室的基本雏形，包括（显示消息，发送消息）两个主要功能。</p>\n<p>今天在之前的基础上增加了（用户登录功能），同时优化了昨天遗留的（消息显示问题），优化了用户输入框的部分内容并添加了一些前端效果。</p>\n<p>本文对于部分重复的内容不再做赘述。</p>\n<p>添加用户登录功能</p>\n<ul>\n<li>数据表构建</li>\n<li>实体类创建</li>\n<li>前端的编写</li>\n</ul>\n<p>此处存疑：在编写 登录&#x2F;注册 的前端页面时，<code>Jquery</code>的<code>show()</code>方法无法触发，而另一个类似的按钮可以正常触发，后来删除了<code>Div</code>中的<code>&lt;form&gt;</code>标签后问题解决了，但事实上在测试用的<code>Demo</code>中并没有发现这个问题。</p>\n<h2 id=\"1-消息显示问题\"><a href=\"#1-消息显示问题\" class=\"headerlink\" title=\"1. 消息显示问题\"></a>1. 消息显示问题</h2><p>在考虑了昨天的遗留之后做了一些思考：<code>JavaScript</code>的计时器会一直执行，为了能更快的获得新的消息，计时器的间隔会很短，而这就一定会造成计时器内的滚动条定位被一直触发，最后使得聊天窗口的滚动条完全没法使用；</p>\n<p>之所以需要计时器，是为了能不断的获得数据库中的数据，而这一点却存在着一些问题：按照之前的算法，程序在不断的读取数据，然后写在页面上，事实上我们是否需要一直写呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">callBack</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ajaxReq.<span class=\"property\">readyState</span> === <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(text !== ajaxReq.<span class=\"property\">responseText</span>)&#123;</span><br><span class=\"line\">\t\t\ttext = ajaxReq.<span class=\"property\">responseText</span>;</span><br><span class=\"line\">\t\t\t$(<span class=\"string\">&quot;#News_Table&quot;</span>).<span class=\"title function_\">html</span>(text);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//默认滚动条最底部</span></span><br><span class=\"line\">\t\t\t$(<span class=\"string\">&quot;body,html&quot;</span>).<span class=\"title function_\">scrollTop</span>($(<span class=\"string\">&quot;table&quot;</span>).<span class=\"title function_\">height</span>());</span><br><span class=\"line\">\t\t&#125;\t\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上修改了<code>ajax</code>的回调函数之后，每一次程序获得<code>Servlet</code>的反馈后，都会判断本次获取的内容是否发生了改变，如果发生了改变则重新写入新的<code>Html</code>代码，同时修改滚动条的位置，解决了昨天的遗留问题。</p>\n<h2 id=\"2-用户输入框的优化\"><a href=\"#2-用户输入框的优化\" class=\"headerlink\" title=\"2. 用户输入框的优化\"></a>2. 用户输入框的优化</h2><p>在之前的内容中，用户输入框使用的是<code>&lt;input type=&quot;text&quot;/&gt;</code>，使用该标签存在一个问题是，<code>input-text</code>并不具有换行的功能，也就是说如果输入的文本足够长，该文本框是一直不断的横向滚动而不是自动换行。</p>\n<p>不用多说自然是换成了文本域<code>&lt;textarea&gt;&lt;/textarea&gt;</code>标签。</p>\n<h2 id=\"3-前端效果的加入\"><a href=\"#3-前端效果的加入\" class=\"headerlink\" title=\"3. 前端效果的加入\"></a>3. 前端效果的加入</h2><p>这里尝试做一个仿英雄联盟的效果用于加好友。</p>\n<p><img src=\"/./images/lian-shou-xiang-mu-bullshit-liao-tian-shi-di-er-tian/1.webp\" alt=\"添加好友.gif\"></p>\n<p>值得一提的是，因为类名一样，行为一样，结构一样，这里又遇到了之前<a href=\"https://www.jianshu.com/p/df57faa24e47\">白块儿</a>里对于事件解绑的问题，不过这次很快就解决了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">&quot;#agree,#refused&quot;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> height = $(<span class=\"string\">&quot;.friend&quot;</span>).<span class=\"title function_\">height</span>();</span><br><span class=\"line\">    $(<span class=\"string\">&quot;.friend&quot;</span>).<span class=\"title function_\">animate</span>(&#123; <span class=\"attr\">height</span>: height + <span class=\"number\">100</span> + <span class=\"string\">&quot;px&quot;</span> &#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">    $(<span class=\"string\">&quot;#agree,#refused&quot;</span>).<span class=\"title function_\">off</span>(<span class=\"string\">&#x27;click&#x27;</span>).<span class=\"title function_\">click</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">\t\t$(<span class=\"variable language_\">this</span>).<span class=\"title function_\">parent</span>().<span class=\"title function_\">hide</span>(<span class=\"number\">300</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当然这里的写法并没有对应功能，后端的开发还未完成，因此这里只是做了行为处理和测试。</p>\n<h2 id=\"4-一个非常严重的错误，登录重写\"><a href=\"#4-一个非常严重的错误，登录重写\" class=\"headerlink\" title=\"4. 一个非常严重的错误，登录重写\"></a>4. 一个非常严重的错误，登录重写</h2><p>晚一点的时候发现自己写了一个非常傻*的东西，在判定完登录之后跳转页面直接用<code>URL</code>传参了用户的账号，然后在数据库里查询账号的记录并显示了其它的内容。</p>\n<p>弊端我就不说了，<code>URL</code>里想上哪个账户就上哪个账户，完全不需要密码……</p>\n<p>最后自然是重新处理了代码，验证之后把账号密码存进了<code>Session</code>中，然后在页面开头从<code>Session</code>里取出内容进行验证防止其它更重不允许的跳转。</p>\n<h2 id=\"5-最后\"><a href=\"#5-最后\" class=\"headerlink\" title=\"5. 最后\"></a>5. 最后</h2><p>第二天的内容到这里就结束了，到此为止得到的是一个不含注册的聊天室应用。</p>\n<p>从今天的开发中看到最大的问题就是规划，因为没有考虑好功能的实现，太多时间都花在了重写上。其次关于<code>JavaScript</code>基础不足的问题已经没什么好说的了。</p>\n<p>给明天定个目标：首先完成注册功能，然后把验证码功能个实装，之后尝试实现添加好友（数据库，后端逻辑）。</p>\n"},{"title":"记一次百度云BOS踩坑","date":"2020-07-12T05:56:18.000Z","_content":"**问题描述**\n\n使用百度提供的STS获取bos临时授权时出现下面的错误：\n\n~~~ shell\nFailed to open TCP connection to sts.bj.baidubce.com:80 (getaddrinfo: Temporary failure in name resolution)\n~~~\n\n使用 `ping sts.bj.baidubce.com` ：\n\n~~~ cmd\nping: sts.bj.baidubce.com: Temporary failure in name resolution\n~~~\n\n**解决方案**\n\n在 `/etc/resolv.conf` 中添加对应内容\n \n~~~ shell\nvim /etc/resolv.conf\nnameserver 111.206.37.122\n~~~\n\n再次尝试 `ping sts.bj.baidubce.com`\n\n~~~ shell\nPING sts.bj.baidubce.n.shifen.com (111.206.37.122) 56(84) bytes of data.\n~~~","source":"_posts/记一次百度云BOS踩坑.md","raw":"---\ntitle: 记一次百度云BOS踩坑\ndate: 2020-07-12 13:56:18\ntags:\n  - 运维\ncategories:\n  - 好饿，早知道不学编程了\n---\n**问题描述**\n\n使用百度提供的STS获取bos临时授权时出现下面的错误：\n\n~~~ shell\nFailed to open TCP connection to sts.bj.baidubce.com:80 (getaddrinfo: Temporary failure in name resolution)\n~~~\n\n使用 `ping sts.bj.baidubce.com` ：\n\n~~~ cmd\nping: sts.bj.baidubce.com: Temporary failure in name resolution\n~~~\n\n**解决方案**\n\n在 `/etc/resolv.conf` 中添加对应内容\n \n~~~ shell\nvim /etc/resolv.conf\nnameserver 111.206.37.122\n~~~\n\n再次尝试 `ping sts.bj.baidubce.com`\n\n~~~ shell\nPING sts.bj.baidubce.n.shifen.com (111.206.37.122) 56(84) bytes of data.\n~~~","slug":"记一次百度云BOS踩坑","published":1,"updated":"2022-05-03T09:46:00.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdus0033r2vegi1w020r","content":"<p><strong>问题描述</strong></p>\n<p>使用百度提供的STS获取bos临时授权时出现下面的错误：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failed to open TCP connection to sts.bj.baidubce.com:80 (getaddrinfo: Temporary failure in name resolution)</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>ping sts.bj.baidubce.com</code> ：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ping: <span class=\"title\">sts.bj.baidubce.com</span>: <span class=\"title\">Temporary</span> <span class=\"title\">failure</span> <span class=\"title\">in</span> <span class=\"title\">name</span> <span class=\"title\">resolution</span></span></span><br></pre></td></tr></table></figure>\n\n<p><strong>解决方案</strong></p>\n<p>在 <code>/etc/resolv.conf</code> 中添加对应内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/resolv.conf</span><br><span class=\"line\">nameserver 111.206.37.122</span><br></pre></td></tr></table></figure>\n\n<p>再次尝试 <code>ping sts.bj.baidubce.com</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PING sts.bj.baidubce.n.shifen.com (111.206.37.122) 56(84) bytes of data.</span><br></pre></td></tr></table></figure>","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<p><strong>问题描述</strong></p>\n<p>使用百度提供的STS获取bos临时授权时出现下面的错误：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Failed to open TCP connection to sts.bj.baidubce.com:80 (getaddrinfo: Temporary failure in name resolution)</span><br></pre></td></tr></table></figure>\n\n<p>使用 <code>ping sts.bj.baidubce.com</code> ：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ping: <span class=\"title\">sts.bj.baidubce.com</span>: <span class=\"title\">Temporary</span> <span class=\"title\">failure</span> <span class=\"title\">in</span> <span class=\"title\">name</span> <span class=\"title\">resolution</span></span></span><br></pre></td></tr></table></figure>\n\n<p><strong>解决方案</strong></p>\n<p>在 <code>/etc/resolv.conf</code> 中添加对应内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/resolv.conf</span><br><span class=\"line\">nameserver 111.206.37.122</span><br></pre></td></tr></table></figure>\n\n<p>再次尝试 <code>ping sts.bj.baidubce.com</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PING sts.bj.baidubce.n.shifen.com (111.206.37.122) 56(84) bytes of data.</span><br></pre></td></tr></table></figure>"},{"_content":"# 这可能是最全最细节的rails环境搭建向导了(基于rvm)\n\n## 0. 写在前面\n\n安装`ruby`其实是个很容易的活儿（大概），但是我总是在不同的环境里遇到不同的问题，每次我解决之后就会习惯性的将它记录到笔记软件里，随后又继续投入到工作之中。一直到某一天我看到我的笔记软件里居然有那么多不同的安装`ruby`时遇到的坑，我想，是时候汇总一下了。\n\n## 1. 下载`rvm`\n\n本文统一使用`rvm`进行`ruby`的版本管理。\n\n### 1.1 建议\n\n首先写在最前面的是：**不推荐将`rvm`安装在root用户下**。\n\n>  本篇教程 **在未遇到不可抗力** 的情况下不需要使用`sudo`。然而显然这种概率极小……\n\n### 1.2 如何正确的卸载`rvm`\n\n对于一部分把`rvm`装在了`root`用户下且希望卸载并按照本教程继续，或者本来就是来看如何卸载的小伙伴，可以使用如下命令然后 **重启** 。\n\n~~~ shell\nrvm implode\n\n# 重启\nreboot\n~~~\n\n至于为什么要重启，感兴趣的小伙伴可以自己对比重启前和重启后的`env`（使用如下命令即可）\n\n~~~ shell\nenv | grep rvm\n~~~\n\n### 1.3 下载`rvm`\n\n下载`rvm`可以参考文档，如果你实在懒得打开文档，直接用如下命令就可以了，至于`rvm`的文档，百度第一个就是。\n\n~~~ shell\ngpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\n\n\\curl -sSL https://get.rvm.io | bash -s stable\n\necho \"source $HOME/.rvm/scripts/rvm\" >> ~/.bash_profile\n\n# 此时你应该打开一个新的终端或者直接使用如下命令\n/bin/bash --login\n\n# 输出版本号则意味着已经完成安装\nrvm -v\n~~~\n\n通常如果你在一个新的`Linux`系统上安装`rvm`，那你大概率会遇到如下提示：\n\n~~~ shell\nThe program 'gpg2' is currently not installed. You can install it by typing:\n~~~\n\n其实无论怎么看你都应该知道解决方法，不过善良的我还是贴心的写出了解决方法：\n\n~~~ shell\nsudo apt-get install gnupg2\n~~~\n\n顺便再婆婆妈妈一句，另一个与之类似的错误可能是这个：\n\n~~~ bash\nsudo apt-get install dirmngr\n~~~\n\n当执行第二步时提示：\n\n~~~ shell\ncurl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused\n~~~\n\n你需要将`199.232.28.133 raw.githubusercontent.com`添加到hosts中，具体操作是这样的：\n\n~~~ shell\nsudo vim /etc/hosts\n~~~\n\n如何使用`vim`编辑，保存，不是本篇要讲的。\n\n## 2. 下载`ruby`\n到这里其实就很简单了，直接使用如下命令即可安装你希望的`ruby`版本：\n~~~ shell\nrvm install 2.5.7\n~~~\n你可以同时安装多个版本的`ruby`，然后只需要：\n~~~ shell\nrvm use 2.5.7\n~~~\n即可快速切换。\n\n## 3. 安装`rails`\n\n### 3.1 如何正确的卸载`rails`\n还是说一下，我曾经在开发环境安装了个多个版本的`rails`（生命不息折腾不止），但在使用如下命令进行卸载后发现依然可以使用脚手架等工具，且出现了版本乱七八糟的问题：\n~~~ shell\ngem uninstall rails\n~~~\n对于多版本，上述代码在执行时会询问要卸载的版本，所以不用太担心。但除此之外你可能还要使用如下代码卸载`railties`：\n~~~ shell\ngem uninstall railties\n~~~\n\n### 3.2 配置镜像并安装\n多嘴一句，有的小伙伴如果用的国外的服务器，其实就不需要配置镜像了，配置了反而会更慢的……\n\n使用如下命令配置镜像：\n~~~ shell\ngem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/\nbundle config mirror.https://rubygems.org https://gems.ruby-china.com\n~~~\n\n然后直接安装即可\n~~~ shell\ngem install rails -v 5.2.4\n~~~\n这里使用了`-v`参数指定了版本为`5.2.4`，有些小伙伴可能并不关注前端部分，因此是否需要使用`rails 6.0`其实有待商榷，为避免默认安装`rails 6.0`导致以后使用脚手架直接整上`webpacker`，这里还是建议指定一下版本。\n\n最后，enjoy it!\n","source":"_posts/这可能是最全最细节的rails环境搭建向导了(基于rvm).md","raw":"# 这可能是最全最细节的rails环境搭建向导了(基于rvm)\n\n## 0. 写在前面\n\n安装`ruby`其实是个很容易的活儿（大概），但是我总是在不同的环境里遇到不同的问题，每次我解决之后就会习惯性的将它记录到笔记软件里，随后又继续投入到工作之中。一直到某一天我看到我的笔记软件里居然有那么多不同的安装`ruby`时遇到的坑，我想，是时候汇总一下了。\n\n## 1. 下载`rvm`\n\n本文统一使用`rvm`进行`ruby`的版本管理。\n\n### 1.1 建议\n\n首先写在最前面的是：**不推荐将`rvm`安装在root用户下**。\n\n>  本篇教程 **在未遇到不可抗力** 的情况下不需要使用`sudo`。然而显然这种概率极小……\n\n### 1.2 如何正确的卸载`rvm`\n\n对于一部分把`rvm`装在了`root`用户下且希望卸载并按照本教程继续，或者本来就是来看如何卸载的小伙伴，可以使用如下命令然后 **重启** 。\n\n~~~ shell\nrvm implode\n\n# 重启\nreboot\n~~~\n\n至于为什么要重启，感兴趣的小伙伴可以自己对比重启前和重启后的`env`（使用如下命令即可）\n\n~~~ shell\nenv | grep rvm\n~~~\n\n### 1.3 下载`rvm`\n\n下载`rvm`可以参考文档，如果你实在懒得打开文档，直接用如下命令就可以了，至于`rvm`的文档，百度第一个就是。\n\n~~~ shell\ngpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB\n\n\\curl -sSL https://get.rvm.io | bash -s stable\n\necho \"source $HOME/.rvm/scripts/rvm\" >> ~/.bash_profile\n\n# 此时你应该打开一个新的终端或者直接使用如下命令\n/bin/bash --login\n\n# 输出版本号则意味着已经完成安装\nrvm -v\n~~~\n\n通常如果你在一个新的`Linux`系统上安装`rvm`，那你大概率会遇到如下提示：\n\n~~~ shell\nThe program 'gpg2' is currently not installed. You can install it by typing:\n~~~\n\n其实无论怎么看你都应该知道解决方法，不过善良的我还是贴心的写出了解决方法：\n\n~~~ shell\nsudo apt-get install gnupg2\n~~~\n\n顺便再婆婆妈妈一句，另一个与之类似的错误可能是这个：\n\n~~~ bash\nsudo apt-get install dirmngr\n~~~\n\n当执行第二步时提示：\n\n~~~ shell\ncurl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused\n~~~\n\n你需要将`199.232.28.133 raw.githubusercontent.com`添加到hosts中，具体操作是这样的：\n\n~~~ shell\nsudo vim /etc/hosts\n~~~\n\n如何使用`vim`编辑，保存，不是本篇要讲的。\n\n## 2. 下载`ruby`\n到这里其实就很简单了，直接使用如下命令即可安装你希望的`ruby`版本：\n~~~ shell\nrvm install 2.5.7\n~~~\n你可以同时安装多个版本的`ruby`，然后只需要：\n~~~ shell\nrvm use 2.5.7\n~~~\n即可快速切换。\n\n## 3. 安装`rails`\n\n### 3.1 如何正确的卸载`rails`\n还是说一下，我曾经在开发环境安装了个多个版本的`rails`（生命不息折腾不止），但在使用如下命令进行卸载后发现依然可以使用脚手架等工具，且出现了版本乱七八糟的问题：\n~~~ shell\ngem uninstall rails\n~~~\n对于多版本，上述代码在执行时会询问要卸载的版本，所以不用太担心。但除此之外你可能还要使用如下代码卸载`railties`：\n~~~ shell\ngem uninstall railties\n~~~\n\n### 3.2 配置镜像并安装\n多嘴一句，有的小伙伴如果用的国外的服务器，其实就不需要配置镜像了，配置了反而会更慢的……\n\n使用如下命令配置镜像：\n~~~ shell\ngem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/\nbundle config mirror.https://rubygems.org https://gems.ruby-china.com\n~~~\n\n然后直接安装即可\n~~~ shell\ngem install rails -v 5.2.4\n~~~\n这里使用了`-v`参数指定了版本为`5.2.4`，有些小伙伴可能并不关注前端部分，因此是否需要使用`rails 6.0`其实有待商榷，为避免默认安装`rails 6.0`导致以后使用脚手架直接整上`webpacker`，这里还是建议指定一下版本。\n\n最后，enjoy it!\n","slug":"这可能是最全最细节的rails环境搭建向导了(基于rvm)","published":1,"date":"2022-05-03T08:46:25.152Z","updated":"2022-05-03T08:46:25.152Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mdut0036r2ve9oak7b8l","content":"<h1 id=\"这可能是最全最细节的rails环境搭建向导了-基于rvm\"><a href=\"#这可能是最全最细节的rails环境搭建向导了-基于rvm\" class=\"headerlink\" title=\"这可能是最全最细节的rails环境搭建向导了(基于rvm)\"></a>这可能是最全最细节的rails环境搭建向导了(基于rvm)</h1><h2 id=\"0-写在前面\"><a href=\"#0-写在前面\" class=\"headerlink\" title=\"0. 写在前面\"></a>0. 写在前面</h2><p>安装<code>ruby</code>其实是个很容易的活儿（大概），但是我总是在不同的环境里遇到不同的问题，每次我解决之后就会习惯性的将它记录到笔记软件里，随后又继续投入到工作之中。一直到某一天我看到我的笔记软件里居然有那么多不同的安装<code>ruby</code>时遇到的坑，我想，是时候汇总一下了。</p>\n<h2 id=\"1-下载rvm\"><a href=\"#1-下载rvm\" class=\"headerlink\" title=\"1. 下载rvm\"></a>1. 下载<code>rvm</code></h2><p>本文统一使用<code>rvm</code>进行<code>ruby</code>的版本管理。</p>\n<h3 id=\"1-1-建议\"><a href=\"#1-1-建议\" class=\"headerlink\" title=\"1.1 建议\"></a>1.1 建议</h3><p>首先写在最前面的是：<strong>不推荐将<code>rvm</code>安装在root用户下</strong>。</p>\n<blockquote>\n<p> 本篇教程 <strong>在未遇到不可抗力</strong> 的情况下不需要使用<code>sudo</code>。然而显然这种概率极小……</p>\n</blockquote>\n<h3 id=\"1-2-如何正确的卸载rvm\"><a href=\"#1-2-如何正确的卸载rvm\" class=\"headerlink\" title=\"1.2 如何正确的卸载rvm\"></a>1.2 如何正确的卸载<code>rvm</code></h3><p>对于一部分把<code>rvm</code>装在了<code>root</code>用户下且希望卸载并按照本教程继续，或者本来就是来看如何卸载的小伙伴，可以使用如下命令然后 <strong>重启</strong> 。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm implode</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重启</span></span><br><span class=\"line\">reboot</span><br></pre></td></tr></table></figure>\n\n<p>至于为什么要重启，感兴趣的小伙伴可以自己对比重启前和重启后的<code>env</code>（使用如下命令即可）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env | grep rvm</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-下载rvm\"><a href=\"#1-3-下载rvm\" class=\"headerlink\" title=\"1.3 下载rvm\"></a>1.3 下载<code>rvm</code></h3><p>下载<code>rvm</code>可以参考文档，如果你实在懒得打开文档，直接用如下命令就可以了，至于<code>rvm</code>的文档，百度第一个就是。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class=\"line\"></span><br><span class=\"line\">\\curl -sSL https://get.rvm.io | bash -s stable</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;source $HOME/.rvm/scripts/rvm&quot; &gt;&gt; ~/.bash_profile</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">此时你应该打开一个新的终端或者直接使用如下命令</span></span><br><span class=\"line\">/bin/bash --login</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">输出版本号则意味着已经完成安装</span></span><br><span class=\"line\">rvm -v</span><br></pre></td></tr></table></figure>\n\n<p>通常如果你在一个新的<code>Linux</code>系统上安装<code>rvm</code>，那你大概率会遇到如下提示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The program &#x27;gpg2&#x27; is currently not installed. You can install it by typing:</span><br></pre></td></tr></table></figure>\n\n<p>其实无论怎么看你都应该知道解决方法，不过善良的我还是贴心的写出了解决方法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gnupg2</span><br></pre></td></tr></table></figure>\n\n<p>顺便再婆婆妈妈一句，另一个与之类似的错误可能是这个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install dirmngr</span><br></pre></td></tr></table></figure>\n\n<p>当执行第二步时提示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</span><br></pre></td></tr></table></figure>\n\n<p>你需要将<code>199.232.28.133 raw.githubusercontent.com</code>添加到hosts中，具体操作是这样的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure>\n\n<p>如何使用<code>vim</code>编辑，保存，不是本篇要讲的。</p>\n<h2 id=\"2-下载ruby\"><a href=\"#2-下载ruby\" class=\"headerlink\" title=\"2. 下载ruby\"></a>2. 下载<code>ruby</code></h2><p>到这里其实就很简单了，直接使用如下命令即可安装你希望的<code>ruby</code>版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.5.7</span><br></pre></td></tr></table></figure>\n<p>你可以同时安装多个版本的<code>ruby</code>，然后只需要：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm use 2.5.7</span><br></pre></td></tr></table></figure>\n<p>即可快速切换。</p>\n<h2 id=\"3-安装rails\"><a href=\"#3-安装rails\" class=\"headerlink\" title=\"3. 安装rails\"></a>3. 安装<code>rails</code></h2><h3 id=\"3-1-如何正确的卸载rails\"><a href=\"#3-1-如何正确的卸载rails\" class=\"headerlink\" title=\"3.1 如何正确的卸载rails\"></a>3.1 如何正确的卸载<code>rails</code></h3><p>还是说一下，我曾经在开发环境安装了个多个版本的<code>rails</code>（生命不息折腾不止），但在使用如下命令进行卸载后发现依然可以使用脚手架等工具，且出现了版本乱七八糟的问题：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem uninstall rails</span><br></pre></td></tr></table></figure>\n<p>对于多版本，上述代码在执行时会询问要卸载的版本，所以不用太担心。但除此之外你可能还要使用如下代码卸载<code>railties</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem uninstall railties</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-配置镜像并安装\"><a href=\"#3-2-配置镜像并安装\" class=\"headerlink\" title=\"3.2 配置镜像并安装\"></a>3.2 配置镜像并安装</h3><p>多嘴一句，有的小伙伴如果用的国外的服务器，其实就不需要配置镜像了，配置了反而会更慢的……</p>\n<p>使用如下命令配置镜像：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class=\"line\">bundle config mirror.https://rubygems.org https://gems.ruby-china.com</span><br></pre></td></tr></table></figure>\n\n<p>然后直接安装即可</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install rails -v 5.2.4</span><br></pre></td></tr></table></figure>\n<p>这里使用了<code>-v</code>参数指定了版本为<code>5.2.4</code>，有些小伙伴可能并不关注前端部分，因此是否需要使用<code>rails 6.0</code>其实有待商榷，为避免默认安装<code>rails 6.0</code>导致以后使用脚手架直接整上<code>webpacker</code>，这里还是建议指定一下版本。</p>\n<p>最后，enjoy it!</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<h1 id=\"这可能是最全最细节的rails环境搭建向导了-基于rvm\"><a href=\"#这可能是最全最细节的rails环境搭建向导了-基于rvm\" class=\"headerlink\" title=\"这可能是最全最细节的rails环境搭建向导了(基于rvm)\"></a>这可能是最全最细节的rails环境搭建向导了(基于rvm)</h1><h2 id=\"0-写在前面\"><a href=\"#0-写在前面\" class=\"headerlink\" title=\"0. 写在前面\"></a>0. 写在前面</h2><p>安装<code>ruby</code>其实是个很容易的活儿（大概），但是我总是在不同的环境里遇到不同的问题，每次我解决之后就会习惯性的将它记录到笔记软件里，随后又继续投入到工作之中。一直到某一天我看到我的笔记软件里居然有那么多不同的安装<code>ruby</code>时遇到的坑，我想，是时候汇总一下了。</p>\n<h2 id=\"1-下载rvm\"><a href=\"#1-下载rvm\" class=\"headerlink\" title=\"1. 下载rvm\"></a>1. 下载<code>rvm</code></h2><p>本文统一使用<code>rvm</code>进行<code>ruby</code>的版本管理。</p>\n<h3 id=\"1-1-建议\"><a href=\"#1-1-建议\" class=\"headerlink\" title=\"1.1 建议\"></a>1.1 建议</h3><p>首先写在最前面的是：<strong>不推荐将<code>rvm</code>安装在root用户下</strong>。</p>\n<blockquote>\n<p> 本篇教程 <strong>在未遇到不可抗力</strong> 的情况下不需要使用<code>sudo</code>。然而显然这种概率极小……</p>\n</blockquote>\n<h3 id=\"1-2-如何正确的卸载rvm\"><a href=\"#1-2-如何正确的卸载rvm\" class=\"headerlink\" title=\"1.2 如何正确的卸载rvm\"></a>1.2 如何正确的卸载<code>rvm</code></h3><p>对于一部分把<code>rvm</code>装在了<code>root</code>用户下且希望卸载并按照本教程继续，或者本来就是来看如何卸载的小伙伴，可以使用如下命令然后 <strong>重启</strong> 。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm implode</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重启</span></span><br><span class=\"line\">reboot</span><br></pre></td></tr></table></figure>\n\n<p>至于为什么要重启，感兴趣的小伙伴可以自己对比重启前和重启后的<code>env</code>（使用如下命令即可）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">env | grep rvm</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-下载rvm\"><a href=\"#1-3-下载rvm\" class=\"headerlink\" title=\"1.3 下载rvm\"></a>1.3 下载<code>rvm</code></h3><p>下载<code>rvm</code>可以参考文档，如果你实在懒得打开文档，直接用如下命令就可以了，至于<code>rvm</code>的文档，百度第一个就是。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class=\"line\"></span><br><span class=\"line\">\\curl -sSL https://get.rvm.io | bash -s stable</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;source $HOME/.rvm/scripts/rvm&quot; &gt;&gt; ~/.bash_profile</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">此时你应该打开一个新的终端或者直接使用如下命令</span></span><br><span class=\"line\">/bin/bash --login</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">输出版本号则意味着已经完成安装</span></span><br><span class=\"line\">rvm -v</span><br></pre></td></tr></table></figure>\n\n<p>通常如果你在一个新的<code>Linux</code>系统上安装<code>rvm</code>，那你大概率会遇到如下提示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The program &#x27;gpg2&#x27; is currently not installed. You can install it by typing:</span><br></pre></td></tr></table></figure>\n\n<p>其实无论怎么看你都应该知道解决方法，不过善良的我还是贴心的写出了解决方法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gnupg2</span><br></pre></td></tr></table></figure>\n\n<p>顺便再婆婆妈妈一句，另一个与之类似的错误可能是这个：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install dirmngr</span><br></pre></td></tr></table></figure>\n\n<p>当执行第二步时提示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</span><br></pre></td></tr></table></figure>\n\n<p>你需要将<code>199.232.28.133 raw.githubusercontent.com</code>添加到hosts中，具体操作是这样的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure>\n\n<p>如何使用<code>vim</code>编辑，保存，不是本篇要讲的。</p>\n<h2 id=\"2-下载ruby\"><a href=\"#2-下载ruby\" class=\"headerlink\" title=\"2. 下载ruby\"></a>2. 下载<code>ruby</code></h2><p>到这里其实就很简单了，直接使用如下命令即可安装你希望的<code>ruby</code>版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.5.7</span><br></pre></td></tr></table></figure>\n<p>你可以同时安装多个版本的<code>ruby</code>，然后只需要：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm use 2.5.7</span><br></pre></td></tr></table></figure>\n<p>即可快速切换。</p>\n<h2 id=\"3-安装rails\"><a href=\"#3-安装rails\" class=\"headerlink\" title=\"3. 安装rails\"></a>3. 安装<code>rails</code></h2><h3 id=\"3-1-如何正确的卸载rails\"><a href=\"#3-1-如何正确的卸载rails\" class=\"headerlink\" title=\"3.1 如何正确的卸载rails\"></a>3.1 如何正确的卸载<code>rails</code></h3><p>还是说一下，我曾经在开发环境安装了个多个版本的<code>rails</code>（生命不息折腾不止），但在使用如下命令进行卸载后发现依然可以使用脚手架等工具，且出现了版本乱七八糟的问题：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem uninstall rails</span><br></pre></td></tr></table></figure>\n<p>对于多版本，上述代码在执行时会询问要卸载的版本，所以不用太担心。但除此之外你可能还要使用如下代码卸载<code>railties</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem uninstall railties</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-配置镜像并安装\"><a href=\"#3-2-配置镜像并安装\" class=\"headerlink\" title=\"3.2 配置镜像并安装\"></a>3.2 配置镜像并安装</h3><p>多嘴一句，有的小伙伴如果用的国外的服务器，其实就不需要配置镜像了，配置了反而会更慢的……</p>\n<p>使用如下命令配置镜像：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class=\"line\">bundle config mirror.https://rubygems.org https://gems.ruby-china.com</span><br></pre></td></tr></table></figure>\n\n<p>然后直接安装即可</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install rails -v 5.2.4</span><br></pre></td></tr></table></figure>\n<p>这里使用了<code>-v</code>参数指定了版本为<code>5.2.4</code>，有些小伙伴可能并不关注前端部分，因此是否需要使用<code>rails 6.0</code>其实有待商榷，为避免默认安装<code>rails 6.0</code>导致以后使用脚手架直接整上<code>webpacker</code>，这里还是建议指定一下版本。</p>\n<p>最后，enjoy it!</p>\n"},{"title":"一个可以随机获取高质量图片的地址","date":"2018-09-14T14:05:43.000Z","_content":"其实前端随机我是想过一些这方面的事情的，起初是看到了Chrome浏览器中的一款叫Momentum的插件。\n\n每次启动页面时背景图片都不是一样的，并且其图片质量都是非常高的，曾经想过用一些“拙劣”的方法去实现，最后都以不靠谱结束= =！\n\n偶然间看到了一篇文章，得到了一个网址\n~~~\nhttps://source.unsplash.com/\n~~~\n\n在网址后以URL传参的方式添加图片分辨率和关键字，即可获取到随机的高质量图片。\n~~~\nbody {\n    background: url(\"https://source.unsplash.com/1366x768/\");\n}\n~~~\n\n并且每一次刷新都可以获取新的图片\n\n但并不建议在网站中大量使用这种方式获取的图片，因为其加载过程比较慢，另外并不是很清楚这些资源是否可以商用。\n\n如果需要获取图片，则可以在浏览器地址栏中直接输入url获取图片，然后右键另存为保存到本地，图片的质量还是有蛮高的。\n","source":"_posts/随机获取到的高质量图片.md","raw":"---\ntitle: 一个可以随机获取高质量图片的地址\ndate:  2018.09.14 22:05:43\ntags:\n  - Java\ncategories:\n  - 好饿，早知道不学编程了\n---\n其实前端随机我是想过一些这方面的事情的，起初是看到了Chrome浏览器中的一款叫Momentum的插件。\n\n每次启动页面时背景图片都不是一样的，并且其图片质量都是非常高的，曾经想过用一些“拙劣”的方法去实现，最后都以不靠谱结束= =！\n\n偶然间看到了一篇文章，得到了一个网址\n~~~\nhttps://source.unsplash.com/\n~~~\n\n在网址后以URL传参的方式添加图片分辨率和关键字，即可获取到随机的高质量图片。\n~~~\nbody {\n    background: url(\"https://source.unsplash.com/1366x768/\");\n}\n~~~\n\n并且每一次刷新都可以获取新的图片\n\n但并不建议在网站中大量使用这种方式获取的图片，因为其加载过程比较慢，另外并不是很清楚这些资源是否可以商用。\n\n如果需要获取图片，则可以在浏览器地址栏中直接输入url获取图片，然后右键另存为保存到本地，图片的质量还是有蛮高的。\n","slug":"随机获取到的高质量图片","published":1,"updated":"2022-05-03T09:56:01.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mduw003lr2vehxv036dt","content":"<p>其实前端随机我是想过一些这方面的事情的，起初是看到了Chrome浏览器中的一款叫Momentum的插件。</p>\n<p>每次启动页面时背景图片都不是一样的，并且其图片质量都是非常高的，曾经想过用一些“拙劣”的方法去实现，最后都以不靠谱结束&#x3D; &#x3D;！</p>\n<p>偶然间看到了一篇文章，得到了一个网址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://source.unsplash.com/</span><br></pre></td></tr></table></figure>\n\n<p>在网址后以URL传参的方式添加图片分辨率和关键字，即可获取到随机的高质量图片。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body &#123;</span><br><span class=\"line\">    background: url(&quot;https://source.unsplash.com/1366x768/&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且每一次刷新都可以获取新的图片</p>\n<p>但并不建议在网站中大量使用这种方式获取的图片，因为其加载过程比较慢，另外并不是很清楚这些资源是否可以商用。</p>\n<p>如果需要获取图片，则可以在浏览器地址栏中直接输入url获取图片，然后右键另存为保存到本地，图片的质量还是有蛮高的。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<p>其实前端随机我是想过一些这方面的事情的，起初是看到了Chrome浏览器中的一款叫Momentum的插件。</p>\n<p>每次启动页面时背景图片都不是一样的，并且其图片质量都是非常高的，曾经想过用一些“拙劣”的方法去实现，最后都以不靠谱结束&#x3D; &#x3D;！</p>\n<p>偶然间看到了一篇文章，得到了一个网址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://source.unsplash.com/</span><br></pre></td></tr></table></figure>\n\n<p>在网址后以URL传参的方式添加图片分辨率和关键字，即可获取到随机的高质量图片。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body &#123;</span><br><span class=\"line\">    background: url(&quot;https://source.unsplash.com/1366x768/&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且每一次刷新都可以获取新的图片</p>\n<p>但并不建议在网站中大量使用这种方式获取的图片，因为其加载过程比较慢，另外并不是很清楚这些资源是否可以商用。</p>\n<p>如果需要获取图片，则可以在浏览器地址栏中直接输入url获取图片，然后右键另存为保存到本地，图片的质量还是有蛮高的。</p>\n"},{"title":"项目从Linux迁移到Windows后找不到Python的问题","date":"2019-04-19T14:28:26.000Z","_content":"~~~shell\nnpm install --global --production windows-build-tools\n~~~\n\n并不是安装`Python`……\n是`Linux`环境下本身就有`Python`，换到`Windows`才会产生的问题。\n","source":"_posts/项目从Linux迁移到Windows后找不到Python的问题.md","raw":"---\ntitle: 项目从Linux迁移到Windows后找不到Python的问题\ndate:  2019.04.19 22:28:26\ntags:\n  - 运维\ncategories:\n  - 好饿，早知道不学编程了\n---\n~~~shell\nnpm install --global --production windows-build-tools\n~~~\n\n并不是安装`Python`……\n是`Linux`环境下本身就有`Python`，换到`Windows`才会产生的问题。\n","slug":"项目从Linux迁移到Windows后找不到Python的问题","published":1,"updated":"2022-05-03T10:00:28.192Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2q2mduw003mr2vea3za04ty","content":"<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --global --production windows-build-tools</span><br></pre></td></tr></table></figure>\n\n<p>并不是安装<code>Python</code>……<br>是<code>Linux</code>环境下本身就有<code>Python</code>，换到<code>Windows</code>才会产生的问题。</p>\n","site":{"data":{"projects":[{"name":"Hexo","url":"https://hexo.io/","desc":"A fast, simple & powerful blog framework"},{"name":"Font Awesome","url":"http://fontawesome.io/","desc":"The iconic font and CSS toolkit"}]}},"excerpt":"","more":"<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --global --production windows-build-tools</span><br></pre></td></tr></table></figure>\n\n<p>并不是安装<code>Python</code>……<br>是<code>Linux</code>环境下本身就有<code>Python</code>，换到<code>Windows</code>才会产生的问题。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl2q2mdtt0009r2vefdowg4fi","category_id":"cl2q2mdtp0004r2veba4s5che","_id":"cl2q2mdtz000ir2ve6w2kfdog"},{"post_id":"cl2q2mdti0001r2vee3bf0etz","category_id":"cl2q2mdtp0004r2veba4s5che","_id":"cl2q2mdu1000or2ve4wjea48e"},{"post_id":"cl2q2mdtu000br2vef8vkfmsc","category_id":"cl2q2mdtp0004r2veba4s5che","_id":"cl2q2mdu2000sr2vee6bb0fxn"},{"post_id":"cl2q2mdtx000fr2ve7nxm4e1t","category_id":"cl2q2mdtp0004r2veba4s5che","_id":"cl2q2mdu3000wr2vee1emeb7b"},{"post_id":"cl2q2mdto0003r2vefglfbyqq","category_id":"cl2q2mdtp0004r2veba4s5che","_id":"cl2q2mdu4000zr2veeqq32aa0"},{"post_id":"cl2q2mdtr0007r2ve5vbhfun8","category_id":"cl2q2mdtp0004r2veba4s5che","_id":"cl2q2mdu50012r2veavdyen5q"},{"post_id":"cl2q2mduf001rr2veezsg09tg","category_id":"cl2q2mduh001tr2vehjon0cx8","_id":"cl2q2mduk0024r2ve4apg3gym"},{"post_id":"cl2q2mduj0021r2ve0wabeg9y","category_id":"cl2q2mduj001zr2vec1zbd7t4","_id":"cl2q2mdul002br2vectboa5db"},{"post_id":"cl2q2mdui001vr2veccvr1mw0","category_id":"cl2q2mduj001zr2vec1zbd7t4","_id":"cl2q2mdum002fr2veb53a3vxt"},{"post_id":"cl2q2mduk0023r2veh0ez4jnb","category_id":"cl2q2mduj001zr2vec1zbd7t4","_id":"cl2q2mdun002ir2ve477ygycr"},{"post_id":"cl2q2mdul0028r2ve509x6c13","category_id":"cl2q2mduj001zr2vec1zbd7t4","_id":"cl2q2mdun002lr2vegsf11nou"},{"post_id":"cl2q2mdui001wr2vefgau1zvw","category_id":"cl2q2mduj001zr2vec1zbd7t4","_id":"cl2q2mduo002or2ve9kyd873m"},{"post_id":"cl2q2mduj001yr2ve6p45c1tz","category_id":"cl2q2mduj001zr2vec1zbd7t4","_id":"cl2q2mdup002rr2vedqzze9rx"},{"post_id":"cl2q2mdun002kr2ve70ax767m","category_id":"cl2q2mduh001tr2vehjon0cx8","_id":"cl2q2mduq002vr2ve6per1gyc"},{"post_id":"cl2q2mduo002nr2ve416gh35m","category_id":"cl2q2mduj001zr2vec1zbd7t4","_id":"cl2q2mdur002zr2vegqxs2as3"},{"post_id":"cl2q2mdur0030r2vehj397ee4","category_id":"cl2q2mduq002wr2ve6rrn3vco","_id":"cl2q2mduu0038r2ve334v3biy"},{"post_id":"cl2q2mduo002qr2ve0se46j46","category_id":"cl2q2mduq002wr2ve6rrn3vco","_id":"cl2q2mduu003ar2ve3gexgadj"},{"post_id":"cl2q2mdus0033r2vegi1w020r","category_id":"cl2q2mduq002wr2ve6rrn3vco","_id":"cl2q2mduu003cr2ve66m1grpg"},{"post_id":"cl2q2mdup002ur2ve558e9ii8","category_id":"cl2q2mduq002wr2ve6rrn3vco","_id":"cl2q2mduu003er2ve4dm31q72"},{"post_id":"cl2q2mduq002yr2ve2lhnf4k4","category_id":"cl2q2mduq002wr2ve6rrn3vco","_id":"cl2q2mduv003hr2ve5k6bdxdo"},{"post_id":"cl2q2mduw003lr2vehxv036dt","category_id":"cl2q2mduq002wr2ve6rrn3vco","_id":"cl2q2mdux003pr2ved026abd8"},{"post_id":"cl2q2mduw003mr2vea3za04ty","category_id":"cl2q2mduq002wr2ve6rrn3vco","_id":"cl2q2mdux003qr2veggf323mm"}],"PostTag":[{"post_id":"cl2q2mdtx000fr2ve7nxm4e1t","tag_id":"cl2q2mdtq0005r2veghal6b16","_id":"cl2q2mdu0000lr2ve9bgb1ng3"},{"post_id":"cl2q2mdtx000fr2ve7nxm4e1t","tag_id":"cl2q2mdtv000dr2veey2ae50q","_id":"cl2q2mdu1000pr2ved8yw5ifr"},{"post_id":"cl2q2mdti0001r2vee3bf0etz","tag_id":"cl2q2mdtq0005r2veghal6b16","_id":"cl2q2mdu2000ur2ve6fkw0nrc"},{"post_id":"cl2q2mdti0001r2vee3bf0etz","tag_id":"cl2q2mdtv000dr2veey2ae50q","_id":"cl2q2mdu3000xr2ve1b6fa6um"},{"post_id":"cl2q2mdto0003r2vefglfbyqq","tag_id":"cl2q2mdtq0005r2veghal6b16","_id":"cl2q2mdu50013r2veg83aduqe"},{"post_id":"cl2q2mdto0003r2vefglfbyqq","tag_id":"cl2q2mdtv000dr2veey2ae50q","_id":"cl2q2mdu60015r2ve5ns153tp"},{"post_id":"cl2q2mdtr0007r2ve5vbhfun8","tag_id":"cl2q2mdtq0005r2veghal6b16","_id":"cl2q2mdu8001br2vegqme20lx"},{"post_id":"cl2q2mdtr0007r2ve5vbhfun8","tag_id":"cl2q2mdtv000dr2veey2ae50q","_id":"cl2q2mdu9001dr2ve82729gtk"},{"post_id":"cl2q2mdtt0009r2vefdowg4fi","tag_id":"cl2q2mdtq0005r2veghal6b16","_id":"cl2q2mdua001gr2ve46z134gl"},{"post_id":"cl2q2mdtt0009r2vefdowg4fi","tag_id":"cl2q2mdtv000dr2veey2ae50q","_id":"cl2q2mdub001ir2veaozn3lxo"},{"post_id":"cl2q2mdtu000br2vef8vkfmsc","tag_id":"cl2q2mdtq0005r2veghal6b16","_id":"cl2q2mduc001kr2veg2xt6bi7"},{"post_id":"cl2q2mdtu000br2vef8vkfmsc","tag_id":"cl2q2mdtv000dr2veey2ae50q","_id":"cl2q2mduc001mr2ve5jb994ng"},{"post_id":"cl2q2mdui001vr2veccvr1mw0","tag_id":"cl2q2mdtv000dr2veey2ae50q","_id":"cl2q2mdui001xr2veg6msbrvf"},{"post_id":"cl2q2mduj001yr2ve6p45c1tz","tag_id":"cl2q2mdtv000dr2veey2ae50q","_id":"cl2q2mduk0022r2vedyiug53y"},{"post_id":"cl2q2mduj0021r2ve0wabeg9y","tag_id":"cl2q2mdtv000dr2veey2ae50q","_id":"cl2q2mdul0027r2ve9rp27865"},{"post_id":"cl2q2mduf001rr2veezsg09tg","tag_id":"cl2q2mduh001ur2ve9k7096pd","_id":"cl2q2mdul0029r2ve0dsa20cr"},{"post_id":"cl2q2mduf001rr2veezsg09tg","tag_id":"cl2q2mduj0020r2ved0u7f0y8","_id":"cl2q2mdum002dr2vec2as2rlz"},{"post_id":"cl2q2mduk0023r2veh0ez4jnb","tag_id":"cl2q2mdtv000dr2veey2ae50q","_id":"cl2q2mdun002gr2veh7o1fe2o"},{"post_id":"cl2q2mdul0028r2ve509x6c13","tag_id":"cl2q2mdtv000dr2veey2ae50q","_id":"cl2q2mdun002jr2vea8ok72t4"},{"post_id":"cl2q2mdui001wr2vefgau1zvw","tag_id":"cl2q2mduk0026r2ved8li5mwk","_id":"cl2q2mduo002mr2vebozz7b3e"},{"post_id":"cl2q2mdun002kr2ve70ax767m","tag_id":"cl2q2mduh001ur2ve9k7096pd","_id":"cl2q2mduo002pr2vefg7w4qu0"},{"post_id":"cl2q2mdun002kr2ve70ax767m","tag_id":"cl2q2mduj0020r2ved0u7f0y8","_id":"cl2q2mdup002tr2veg03t0hzp"},{"post_id":"cl2q2mduo002qr2ve0se46j46","tag_id":"cl2q2mduk0026r2ved8li5mwk","_id":"cl2q2mduq002xr2ve21xagkcl"},{"post_id":"cl2q2mduq002yr2ve2lhnf4k4","tag_id":"cl2q2mduk0026r2ved8li5mwk","_id":"cl2q2mdus0032r2vedez8akx4"},{"post_id":"cl2q2mdur0030r2vehj397ee4","tag_id":"cl2q2mduk0026r2ved8li5mwk","_id":"cl2q2mdut0035r2ve79ui0g4e"},{"post_id":"cl2q2mduo002nr2ve416gh35m","tag_id":"cl2q2mdup002sr2ve8qhg7972","_id":"cl2q2mduu003dr2ve2m5wepi1"},{"post_id":"cl2q2mduo002nr2ve416gh35m","tag_id":"cl2q2mdus0031r2ve1pti9aaf","_id":"cl2q2mduu003fr2ve9wcn3xau"},{"post_id":"cl2q2mduo002nr2ve416gh35m","tag_id":"cl2q2mdut0037r2ve9kur6126","_id":"cl2q2mduv003ir2ve5vt4bj6l"},{"post_id":"cl2q2mdup002ur2ve558e9ii8","tag_id":"cl2q2mduu003br2ve0j6a08pq","_id":"cl2q2mduv003jr2vedwxj5tmx"},{"post_id":"cl2q2mdus0033r2vegi1w020r","tag_id":"cl2q2mduv003gr2ve7ek1f28h","_id":"cl2q2mduv003kr2ved4mf3n63"},{"post_id":"cl2q2mduw003lr2vehxv036dt","tag_id":"cl2q2mduk0026r2ved8li5mwk","_id":"cl2q2mdux003nr2ve8e3w6dd8"},{"post_id":"cl2q2mduw003mr2vea3za04ty","tag_id":"cl2q2mduv003gr2ve7ek1f28h","_id":"cl2q2mdux003or2ve7oaubqko"}],"Tag":[{"name":"JavaScript","_id":"cl2q2mdtq0005r2veghal6b16"},{"name":"前端","_id":"cl2q2mdtv000dr2veey2ae50q"},{"name":"读书笔记","_id":"cl2q2mduh001ur2ve9k7096pd"},{"name":"时间管理","_id":"cl2q2mduj0020r2ved0u7f0y8"},{"name":"Java","_id":"cl2q2mduk0026r2ved8li5mwk"},{"name":"Ruby","_id":"cl2q2mdup002sr2ve8qhg7972"},{"name":"后端","_id":"cl2q2mdus0031r2ve1pti9aaf"},{"name":"爬虫","_id":"cl2q2mdut0037r2ve9kur6126"},{"name":"c","_id":"cl2q2mduu003br2ve0j6a08pq"},{"name":"运维","_id":"cl2q2mduv003gr2ve7ek1f28h"}]}}