# 前言（啰嗦两句）

作为一名普通野鸡大学的毕业的科班生，虽然在学校学过《数据结构》这样一门课程，但彼时的我所有的编码经验也就只是写过一些诸如杨辉三角，水仙花数之类的例题，因而在结课后很快就还给老师了……

最近颇乏于写应用层代码，终于又双叒叕难得想学数据结构了，遂打算开一个系列，希望能够有始有终的写完。

[yuchiXiong/data-structure: 我又双叒叕准备学数据结构啦](https://github.com/yuchiXiong/data-structure)


# 参考

## CSTL

区分序列容器 `Sequence containers` 和容器适配器 `Container adaptors`

顺序表 impl 栈 => 顺序栈

单链表 impl 栈 => 链式栈

顺序表 impl 队列 => 顺序队列

单链表 impl 队列 => 链式队列


---
---
---
# 1. 线性表是什么？
> [wiki](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8): 线性表是一个具有顺序的，由同类型数据组成的集合，它是常用的数据结构之一。

线性表具有几个基本特征：
1. 有限性，线性表是一个有限序列。
2. 有序性，线性表具有基本的有序性。
3. 同一性，线性表元素具有相同的类型。

关于上述3，在参考广义表的相关定义后，我认为应该更完整的描述为：线性表由同类型数据组成，且该类型被限定为原子类型（如整数、字符串、布尔值等），而非结构类型（如数组、结构体、类等）。

关于 `线性` ，我们知道数据结构中还定义了其他诸多非线性数据结构如树、图等。它们的一个共同特点就是其并非在计算机中存储时就表现为树状或图状，而是从逻辑上抽象为树状或图状。线性结构与之类似，当我们将线性表的元素按照顺序排列时，它呈现为一条线段，因而我们称之为线性结构。对应的，当我们将广义表的元素按照其层次排列时，它并不是一条线段，而更像是一个平面，这正是我们说广义表是一种非线性数据结构的原因，同时也是线性表同一性限制存在的原因。


# 2. 顺序存储与链式存储
线性表的线性是逻辑层面的，但实际无论是线性表，广义表，还是树，图等，在计算机中存储时，都无外乎两种形式：顺序存储和链式存储。

## 2.1 顺序存储与顺序表
在计算机中存储数据的第一种方式是顺序存储，基于顺序存储方式实现的线性表称为顺序表，举一个比较形象的例子：

*你和你的小伙伴一起去看电影，此时你希望你们可以坐在一起，因而你们选择购买了某一座位开始往后的多个**连续**的座位。*

我们不难发现，在这一案例中有几个重要的细节：

1. 我们需要一次性购买多个连续的座位。
2. 当我们知道第一个座位的编号时，很容通过第一个座位的编号，计算出后面的座位的编号。
3. 当我们希望在保持原有的座位顺序的前提下，插入一个新的座位时，我们需要将原有的每一个座位向后移动一个位置。
4. 当我们希望在保持原有的座位顺序的前提下，删除一个已有座位时，我们需要将原有的每一个座位向前移动一个位置。

我们将这个例子映射到顺序表中，就可以得到顺序表的几个重要特征：

1. 在使用顺序表时，我们需要一次性申请存储元素所需要的存储空间。
2. 通过元素下标我们可以快速的访问元素。
3. 在插入元素到顺序表中时，我们需要将原有的每一个元素向后移动一个位置。

这些特征决定了顺序表最重要的优点：访问速度快。通过下面我们能在 `O(1)` 时间复杂度内访问到某个元素。

但同时，这些特征也暴露了顺序表的缺点：
1. 由于在使用前需要一次性申请指定容量的空间，当遇到数据增长速度较快的场景时，顺序表容量可能会达到最大值而无法添加新的数据，但如果一次性申请的空间过大，则又容易造成浪费。
2. 如果需要对顺序表进行扩容，则需要额外的空间来进行数据的复制。
3. 如果需要插入元素到顺序表中，则需要将原有的每一个元素向后移动一个位置，时间复杂度为 `O(n)`。

最后，以 `C` 语言为例，我们可以将数组看作一个顺序表，但值得注意的是，在部分动态语言如 `Python/JavaScript/Ruby` 等中，数组元素的类型是动态的，它可以是数组、对象等任何类型的数据，此时的数组则更应该看作广义表而非线性表。

## 2.2 链式存储与链表
在计算机中存储数据的另一种方式是链式存储，基于链式存储方式实现的线性表称为链表。

链表的每一个节点分散存储在不同的地址，而后使用一个 `next` 指针来指向下一个节点，最终实现了维护其逻辑上的线性的目的。这样做的好处是当我们需要对链表进行修改时，无需再对其他元素进行移动操作：

1. 当需要在链表中插入新节点时，我们只需要修改目标位置上一个位置节点的 `next` 指针指向新节点，然后将新节点的 `next` 指针指向原有位置上的节点即可。
2. 当需要在链表中删除一个节点时，我们只需要将目标位置上的节点的 `next` 指针指向目标位置上的下一个节点即可。
3. 当需要在表头插入新节点时，我们只需要将新节点的 `next` 指针指向原有的表头即可。
4. 当需要在表尾插入新节点时，我们只需要将表尾节点的 `next` 指针指向新节点即可。

但由于链表的线性关系是通过 `next` 指针来实现的，因此当希望读取链表的某一个元素时，无法通过下标的方式以 `O(1)` 的时间复杂度完成而是需要进行遍历，时间复杂度为 `O(n)`。

参考代码实现可见 [LinkedList](https://github.com/yuchiXiong/data-structure/blob/main/List/LinkedList.cpp)

# 3. 常见线性数据结构
在实际的使用过程中，我们经常基于线性表来实现一些更符合业务场景的数据结构。
## 3.1 变长数组
由于顺序表始终需要维护一个固定的长度，在使用过程中扩容极不方便，因而我们可以基于顺序表来实现一个变长数组，使其能够在使用的过程中进行动态扩容。

`Java Collection Framework`（简称 `JCF`) 中实现的 `ArrayList/Vector` 以及 `CPP STL Container adaptors` 中提供的 `Vector` 都可以看作一个变长数组。其实现的原理大致为当向数组中添加或删除元素时，首先检查数组的容量：

1. 如果当前数组的容量不足以添加新的元素，将数组扩容（通常为原来的两倍），然后将原来的数据复制到新的数组中。
2. 如果当前数组的使用容量低于阈值（通常是当前容量的 `1/4` ），将数组的容量缩小为原来的一半，然后将原来的数据复制到新的数组中。

参考代码实现可见 [Vector](https://github.com/yuchiXiong/data-structure/blob/main/List/Vector.cpp)

## 3.2 顺序栈


## 3.3 链式栈
## 3.4 顺序队列
## 3.5 链式队列
## 3.6 双端队列
## 3.7 顺序双端队列

# 4. 参考
- [CPP Reference Containers library](https://en.cppreference.com/w/cpp/container)
